{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PromptManager Documentation","text":"\u26a0\ufe0f CAUTION \u26a0\ufe0f   Breaking Changes are Coming   See Roadmap for details  <p>Like an enchanted librarian organizing floating books of knowledge, PromptManager helps you masterfully orchestrate and organize your AI prompts through wisdom and experience.</p> <p>Each prompt becomes a living entity that can be categorized, parameterized, and interconnected with golden threads of relationships.</p> Key Features <ul> <li>\ud83d\udcda Multiple Storage Adapters</li> <li>\ud83d\udd27 Parameterized Prompts</li> <li>\ud83d\udccb Directive Processing</li> <li>\ud83c\udfa8 ERB Integration</li> <li>\ud83c\udf0d Shell Integration</li> <li>\ud83d\udcd6 Inline Documentation</li> <li>\ud83d\udcca Parameter History</li> <li>\u26a1 Error Handling</li> <li>\ud83d\udd0c Extensible Architecture</li> </ul>"},{"location":"#what-is-promptmanager","title":"What is PromptManager?","text":"<p>PromptManager is a Ruby gem designed for managing parameterized prompts used in generative AI applications. It provides a sophisticated system for organizing, templating, and processing prompts with support for multiple storage backends, directive processing, and advanced templating features.</p> <p>Think of it as your personal AI prompt librarian - organizing your prompts, managing their parameters, processing their directives, and ensuring they're always ready when you need them.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get up and running with PromptManager in minutes:</p> InstallationBasic UsageCreate a Prompt <pre><code>gem install prompt_manager\n# or add to Gemfile\nbundle add prompt_manager\n</code></pre> <pre><code>require 'prompt_manager'\n\n# Configure storage\nPromptManager::Prompt.storage_adapter = \n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = '~/.prompts'\n  end.new\n\n# Use a prompt\nprompt = PromptManager::Prompt.new(id: 'greeting')\nprompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[LANGUAGE]\" =&gt; \"English\"\n}\n\nputs prompt.to_s\n</code></pre> <pre><code># ~/.prompts/greeting.txt\n# Description: A friendly greeting prompt\n\nHello [NAME]! How can I assist you today?\nPlease respond in [LANGUAGE].\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>PromptManager follows a modular architecture designed for flexibility and extensibility:</p> <pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Your Application]\n        P[PromptManager::Prompt]\n    end\n\n    subgraph \"Processing Layer\"\n        D[Directive Processor]\n        E[ERB Engine]\n        K[Keyword Substitution]\n    end\n\n    subgraph \"Storage Layer\"\n        FS[FileSystem Adapter]\n        AR[ActiveRecord Adapter]\n        CA[Custom Adapter]\n    end\n\n    A --&gt; P\n    P --&gt; D\n    P --&gt; E\n    P --&gt; K\n    P --&gt; FS\n    P --&gt; AR\n    P --&gt; CA\n\n    D --&gt; |includes| FS\n    E --&gt; |templates| P\n    K --&gt; |substitutes| P</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#parameterized-prompts","title":"Parameterized Prompts","text":"<p>Transform static prompts into dynamic templates:</p> <pre><code># Template with parameters\nprompt_text = \"Translate '[TEXT]' from [SOURCE_LANG] to [TARGET_LANG]\"\n\n# Filled with values\nprompt.parameters = {\n  \"[TEXT]\" =&gt; \"Hello world\",\n  \"[SOURCE_LANG]\" =&gt; \"English\", \n  \"[TARGET_LANG]\" =&gt; \"Spanish\"\n}\n\n# Result: \"Translate 'Hello world' from English to Spanish\"\n</code></pre>"},{"location":"#directive-processing","title":"Directive Processing","text":"<p>Use JCL-style directives for prompt composition:</p> <pre><code># Common header for all customer service prompts\n//include common/customer_service_header.txt\n\n# Dynamic template inclusion\n//include templates/[TEMPLATE_TYPE].txt\n\nHandle this customer inquiry about [TOPIC].\n</code></pre>"},{"location":"#storage-adapters","title":"Storage Adapters","text":"<p>Choose your preferred storage backend:</p> <ul> <li>FileSystemAdapter: Store prompts as text files</li> <li>ActiveRecordAdapter: Store prompts in a database  </li> <li>Custom Adapters: Build your own storage solution</li> </ul>"},{"location":"#why-promptmanager","title":"Why PromptManager?","text":""},{"location":"#organized-prompts","title":"\ud83c\udfaf Organized Prompts","text":"<p>Keep your prompts organized in a structured, searchable format instead of scattered across your codebase.</p>"},{"location":"#reusable-templates","title":"\ud83d\udd04 Reusable Templates","text":"<p>Create parameterized templates that can be reused across different contexts and applications.</p>"},{"location":"#powerful-processing","title":"\ud83d\udee0\ufe0f Powerful Processing","text":"<p>Advanced features like directive processing, ERB templating, and environment variable substitution.</p>"},{"location":"#scalable-architecture","title":"\ud83d\udcc8 Scalable Architecture","text":"<p>Modular design supports everything from simple scripts to enterprise applications.</p>"},{"location":"#easy-management","title":"\ud83d\udd0d Easy Management","text":"<p>Built-in search capabilities and parameter history make prompt management effortless.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to dive in? Here are some great places to start:</p> <ul> <li> <p> Quick Start</p> <p>Get PromptManager running in your project within minutes</p> <p> Quick Start</p> </li> <li> <p> Core Features</p> <p>Learn about parameterized prompts, directives, and more</p> <p> Core Features</p> </li> <li> <p> Storage Adapters</p> <p>Choose the right storage solution for your needs</p> <p> Storage Options</p> </li> <li> <p> API Reference</p> <p>Complete reference for all classes and methods</p> <p> API Docs</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: MadBomber/prompt_manager</li> <li>RubyGems: prompt_manager</li> <li>Issues: Report bugs or request features</li> <li>Discussions: Community discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>PromptManager is released under the MIT License.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides comprehensive examples demonstrating various features and use cases of PromptManager.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to get started with PromptManager:</p> <pre><code># examples/simple.rb\nrequire 'prompt_manager'\n\n# Configure storage adapter\nPromptManager::Prompt.storage_adapter =\n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = '~/.prompts'\n  end.new\n\n# Create and use a prompt\nprompt = PromptManager::Prompt.new(id: 'greeting')\nprompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[LANGUAGE]\" =&gt; \"English\"\n}\n\n# Get the processed prompt text\nputs prompt.to_s\n</code></pre>"},{"location":"examples/#advanced-integration-with-llm-and-streaming","title":"Advanced Integration with LLM and Streaming","text":"<p>The advanced_integrations.rb example demonstrates a complete integration with OpenAI's API, showcasing:</p>"},{"location":"examples/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>ERB templating for dynamic content generation</li> <li>Shell integration for environment variable substitution  </li> <li>OpenAI API integration with streaming responses</li> <li>Professional UI with spinner feedback using <code>tty-spinner</code></li> <li>Real-time streaming of LLM responses</li> </ul>"},{"location":"examples/#code-overview","title":"Code Overview","text":"<pre><code>#!/usr/bin/env ruby\n# frozen_string_literal: true\n\nrequire 'bundler/inline'\n\ngemfile do\n  source 'https://rubygems.org'\n  gem 'prompt_manager'\n  gem 'ruby-openai'\n  gem 'tty-spinner'\nend\n\nrequire 'prompt_manager'\nrequire 'openai'\nrequire 'erb'\nrequire 'time'\nrequire 'tty-spinner'\n\n# Configure PromptManager with filesystem adapter\nPromptManager::Prompt.storage_adapter = PromptManager::Storage::FileSystemAdapter.config do |config|\n  config.prompts_dir = File.join(__dir__, 'prompts_dir')\nend.new\n\n# Configure OpenAI client\nclient = OpenAI::Client.new(\n  access_token: ENV['OPENAI_API_KEY']\n)\n\n# Get prompt instance with advanced features enabled\nprompt = PromptManager::Prompt.new(\n  id: 'advanced_demo',\n  erb_flag: true,    # Enable ERB templating\n  envar_flag: true   # Enable environment variable substitution\n)\n\n# Show spinner while waiting for response\nspinner = TTY::Spinner.new(\"[:spinner] Waiting for response...\")\nspinner.auto_spin\n\n# Stream the response from OpenAI\nresponse = client.chat(\n  parameters: {\n    model: 'gpt-4o-mini',\n    messages: [{ role: 'user', content: prompt.to_s }],\n    stream: proc do |chunk, _bytesize|\n      spinner.stop\n      content = chunk.dig(\"choices\", 0, \"delta\", \"content\")\n      print content if content\n      $stdout.flush\n    end\n  }\n)\n\nputs\n</code></pre>"},{"location":"examples/#prompt-template","title":"Prompt Template","text":"<p>The example uses a sophisticated prompt template (advanced_demo.txt) that demonstrates:</p> <pre><code># System Analysis and Historical Comparison Report\n# Generated with PromptManager - ERB + Shell Integration Demo\n\n```markdown\n## Current System Information\n\n**Timestamp**: &lt;%= Time.now.strftime('%A, %B %d, %Y at %I:%M:%S %p %Z') %&gt;\n**Analysis Duration**: &lt;%= Time.now - Time.parse('2024-01-01') %&gt; seconds since 2024 began\n\n### Hardware Platform Details\n**Architecture**: $HOSTTYPE$MACHTYPE\n**Hostname**: $HOSTNAME  \n**Operating System**: $OSTYPE\n**Shell**: $SHELL (version: $BASH_VERSION)\n**User**: $USER\n**Home Directory**: $HOME\n**Current Path**: $PWD\n**Terminal**: $TERM\n\n### Detailed System Profile\n&lt;% if RUBY_PLATFORM.include?('darwin') %&gt;\n**Platform**: macOS/Darwin System\n**Ruby Platform**: &lt;%= RUBY_PLATFORM %&gt;\n**Ruby Version**: &lt;%= RUBY_VERSION %&gt;\n**Ruby Engine**: &lt;%= RUBY_ENGINE %&gt;\n&lt;% elsif RUBY_PLATFORM.include?('linux') %&gt;\n**Platform**: Linux System  \n**Ruby Platform**: &lt;%= RUBY_PLATFORM %&gt;\n**Ruby Version**: &lt;%= RUBY_VERSION %&gt;\n**Ruby Engine**: &lt;%= RUBY_ENGINE %&gt;\n&lt;% else %&gt;\n**Platform**: Other Unix-like System\n**Ruby Platform**: &lt;%= RUBY_PLATFORM %&gt;\n**Ruby Version**: &lt;%= RUBY_VERSION %&gt;\n**Ruby Engine**: &lt;%= RUBY_ENGINE %&gt;\n&lt;% end %&gt;\n\n### Performance Context\n**Load Average**: &lt;%= `uptime`.strip rescue 'Unable to determine' %&gt;\n**Memory Info**: &lt;%= `vm_stat | head -5`.strip rescue 'Unable to determine' if RUBY_PLATFORM.include?('darwin') %&gt;\n**Disk Usage**: &lt;%= `df -h / | tail -1`.strip rescue 'Unable to determine' %&gt;\n\n## Analysis Request\n\nYou are a technology historian and systems analyst. Please provide a comprehensive comparison between this current system and **the most powerful Apple computer created in the 20th century** (which would be from the 1990s).\n</code></pre>"},{"location":"examples/#key-benefits","title":"Key Benefits","text":"<ol> <li>Dynamic Content: ERB templating allows for real-time system information gathering</li> <li>Environment Awareness: Shell integration provides current system context</li> <li>Professional UX: Spinner provides visual feedback during API calls  </li> <li>Real-time Streaming: Users see responses as they're generated</li> <li>Comprehensive Analysis: The prompt generates detailed technical comparisons</li> </ol>"},{"location":"examples/#search-integration","title":"Search Integration","text":"<p>See using_search_proc.rb for advanced search capabilities:</p> <pre><code># Configure custom search with ripgrep\nPromptManager::Storage::FileSystemAdapter.config do |config|\n  config.prompts_dir = '~/.prompts'\n  config.search_proc = -&gt;(query) {\n    # Use ripgrep for fast searching\n    `rg -l \"#{query}\" #{config.prompts_dir}`.split(\"\\n\")\n      .map { |path| File.basename(path, '.txt') }\n  }\nend.new\n\n# Search for prompts containing specific terms\nresults = PromptManager::Prompt.search(\"database queries\")\nputs \"Found prompts: #{results.join(', ')}\"\n</code></pre>"},{"location":"examples/#parameter-management","title":"Parameter Management","text":""},{"location":"examples/#basic-parameters","title":"Basic Parameters","text":"<pre><code>prompt = PromptManager::Prompt.new(id: 'template')\nprompt.parameters = {\n  \"[NAME]\" =&gt; \"John\",\n  \"[ROLE]\" =&gt; \"developer\",\n  \"[PROJECT]\" =&gt; \"web application\"\n}\n</code></pre>"},{"location":"examples/#parameter-history","title":"Parameter History","text":"<pre><code># Parameters support history tracking\nprompt.parameters = {\n  \"[NAME]\" =&gt; [\"Alice\", \"Bob\", \"Charlie\"]  # Charlie is most recent\n}\n\n# Access current value\ncurrent_name = prompt.parameters[\"[NAME]\"].last\n\n# Access history\nname_history = prompt.parameters[\"[NAME]\"]\n</code></pre>"},{"location":"examples/#custom-storage-adapters","title":"Custom Storage Adapters","text":""},{"location":"examples/#redis-storage-example","title":"Redis Storage Example","text":"<pre><code>require 'redis'\nrequire 'json'\n\nclass RedisAdapter\n  def initialize(redis_client)\n    @redis = redis_client\n  end\n\n  def get(id:)\n    {\n      id: id,\n      text: @redis.get(\"prompt:#{id}:text\") || \"\",\n      parameters: JSON.parse(@redis.get(\"prompt:#{id}:params\") || '{}')\n    }\n  end\n\n  def save(id:, text:, parameters:)\n    @redis.set(\"prompt:#{id}:text\", text)\n    @redis.set(\"prompt:#{id}:params\", parameters.to_json)\n  end\n\n  def delete(id:)\n    @redis.del(\"prompt:#{id}:text\", \"prompt:#{id}:params\")\n  end\n\n  def search(query)\n    # Simple search implementation\n    @redis.keys(\"prompt:*:text\").select do |key|\n      content = @redis.get(key)\n      content&amp;.include?(query)\n    end.map { |key| key.split(':')[1] }\n  end\n\n  def list\n    @redis.keys(\"prompt:*:text\").map { |key| key.split(':')[1] }\n  end\nend\n\n# Usage\nredis = Redis.new\nPromptManager::Prompt.storage_adapter = RedisAdapter.new(redis)\n</code></pre>"},{"location":"examples/#directive-processing","title":"Directive Processing","text":""},{"location":"examples/#custom-directives","title":"Custom Directives","text":"<pre><code>class CustomDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def process_directive(directive, prompt)\n    case directive\n    when /^\\/\\/model (.+)$/\n      set_model($1)\n    when /^\\/\\/temperature (.+)$/\n      set_temperature($1.to_f)\n    when /^\\/\\/max_tokens (\\d+)$/\n      set_max_tokens($1.to_i)\n    else\n      super  # Handle built-in directives\n    end\n  end\n\n  private\n\n  def set_model(model)\n    @model = model\n  end\n\n  def set_temperature(temp)\n    @temperature = temp\n  end\n\n  def set_max_tokens(tokens)\n    @max_tokens = tokens\n  end\nend\n\n# Usage\nprompt = PromptManager::Prompt.new(\n  id: 'ai_prompt',\n  directives_processor: CustomDirectiveProcessor.new\n)\n</code></pre>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'nonexistent')\n  result = prompt.to_s\nrescue PromptManager::StorageError =&gt; e\n  puts \"Storage error: #{e.message}\"\nrescue PromptManager::ParameterError =&gt; e\n  puts \"Parameter error: #{e.message}\"\nrescue PromptManager::ConfigurationError =&gt; e\n  puts \"Configuration error: #{e.message}\"\nend\n</code></pre>"},{"location":"examples/#testing-integration","title":"Testing Integration","text":"<pre><code># Test helper for prompt testing\ndef test_prompt(id, params = {})\n  prompt = PromptManager::Prompt.new(id: id)\n  prompt.parameters = params\n  prompt.to_s\nend\n\n# Example test\ndescribe \"greeting prompt\" do\n  it \"personalizes the greeting\" do\n    result = test_prompt('greeting', {\n      \"[NAME]\" =&gt; \"Alice\",\n      \"[TIME]\" =&gt; \"morning\"\n    })\n\n    expect(result).to include(\"Hello Alice\")\n    expect(result).to include(\"Good morning\")\n  end\nend\n</code></pre> <p>For more examples and advanced usage patterns, see the complete examples in the examples/ directory.</p>"},{"location":"advanced/custom-keywords/","title":"Custom Keywords","text":"<p>PromptManager allows you to define custom keywords and parameter patterns beyond the standard <code>[PARAMETER_NAME]</code> syntax.</p>"},{"location":"advanced/custom-keywords/#overview","title":"Overview","text":"<p>Custom keywords enable you to create domain-specific parameter patterns, validation rules, and transformation logic for your prompts.</p>"},{"location":"advanced/custom-keywords/#defining-custom-keywords","title":"Defining Custom Keywords","text":""},{"location":"advanced/custom-keywords/#basic-custom-keywords","title":"Basic Custom Keywords","text":"<pre><code>PromptManager.configure do |config|\n  config.custom_keywords = {\n    'EMAIL' =&gt; {\n      pattern: /\\{EMAIL:([^}]+)\\}/,\n      validator: -&gt;(value) { value.match?(/\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i) },\n      transformer: -&gt;(value) { value.downcase }\n    },\n\n    'PHONE' =&gt; {\n      pattern: /\\{PHONE:([^}]+)\\}/,\n      validator: -&gt;(value) { value.match?(/\\A\\+?[\\d\\-\\(\\)\\s]+\\z/) },\n      transformer: -&gt;(value) { value.gsub(/[^\\d+]/, '') }\n    },\n\n    'CURRENCY' =&gt; {\n      pattern: /\\{CURRENCY:([^}]+):([A-Z]{3})\\}/,\n      transformer: -&gt;(amount, currency) { \n        formatted = sprintf('%.2f', amount.to_f)\n        case currency\n        when 'USD' then \"$#{formatted}\"\n        when 'EUR' then \"\u20ac#{formatted}\"\n        else \"#{formatted} #{currency}\"\n        end\n      }\n    }\n  }\nend\n</code></pre>"},{"location":"advanced/custom-keywords/#usage-in-prompts","title":"Usage in Prompts","text":"<pre><code># email_template.txt\nDear Customer,\n\nYour account {EMAIL:customer_email} has been updated.\nPlease contact us at {PHONE:support_phone} if you have questions.\nYour order total is {CURRENCY:order_amount:USD}.\n\nBest regards,\nSupport Team\n</code></pre> <pre><code>prompt = PromptManager::Prompt.new(id: 'email_template')\nresult = prompt.render(\n  customer_email: 'JOHN.DOE@EXAMPLE.COM',\n  support_phone: '1-800-555-0123',\n  order_amount: 123.45\n)\n\n# Result:\n# Dear Customer,\n# Your account john.doe@example.com has been updated.\n# Please contact us at +18005550123 if you have questions.\n# Your order total is $123.45.\n</code></pre>"},{"location":"advanced/custom-keywords/#advanced-custom-keywords","title":"Advanced Custom Keywords","text":""},{"location":"advanced/custom-keywords/#conditional-keywords","title":"Conditional Keywords","text":"<pre><code>config.custom_keywords['IF_PREMIUM'] = {\n  pattern: /\\{IF_PREMIUM:([^}]+)\\}/,\n  processor: -&gt;(content, context) {\n    user_tier = context.dig(:parameters, :user_tier)\n    user_tier == 'premium' ? content : ''\n  }\n}\n</code></pre> <pre><code># Usage in prompt:\n{IF_PREMIUM:\ud83c\udf1f Thank you for being a Premium member!}\n</code></pre>"},{"location":"advanced/custom-keywords/#loop-keywords","title":"Loop Keywords","text":"<pre><code>config.custom_keywords['FOREACH'] = {\n  pattern: /\\{FOREACH:([^:]+):([^}]+)\\}/,\n  processor: -&gt;(array_name, template, context) {\n    array_data = context.dig(:parameters, array_name.to_sym) || []\n\n    array_data.map.with_index do |item, index|\n      item_template = template.gsub(/\\{ITEM\\.(\\w+)\\}/) { item[Regexp.last_match(1).to_sym] }\n      item_template.gsub(/\\{INDEX\\}/, index.to_s)\n    end.join(\"\\n\")\n  }\n}\n</code></pre> <pre><code># Usage in prompt:\nYour order items:\n{FOREACH:order_items:- {ITEM.name}: ${ITEM.price}}\n</code></pre>"},{"location":"advanced/custom-keywords/#datetime-keywords","title":"Date/Time Keywords","text":"<pre><code>config.custom_keywords['DATE'] = {\n  pattern: /\\{DATE:([^:}]+)(?::([^}]+))?\\}/,\n  processor: -&gt;(format, offset, context) {\n    base_date = Time.current\n\n    if offset\n      case offset\n      when /\\+(\\d+)d/ then base_date += Regexp.last_match(1).to_i.days\n      when /-(\\d+)d/ then base_date -= Regexp.last_match(1).to_i.days\n      when /\\+(\\d+)w/ then base_date += Regexp.last_match(1).to_i.weeks\n      end\n    end\n\n    base_date.strftime(format)\n  }\n}\n</code></pre> <pre><code># Usage in prompt:\nToday: {DATE:%B %d, %Y}\nNext week: {DATE:%B %d, %Y:+7d}\nLast month: {DATE:%B %Y:-1m}\n</code></pre>"},{"location":"advanced/custom-keywords/#validation-and-error-handling","title":"Validation and Error Handling","text":""},{"location":"advanced/custom-keywords/#parameter-validation","title":"Parameter Validation","text":"<pre><code>config.custom_keywords['VALIDATED_EMAIL'] = {\n  pattern: /\\{EMAIL:([^}]+)\\}/,\n  validator: -&gt;(email) {\n    return false unless email.is_a?(String)\n    return false unless email.match?(/\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i)\n\n    # Additional validation\n    domain = email.split('@').last\n    !['tempmail.com', 'throwaway.email'].include?(domain)\n  },\n  error_message: 'Please provide a valid email address from an allowed domain'\n}\n</code></pre>"},{"location":"advanced/custom-keywords/#custom-error-handling","title":"Custom Error Handling","text":"<pre><code>class CustomKeywordProcessor\n  def self.process_keyword(keyword, args, context)\n    case keyword\n    when 'SECURE_DATA'\n      return '[REDACTED]' if context[:redact_sensitive_data]\n      args.first\n\n    when 'API_CALL'\n      begin\n        api_result = make_api_call(args.first)\n        api_result['data']\n      rescue =&gt; e\n        Rails.logger.error \"API call failed: #{e.message}\"\n        '[API_ERROR]'\n      end\n\n    else\n      raise PromptManager::UnknownKeywordError.new(\"Unknown keyword: #{keyword}\")\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/custom-keywords/#dynamic-keywords","title":"Dynamic Keywords","text":""},{"location":"advanced/custom-keywords/#runtime-registration","title":"Runtime Registration","text":"<pre><code>class DynamicKeywordManager\n  def self.register_for_user(user)\n    PromptManager.configure do |config|\n      config.custom_keywords ||= {}\n\n      # User-specific keywords\n      config.custom_keywords[\"USER_#{user.id}_NAME\"] = {\n        pattern: /\\{USER_NAME\\}/,\n        processor: -&gt;(*args, context) { user.full_name }\n      }\n\n      # Role-based keywords\n      if user.admin?\n        config.custom_keywords['ADMIN_PANEL'] = {\n          pattern: /\\{ADMIN_PANEL:([^}]+)\\}/,\n          processor: -&gt;(content, context) { content }\n        }\n      end\n    end\n  end\nend\n\n# Usage\nDynamicKeywordManager.register_for_user(current_user)\n</code></pre>"},{"location":"advanced/custom-keywords/#database-driven-keywords","title":"Database-Driven Keywords","text":"<pre><code>class DatabaseKeywordLoader\n  def self.load_keywords\n    CustomKeyword.active.each do |keyword_record|\n      PromptManager.configure do |config|\n        config.custom_keywords[keyword_record.name] = {\n          pattern: Regexp.new(keyword_record.pattern),\n          processor: eval(keyword_record.processor_code),\n          description: keyword_record.description\n        }\n      end\n    end\n  end\nend\n\n# Load keywords on application startup\nDatabaseKeywordLoader.load_keywords\n</code></pre>"},{"location":"advanced/custom-keywords/#integration-with-erb","title":"Integration with ERB","text":""},{"location":"advanced/custom-keywords/#erb-enhanced-keywords","title":"ERB-Enhanced Keywords","text":"<pre><code>config.custom_keywords['ERB_EVAL'] = {\n  pattern: /\\{ERB:([^}]+)\\}/,\n  processor: -&gt;(erb_code, context) {\n    template = ERB.new(erb_code)\n    template.result(binding)\n  }\n}\n</code></pre> <pre><code># Usage in prompt:\nCurrent time: {ERB:&lt;%= Time.current.strftime('%H:%M') %&gt;}\nRandom number: {ERB:&lt;%= rand(100) %&gt;}\n</code></pre>"},{"location":"advanced/custom-keywords/#template-inheritance","title":"Template Inheritance","text":"<pre><code>config.custom_keywords['PARENT'] = {\n  pattern: /\\{PARENT:([^}]+)\\}/,\n  processor: -&gt;(parent_template, context) {\n    parent_prompt = PromptManager::Prompt.new(id: parent_template)\n    parent_prompt.render(context[:parameters])\n  }\n}\n</code></pre>"},{"location":"advanced/custom-keywords/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/custom-keywords/#keyword-caching","title":"Keyword Caching","text":"<pre><code>class CachedKeywordProcessor\n  @cache = {}\n\n  def self.process_with_cache(keyword, args, context, cache_ttl: 300)\n    cache_key = \"#{keyword}:#{args.join(':')}:#{context.hash}\"\n\n    cached_result = @cache[cache_key]\n    if cached_result &amp;&amp; (Time.current - cached_result[:timestamp]) &lt; cache_ttl\n      return cached_result[:value]\n    end\n\n    result = process_keyword(keyword, args, context)\n    @cache[cache_key] = {\n      value: result,\n      timestamp: Time.current\n    }\n\n    result\n  end\nend\n</code></pre>"},{"location":"advanced/custom-keywords/#lazy-evaluation","title":"Lazy Evaluation","text":"<pre><code>config.custom_keywords['LAZY_LOAD'] = {\n  pattern: /\\{LAZY:([^}]+)\\}/,\n  processor: -&gt;(data_source, context) {\n    # Only load data when actually needed\n    -&gt; { expensive_data_load(data_source) }\n  }\n}\n</code></pre>"},{"location":"advanced/custom-keywords/#testing-custom-keywords","title":"Testing Custom Keywords","text":""},{"location":"advanced/custom-keywords/#rspec-examples","title":"RSpec Examples","text":"<pre><code>describe 'Custom Keywords' do\n  before do\n    PromptManager.configure do |config|\n      config.custom_keywords = {\n        'TEST_UPPER' =&gt; {\n          pattern: /\\{UPPER:([^}]+)\\}/,\n          transformer: -&gt;(value) { value.upcase }\n        }\n      }\n    end\n  end\n\n  it 'processes custom keyword' do\n    prompt = PromptManager::Prompt.new(id: 'test')\n    allow(prompt.storage).to receive(:read).and_return('Hello {UPPER:world}')\n\n    result = prompt.render\n    expect(result).to eq 'Hello WORLD'\n  end\n\n  it 'validates custom keyword input' do\n    PromptManager.configure do |config|\n      config.custom_keywords['VALIDATED'] = {\n        pattern: /\\{VALIDATED:([^}]+)\\}/,\n        validator: -&gt;(value) { value.length &gt; 3 },\n        error_message: 'Value must be longer than 3 characters'\n      }\n    end\n\n    prompt = PromptManager::Prompt.new(id: 'test')\n    allow(prompt.storage).to receive(:read).and_return('Hello {VALIDATED:ab}')\n\n    expect {\n      prompt.render\n    }.to raise_error(PromptManager::ValidationError, /Value must be longer than 3 characters/)\n  end\nend\n</code></pre>"},{"location":"advanced/custom-keywords/#real-world-examples","title":"Real-World Examples","text":""},{"location":"advanced/custom-keywords/#e-commerce-keywords","title":"E-commerce Keywords","text":"<pre><code>PromptManager.configure do |config|\n  config.custom_keywords.merge!({\n    'PRICE' =&gt; {\n      pattern: /\\{PRICE:([^:}]+)(?::([A-Z]{3}))?\\}/,\n      processor: -&gt;(amount, currency, context) {\n        currency ||= 'USD'\n        user_country = context.dig(:parameters, :user_country)\n\n        # Adjust currency based on user location\n        case user_country\n        when 'GB' then currency = 'GBP'\n        when 'DE', 'FR', 'IT' then currency = 'EUR'\n        end\n\n        CurrencyFormatter.format(amount.to_f, currency)\n      }\n    },\n\n    'INVENTORY_STATUS' =&gt; {\n      pattern: /\\{STOCK:([^}]+)\\}/,\n      processor: -&gt;(product_id, context) {\n        stock_level = InventoryService.check_stock(product_id)\n\n        case stock_level\n        when 0 then '\u274c Out of Stock'\n        when 1..5 then '\u26a0\ufe0f Low Stock'\n        else '\u2705 In Stock'\n        end\n      }\n    }\n  })\nend\n</code></pre>"},{"location":"advanced/custom-keywords/#localization-keywords","title":"Localization Keywords","text":"<pre><code>config.custom_keywords['TRANSLATE'] = {\n  pattern: /\\{T:([^:}]+)(?::([a-z]{2}))?\\}/,\n  processor: -&gt;(key, locale, context) {\n    locale ||= context.dig(:parameters, :locale) || 'en'\n    I18n.with_locale(locale) { I18n.t(key) }\n  }\n}\n\nconfig.custom_keywords['PLURALIZE'] = {\n  pattern: /\\{PLURAL:([^:]+):([^:]+):([^}]+)\\}/,\n  processor: -&gt;(count, singular, plural, context) {\n    count_val = context.dig(:parameters, count.to_sym) || 0\n    count_val.to_i == 1 ? singular : plural\n  }\n}\n</code></pre>"},{"location":"advanced/custom-keywords/#best-practices","title":"Best Practices","text":"<ol> <li>Descriptive Names: Use clear, descriptive names for custom keywords</li> <li>Validation: Always validate input parameters</li> <li>Error Handling: Provide meaningful error messages</li> <li>Documentation: Document keyword syntax and behavior</li> <li>Performance: Cache expensive operations</li> <li>Security: Sanitize user input in keyword processors</li> <li>Testing: Write comprehensive tests for custom keywords</li> <li>Consistency: Follow consistent naming conventions across keywords</li> </ol>"},{"location":"advanced/dynamic-directives/","title":"Dynamic Directives","text":"<p>Dynamic directives allow you to create sophisticated, runtime-configurable prompt processing behaviors that go beyond static <code>//include</code> statements.</p>"},{"location":"advanced/dynamic-directives/#overview","title":"Overview","text":"<p>Dynamic directives are custom processing instructions that can modify prompt content based on runtime conditions, external data sources, user context, and complex business logic.</p>"},{"location":"advanced/dynamic-directives/#creating-dynamic-directives","title":"Creating Dynamic Directives","text":""},{"location":"advanced/dynamic-directives/#basic-dynamic-directive","title":"Basic Dynamic Directive","text":"<pre><code>PromptManager.configure do |config|\n  config.directive_processor.register_directive('current_time') do |args, context|\n    format = args.strip.empty? ? '%Y-%m-%d %H:%M:%S' : args.strip\n    Time.current.strftime(format)\n  end\nend\n</code></pre> <pre><code># Usage in prompts:\nGenerated at: //current_time\nCustom format: //current_time %B %d, %Y at %I:%M %p\n</code></pre>"},{"location":"advanced/dynamic-directives/#context-aware-directives","title":"Context-Aware Directives","text":"<pre><code>config.directive_processor.register_directive('user_greeting') do |args, context|\n  user = context.dig(:parameters, :user)\n  return 'Hello there!' unless user\n\n  time_of_day = Time.current.hour\n  greeting = case time_of_day\n             when 0..11 then 'Good morning'\n             when 12..17 then 'Good afternoon'\n             else 'Good evening'\n             end\n\n  \"#{greeting}, #{user[:name]}!\"\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#advanced-directive-patterns","title":"Advanced Directive Patterns","text":""},{"location":"advanced/dynamic-directives/#data-loading-directives","title":"Data Loading Directives","text":"<pre><code>config.directive_processor.register_directive('load_user_data') do |user_id, context|\n  begin\n    user = UserService.find(user_id)\n    context[:loaded_user] = user\n\n    # Return user summary\n    &lt;&lt;~USER_INFO\n    User: #{user.name}\n    Email: #{user.email}\n    Account Type: #{user.account_type}\n    USER_INFO\n  rescue UserNotFoundError\n    'User information unavailable'\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#api-integration-directives","title":"API Integration Directives","text":"<pre><code>config.directive_processor.register_directive('weather') do |location, context|\n  begin\n    response = HTTParty.get(\n      'https://api.weather.example.com/current',\n      query: {\n        location: location,\n        api_key: ENV['WEATHER_API_KEY']\n      }\n    )\n\n    if response.success?\n      data = response.parsed_response\n      \"Weather in #{location}: #{data['temperature']}\u00b0F, #{data['condition']}\"\n    else\n      'Weather information unavailable'\n    end\n  rescue =&gt; e\n    Rails.logger.error \"Weather API error: #{e.message}\"\n    'Weather service temporarily unavailable'\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#database-query-directives","title":"Database Query Directives","text":"<pre><code>config.directive_processor.register_directive('recent_orders') do |user_id, context|\n  user = User.find(user_id)\n  recent_orders = user.orders.recent.limit(5)\n\n  if recent_orders.any?\n    orders_list = recent_orders.map do |order|\n      \"- Order ##{order.id}: #{order.total_formatted} (#{order.status})\"\n    end.join(\"\\n\")\n\n    \"Your recent orders:\\n#{orders_list}\"\n  else\n    'You have no recent orders.'\n  end\nrescue ActiveRecord::RecordNotFound\n  'User not found'\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#conditional-logic-directives","title":"Conditional Logic Directives","text":""},{"location":"advanced/dynamic-directives/#ifelseendif-directive-system","title":"IF/ELSE/ENDIF Directive System","text":"<pre><code>class ConditionalDirectiveProcessor\n  def self.register_conditionals(processor)\n    processor.register_directive('if') do |condition, context|\n      context[:if_stack] ||= []\n\n      result = evaluate_condition(condition, context)\n      context[:if_stack].push({\n        condition_met: result,\n        in_else: false,\n        content: ''\n      })\n\n      '' # Don't output anything for the if directive itself\n    end\n\n    processor.register_directive('else') do |args, context|\n      return '' unless context[:if_stack]&amp;.any?\n\n      current_if = context[:if_stack].last\n      current_if[:in_else] = true\n\n      '' # Don't output anything for the else directive\n    end\n\n    processor.register_directive('endif') do |args, context|\n      return '' unless context[:if_stack]&amp;.any?\n\n      if_block = context[:if_stack].pop\n\n      # Process the accumulated content based on conditions\n      if (if_block[:condition_met] &amp;&amp; !if_block[:in_else]) ||\n         (!if_block[:condition_met] &amp;&amp; if_block[:in_else])\n        processor.process(if_block[:content], context)\n      else\n        ''\n      end\n    end\n  end\n\n  def self.evaluate_condition(condition, context)\n    # Simple condition evaluation\n    # In production, use a proper expression evaluator\n    case condition.strip\n    when /\\[(\\w+)\\]\\s*(==|!=|&gt;|&lt;|&gt;=|&lt;=)\\s*(.+)/\n      param_name = Regexp.last_match(1).downcase.to_sym\n      operator = Regexp.last_match(2)\n      expected_value = Regexp.last_match(3).strip.gsub(/['\"]/, '')\n\n      actual_value = context.dig(:parameters, param_name).to_s\n\n      case operator\n      when '==' then actual_value == expected_value\n      when '!=' then actual_value != expected_value\n      when '&gt;' then actual_value.to_f &gt; expected_value.to_f\n      when '&lt;' then actual_value.to_f &lt; expected_value.to_f\n      when '&gt;=' then actual_value.to_f &gt;= expected_value.to_f\n      when '&lt;=' then actual_value.to_f &lt;= expected_value.to_f\n      end\n    else\n      false\n    end\n  end\nend\n\n# Register the conditional directives\nConditionalDirectiveProcessor.register_conditionals(\n  PromptManager.configuration.directive_processor\n)\n</code></pre> <pre><code># Usage in prompts:\n//if [USER_TYPE] == 'premium'\n\ud83c\udf1f Welcome to Premium features!\n//else\nUpgrade to Premium for additional benefits.\n//endif\n\n//if [ORDER_TOTAL] &gt;= 100\n\ud83d\ude9a Free shipping applied!\n//endif\n</code></pre>"},{"location":"advanced/dynamic-directives/#loop-directives","title":"Loop Directives","text":"<pre><code>config.directive_processor.register_directive('foreach') do |args, context|\n  array_name, template = args.split(':', 2)\n  array_data = context.dig(:parameters, array_name.strip.to_sym) || []\n\n  array_data.map.with_index do |item, index|\n    # Create item context\n    item_context = context.deep_dup\n    item_context[:parameters].merge!({\n      item: item,\n      item_index: index,\n      is_first: index == 0,\n      is_last: index == array_data.length - 1,\n      total_count: array_data.length\n    })\n\n    # Process template with item context\n    processed_template = template.gsub(/\\[ITEM\\.(\\w+)\\]/i) do |match|\n      property = Regexp.last_match(1).downcase\n      item.is_a?(Hash) ? item[property.to_sym] : item.send(property)\n    end\n\n    PromptManager::DirectiveProcessor.new.process(processed_template, item_context)\n  end.join(\"\\n\")\nend\n</code></pre> <pre><code># Usage in prompts:\nYour order items:\n//foreach order_items: - [ITEM.name]: $[ITEM.price] (Qty: [ITEM.quantity])\n\n//foreach products: \n**[ITEM.name]** - $[ITEM.price]\n//if [ITEM.on_sale] == 'true'\n\ud83c\udff7\ufe0f ON SALE!\n//endif\n</code></pre>"},{"location":"advanced/dynamic-directives/#template-system-directives","title":"Template System Directives","text":""},{"location":"advanced/dynamic-directives/#layout-system","title":"Layout System","text":"<pre><code>class LayoutDirectiveProcessor\n  def self.register_layout_directives(processor)\n    processor.register_directive('layout') do |layout_name, context|\n      layout_content = processor.storage.read(\"layouts/#{layout_name}\")\n      context[:current_layout] = layout_content\n      context[:sections] ||= {}\n      '' # Layout directive doesn't output content directly\n    end\n\n    processor.register_directive('section') do |args, context|\n      section_name, content = args.split(':', 2)\n      context[:sections] ||= {}\n      context[:sections][section_name.strip] = content.strip\n      '' # Section directive stores content for later use\n    end\n\n    processor.register_directive('yield') do |section_name, context|\n      section_content = context.dig(:sections, section_name.strip) || ''\n      processor.process(section_content, context)\n    end\n\n    processor.register_directive('render_layout') do |args, context|\n      return '' unless context[:current_layout]\n\n      processor.process(context[:current_layout], context)\n    end\n  end\nend\n\nLayoutDirectiveProcessor.register_layout_directives(\n  PromptManager.configuration.directive_processor\n)\n</code></pre> <pre><code># child_template.txt:\n//layout email_layout\n//section title: Important Account Update\n//section content: Your account settings have been updated successfully.\n//render_layout\n\n# layouts/email_layout.txt:\nSubject: //yield title\n\nDear [CUSTOMER_NAME],\n\n//yield content\n\nBest regards,\nThe Support Team\n</code></pre>"},{"location":"advanced/dynamic-directives/#component-system","title":"Component System","text":"<pre><code>config.directive_processor.register_directive('component') do |args, context|\n  component_name, props_str = args.split(':', 2)\n\n  # Parse component props\n  props = {}\n  if props_str\n    props_str.scan(/(\\w+)=\"([^\"]*)\"/) do |key, value|\n      props[key.to_sym] = value\n    end\n  end\n\n  # Load component template\n  component_template = processor.storage.read(\"components/#{component_name}\")\n\n  # Create component context\n  component_context = context.deep_dup\n  component_context[:parameters].merge!(props)\n\n  # Render component\n  processor.process(component_template, component_context)\nrescue PromptManager::PromptNotFoundError\n  \"&lt;!-- Component '#{component_name}' not found --&gt;\"\nend\n</code></pre> <pre><code># Using components:\n//component button: text=\"Click Here\" url=\"https://example.com\" style=\"primary\"\n//component user_card: name=\"[USER_NAME]\" email=\"[USER_EMAIL]\"\n\n# components/button.txt:\n[Click here]([URL]) &lt;!-- [TEXT] --&gt;\n\n# components/user_card.txt:\n**[NAME]**\nEmail: [EMAIL]\n</code></pre>"},{"location":"advanced/dynamic-directives/#external-service-integration","title":"External Service Integration","text":""},{"location":"advanced/dynamic-directives/#crm-integration-directive","title":"CRM Integration Directive","text":"<pre><code>config.directive_processor.register_directive('crm_data') do |args, context|\n  data_type, customer_id = args.split(':', 2)\n\n  case data_type.strip\n  when 'customer_info'\n    customer = CRMService.get_customer(customer_id)\n    &lt;&lt;~INFO\n    Customer: #{customer.name}\n    Account Value: #{customer.lifetime_value}\n    Support Tier: #{customer.support_tier}\n    INFO\n\n  when 'recent_interactions'\n    interactions = CRMService.get_recent_interactions(customer_id, limit: 5)\n    interactions.map do |interaction|\n      \"- #{interaction.date}: #{interaction.type} - #{interaction.summary}\"\n    end.join(\"\\n\")\n\n  else\n    'Unknown CRM data type'\n  end\nrescue =&gt; e\n  Rails.logger.error \"CRM integration error: #{e.message}\"\n  'CRM data temporarily unavailable'\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#analytics-directive","title":"Analytics Directive","text":"<pre><code>config.directive_processor.register_directive('analytics') do |args, context|\n  metric_type, time_period = args.split(':', 2)\n  time_period ||= '30d'\n\n  case metric_type.strip\n  when 'user_activity'\n    user_id = context.dig(:parameters, :user_id)\n    activity = AnalyticsService.get_user_activity(user_id, time_period)\n    \"Active #{activity[:active_days]} days in the last #{time_period}\"\n\n  when 'feature_usage'\n    feature_usage = AnalyticsService.get_feature_usage(time_period)\n    top_features = feature_usage.first(3)\n    \"Top features: #{top_features.map(&amp;:name).join(', ')}\"\n\n  else\n    'Unknown analytics metric'\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/dynamic-directives/#caching-dynamic-directives","title":"Caching Dynamic Directives","text":"<pre><code>class CachedDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def initialize(**options)\n    super(**options)\n    @directive_cache = Rails.cache\n  end\n\n  def register_cached_directive(name, cache_ttl: 300, &amp;handler)\n    cached_handler = lambda do |args, context|\n      cache_key = generate_cache_key(name, args, context)\n\n      @directive_cache.fetch(cache_key, expires_in: cache_ttl) do\n        handler.call(args, context)\n      end\n    end\n\n    register_directive(name, &amp;cached_handler)\n  end\n\n  private\n\n  def generate_cache_key(directive_name, args, context)\n    relevant_params = context[:parameters].slice(:user_id, :tenant_id)\n    \"directive:#{directive_name}:#{args}:#{relevant_params.hash}\"\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#async-directive-processing","title":"Async Directive Processing","text":"<pre><code>config.directive_processor.register_directive('async_load') do |args, context|\n  data_source = args.strip\n  cache_key = \"async_data:#{data_source}:#{context[:parameters][:user_id]}\"\n\n  # Try to get cached result first\n  cached_result = Rails.cache.read(cache_key)\n  return cached_result if cached_result\n\n  # Start async job if not cached\n  AsyncDataLoadJob.perform_later(data_source, cache_key, context[:parameters])\n\n  # Return placeholder\n  \"Loading #{data_source} data...\"\nend\n\nclass AsyncDataLoadJob &lt; ApplicationJob\n  def perform(data_source, cache_key, parameters)\n    result = load_data_from_source(data_source, parameters)\n    Rails.cache.write(cache_key, result, expires_in: 1.hour)\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#testing-dynamic-directives","title":"Testing Dynamic Directives","text":""},{"location":"advanced/dynamic-directives/#rspec-examples","title":"RSpec Examples","text":"<pre><code>describe 'Dynamic Directives' do\n  let(:processor) { PromptManager::DirectiveProcessor.new(storage: storage) }\n  let(:storage) { instance_double(PromptManager::Storage::Base) }\n\n  before do\n    processor.register_directive('test_directive') do |args, context|\n      \"processed: #{args} with #{context.dig(:parameters, :test_param)}\"\n    end\n  end\n\n  it 'processes directive with context' do\n    content = \"//test_directive hello world\"\n    context = { parameters: { test_param: 'value' } }\n\n    result = processor.process(content, context)\n    expect(result).to eq \"processed: hello world with value\"\n  end\n\n  it 'handles directive errors' do\n    processor.register_directive('error_directive') do |args, context|\n      raise StandardError, 'test error'\n    end\n\n    expect {\n      processor.process(\"//error_directive test\")\n    }.to raise_error(PromptManager::DirectiveProcessingError)\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#integration-tests","title":"Integration Tests","text":"<pre><code>describe 'Dynamic Directive Integration' do\n  it 'processes complex directive chains' do\n    storage = PromptManager::Storage::FileSystemAdapter.new(prompts_dir: 'spec/fixtures')\n    processor = PromptManager::DirectiveProcessor.new(storage: storage)\n\n    # Register test directives\n    processor.register_directive('if') { |condition, context| ... }\n    processor.register_directive('foreach') { |args, context| ... }\n\n    prompt_content = &lt;&lt;~PROMPT\n    //if [USER_TYPE] == 'premium'\n    Premium Features:\n    //foreach features: - [ITEM.name]: [ITEM.description]\n    //endif\n    PROMPT\n\n    result = processor.process(prompt_content, {\n      parameters: {\n        user_type: 'premium',\n        features: [\n          { name: 'Feature 1', description: 'Description 1' },\n          { name: 'Feature 2', description: 'Description 2' }\n        ]\n      }\n    })\n\n    expect(result).to include('Feature 1: Description 1')\n    expect(result).to include('Feature 2: Description 2')\n  end\nend\n</code></pre>"},{"location":"advanced/dynamic-directives/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always handle errors gracefully in directive processors</li> <li>Performance: Cache expensive operations and use async processing when appropriate</li> <li>Security: Validate and sanitize all directive arguments</li> <li>Context Isolation: Be careful when modifying context to avoid side effects</li> <li>Documentation: Document directive syntax, parameters, and behavior</li> <li>Testing: Write comprehensive tests including error cases</li> <li>Naming: Use clear, descriptive names that indicate the directive's purpose</li> <li>Resource Management: Clean up resources and connections properly</li> </ol>"},{"location":"advanced/performance/","title":"Performance Optimization","text":"<p>This guide covers techniques and best practices for optimizing PromptManager performance in production environments.</p>"},{"location":"advanced/performance/#caching-strategies","title":"Caching Strategies","text":""},{"location":"advanced/performance/#prompt-content-caching","title":"Prompt Content Caching","text":"<pre><code># Enable built-in caching\nPromptManager.configure do |config|\n  config.cache_prompts = true\n  config.cache_ttl = 3600  # 1 hour\n  config.cache_store = ActiveSupport::Cache::RedisStore.new(\n    url: ENV['REDIS_URL'],\n    namespace: 'prompt_manager'\n  )\nend\n</code></pre>"},{"location":"advanced/performance/#custom-caching-layer","title":"Custom Caching Layer","text":"<pre><code>class CachedPromptManager\n  def self.render(prompt_id, parameters = {}, cache_options = {})\n    cache_key = generate_cache_key(prompt_id, parameters)\n\n    Rails.cache.fetch(cache_key, cache_options) do\n      prompt = PromptManager::Prompt.new(id: prompt_id)\n      prompt.render(parameters)\n    end\n  end\n\n  def self.invalidate_cache(prompt_id, parameters = nil)\n    if parameters\n      cache_key = generate_cache_key(prompt_id, parameters)\n      Rails.cache.delete(cache_key)\n    else\n      # Invalidate all cached versions of this prompt\n      Rails.cache.delete_matched(\"prompt:#{prompt_id}:*\")\n    end\n  end\n\n  private\n\n  def self.generate_cache_key(prompt_id, parameters)\n    param_hash = Digest::MD5.hexdigest(parameters.to_json)\n    \"prompt:#{prompt_id}:#{param_hash}\"\n  end\nend\n\n# Usage\nresult = CachedPromptManager.render('welcome_email', { name: 'John' }, expires_in: 30.minutes)\n</code></pre>"},{"location":"advanced/performance/#multi-level-caching","title":"Multi-level Caching","text":"<pre><code>class HierarchicalPromptCache\n  def initialize\n    @l1_cache = ActiveSupport::Cache::MemoryStore.new(size: 100) # Fast, small\n    @l2_cache = Rails.cache # Redis, larger but slower\n  end\n\n  def fetch(key, options = {}, &amp;block)\n    # Try L1 cache first\n    result = @l1_cache.read(key)\n    return result if result\n\n    # Try L2 cache\n    result = @l2_cache.fetch(key, options, &amp;block)\n\n    # Store in L1 cache for next time\n    @l1_cache.write(key, result, expires_in: 5.minutes) if result\n\n    result\n  end\n\n  def invalidate(key_pattern)\n    @l1_cache.clear\n    @l2_cache.delete_matched(key_pattern)\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#storage-optimization","title":"Storage Optimization","text":""},{"location":"advanced/performance/#connection-pooling","title":"Connection Pooling","text":"<pre><code>class PooledDatabaseAdapter &lt; PromptManager::Storage::ActiveRecordAdapter\n  def initialize(pool_size: 10, **options)\n    super(**options)\n    @connection_pool = ConnectionPool.new(size: pool_size) do\n      model_class.connection_pool.checkout\n    end\n  end\n\n  def read(prompt_id)\n    @connection_pool.with do |connection|\n      result = connection.exec_query(\n        \"SELECT content FROM prompts WHERE prompt_id = ?\",\n        'PromptManager::Read',\n        [prompt_id]\n      )\n\n      raise PromptNotFoundError unless result.any?\n      result.first['content']\n    end\n  end\n\n  def write(prompt_id, content)\n    @connection_pool.with do |connection|\n      connection.exec_insert(\n        \"INSERT INTO prompts (prompt_id, content, updated_at) VALUES (?, ?, ?) \" \\\n        \"ON CONFLICT (prompt_id) DO UPDATE SET content = ?, updated_at = ?\",\n        'PromptManager::Write',\n        [prompt_id, content, Time.current, content, Time.current]\n      )\n    end\n    true\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#bulk-operations","title":"Bulk Operations","text":"<pre><code>class BulkPromptOperations\n  def self.bulk_render(prompt_configs, batch_size: 100)\n    results = {}\n\n    prompt_configs.each_slice(batch_size) do |batch|\n      # Pre-load all prompts in the batch\n      prompt_contents = preload_prompts(batch.map { |config| config[:prompt_id] })\n\n      # Process batch in parallel\n      batch_results = Parallel.map(batch, in_threads: 4) do |config|\n        begin\n          content = prompt_contents[config[:prompt_id]]\n          next unless content\n\n          processor = PromptManager::DirectiveProcessor.new\n          result = processor.process(content, config[:parameters])\n\n          [config[:prompt_id], { success: true, result: result }]\n        rescue =&gt; e\n          [config[:prompt_id], { success: false, error: e.message }]\n        end\n      end.compact\n\n      batch_results.each do |prompt_id, result|\n        results[prompt_id] = result\n      end\n    end\n\n    results\n  end\n\n  private\n\n  def self.preload_prompts(prompt_ids)\n    # Batch load all prompts at once\n    if PromptManager.storage.respond_to?(:bulk_read)\n      PromptManager.storage.bulk_read(prompt_ids)\n    else\n      prompt_ids.each_with_object({}) do |id, hash|\n        begin\n          hash[id] = PromptManager.storage.read(id)\n        rescue PromptNotFoundError\n          # Skip missing prompts\n        end\n      end\n    end\n  end\nend\n\n# Usage\nconfigs = [\n  { prompt_id: 'welcome', parameters: { name: 'Alice' } },\n  { prompt_id: 'welcome', parameters: { name: 'Bob' } },\n  { prompt_id: 'reminder', parameters: { task: 'Meeting' } }\n]\n\nresults = BulkPromptOperations.bulk_render(configs)\n</code></pre>"},{"location":"advanced/performance/#directive-processing-optimization","title":"Directive Processing Optimization","text":""},{"location":"advanced/performance/#lazy-evaluation","title":"Lazy Evaluation","text":"<pre><code>class LazyDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def process(content, context = {})\n    # Only process directives that are actually needed\n    lazy_content = LazyContent.new(content, context)\n    lazy_content.to_s\n  end\nend\n\nclass LazyContent\n  def initialize(content, context)\n    @content = content\n    @context = context\n    @processed = false\n    @result = nil\n  end\n\n  def to_s\n    return @result if @processed\n\n    # Process only when needed\n    @result = process_directives\n    @processed = true\n    @result\n  end\n\n  private\n\n  def process_directives\n    # Only process directives that appear in the content\n    directive_pattern = %r{^//(\\w+)\\s+(.*)$}\n\n    @content.gsub(directive_pattern) do |match|\n      directive_name = Regexp.last_match(1)\n      directive_args = Regexp.last_match(2)\n\n      # Skip processing if directive handler doesn't exist\n      next match unless directive_handlers.key?(directive_name)\n\n      # Process directive\n      handler = directive_handlers[directive_name]\n      handler.call(directive_args, @context)\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#directive-compilation","title":"Directive Compilation","text":"<pre><code>class CompiledDirectiveProcessor\n  def initialize\n    @compiled_templates = {}\n  end\n\n  def compile(content)\n    template_id = Digest::MD5.hexdigest(content)\n\n    @compiled_templates[template_id] ||= compile_template(content)\n  end\n\n  def render(template_id, context)\n    compiled_template = @compiled_templates[template_id]\n    return nil unless compiled_template\n\n    compiled_template.call(context)\n  end\n\n  private\n\n  def compile_template(content)\n    # Pre-compile template into executable code\n    ruby_code = convert_to_ruby(content)\n\n    # Create a proc that can be called with context\n    eval(\"lambda { |context| #{ruby_code} }\")\n  end\n\n  def convert_to_ruby(content)\n    # Convert directive syntax to Ruby code\n    content.gsub(%r{//include\\s+(.+)}) do |match|\n      file_path = Regexp.last_match(1).strip\n      %{PromptManager.storage.read(\"#{file_path}\")}\n    end.gsub(/\\[(\\w+)\\]/) do |match|\n      param_name = Regexp.last_match(1).downcase\n      %{context[:parameters][:#{param_name}]}\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#memory-management","title":"Memory Management","text":""},{"location":"advanced/performance/#memory-efficient-prompt-loading","title":"Memory-Efficient Prompt Loading","text":"<pre><code>class StreamingPromptProcessor\n  def process_large_prompt(prompt_id, parameters = {})\n    prompt_file = PromptManager.storage.file_path(prompt_id)\n\n    Enumerator.new do |yielder|\n      File.foreach(prompt_file) do |line|\n        processed_line = process_line(line, parameters)\n        yielder &lt;&lt; processed_line unless processed_line.empty?\n      end\n    end\n  end\n\n  private\n\n  def process_line(line, parameters)\n    # Process parameters in this line\n    line.gsub(/\\[(\\w+)\\]/) do |match|\n      param_name = Regexp.last_match(1).downcase.to_sym\n      parameters[param_name] || match\n    end\n  end\nend\n\n# Usage for large prompts\nprocessor = StreamingPromptProcessor.new\nprompt_stream = processor.process_large_prompt('huge_prompt', user_id: 123)\n\nprompt_stream.each do |line|\n  # Process line by line without loading entire prompt into memory\n  output_stream.puts line\nend\n</code></pre>"},{"location":"advanced/performance/#object-pool-pattern","title":"Object Pool Pattern","text":"<pre><code>class PromptProcessorPool\n  def initialize(size: 10)\n    @pool = Queue.new\n    @size = size\n\n    size.times do\n      @pool &lt;&lt; PromptManager::DirectiveProcessor.new\n    end\n  end\n\n  def with_processor\n    processor = @pool.pop\n    begin\n      yield processor\n    ensure\n      # Reset processor state\n      processor.reset_state if processor.respond_to?(:reset_state)\n      @pool &lt;&lt; processor\n    end\n  end\nend\n\n# Global pool\nPROCESSOR_POOL = PromptProcessorPool.new(size: 20)\n\n# Usage\nPROCESSOR_POOL.with_processor do |processor|\n  result = processor.process(content, context)\nend\n</code></pre>"},{"location":"advanced/performance/#database-query-optimization","title":"Database Query Optimization","text":""},{"location":"advanced/performance/#query-optimization-for-activerecord-adapter","title":"Query Optimization for ActiveRecord Adapter","text":"<pre><code>class OptimizedActiveRecordAdapter &lt; PromptManager::Storage::ActiveRecordAdapter\n  def bulk_read(prompt_ids)\n    # Single query instead of N+1\n    prompts = model_class.where(id_column =&gt; prompt_ids)\n                        .pluck(id_column, content_column)\n                        .to_h\n\n    # Ensure all requested IDs are present\n    missing_ids = prompt_ids - prompts.keys\n    missing_ids.each { |id| prompts[id] = nil }\n\n    prompts\n  end\n\n  def read_with_metadata(prompt_id)\n    # Fetch prompt and metadata in single query\n    prompt = model_class.select(:id, :content, :metadata, :updated_at)\n                       .find_by(id_column =&gt; prompt_id)\n\n    raise PromptNotFoundError unless prompt\n\n    {\n      content: prompt.send(content_column),\n      metadata: prompt.metadata,\n      last_modified: prompt.updated_at\n    }\n  end\n\n  def frequently_used_prompts(limit: 100)\n    # Cache frequently accessed prompts\n    model_class.joins(:usage_logs)\n              .group(id_column)\n              .order('COUNT(usage_logs.id) DESC')\n              .limit(limit)\n              .pluck(id_column, content_column)\n              .to_h\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#index-optimization","title":"Index Optimization","text":"<pre><code>-- Optimize database indexes for prompt queries\n\n-- Primary lookup index\nCREATE INDEX CONCURRENTLY idx_prompts_id_active \nON prompts(prompt_id) WHERE active = true;\n\n-- Content search index (PostgreSQL)\nCREATE INDEX CONCURRENTLY idx_prompts_content_gin \nON prompts USING gin(to_tsvector('english', content));\n\n-- Metadata search index (PostgreSQL with JSONB)\nCREATE INDEX CONCURRENTLY idx_prompts_metadata_gin \nON prompts USING gin(metadata);\n\n-- Usage-based queries\nCREATE INDEX CONCURRENTLY idx_prompts_usage_updated \nON prompts(usage_count DESC, updated_at DESC);\n\n-- Composite index for filtered queries\nCREATE INDEX CONCURRENTLY idx_prompts_category_status_updated \nON prompts(category, status, updated_at DESC);\n</code></pre>"},{"location":"advanced/performance/#monitoring-and-profiling","title":"Monitoring and Profiling","text":""},{"location":"advanced/performance/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>class PromptPerformanceMonitor\n  def self.monitor_render(prompt_id, parameters = {})\n    start_time = Time.current\n    memory_before = get_memory_usage\n\n    begin\n      result = yield\n\n      duration = Time.current - start_time\n      memory_after = get_memory_usage\n      memory_used = memory_after - memory_before\n\n      log_performance_metrics(prompt_id, {\n        duration: duration,\n        memory_used: memory_used,\n        parameters_count: parameters.size,\n        result_size: result.bytesize,\n        success: true\n      })\n\n      result\n    rescue =&gt; e\n      duration = Time.current - start_time\n\n      log_performance_metrics(prompt_id, {\n        duration: duration,\n        error: e.class.name,\n        success: false\n      })\n\n      raise e\n    end\n  end\n\n  private\n\n  def self.get_memory_usage\n    GC.stat[:heap_allocated_pages] * GC::INTERNAL_CONSTANTS[:HEAP_PAGE_SIZE]\n  end\n\n  def self.log_performance_metrics(prompt_id, metrics)\n    Rails.logger.info \"PromptManager Performance: #{prompt_id}\", metrics\n\n    # Send to monitoring service\n    if defined?(StatsD)\n      StatsD.histogram('prompt_manager.render_duration', metrics[:duration])\n      StatsD.histogram('prompt_manager.memory_usage', metrics[:memory_used]) if metrics[:memory_used]\n      StatsD.increment('prompt_manager.renders', tags: [\"success:#{metrics[:success]}\"])\n    end\n  end\nend\n\n# Usage\nresult = PromptPerformanceMonitor.monitor_render('welcome_email', name: 'John') do\n  prompt = PromptManager::Prompt.new(id: 'welcome_email')\n  prompt.render(name: 'John')\nend\n</code></pre>"},{"location":"advanced/performance/#custom-profiling","title":"Custom Profiling","text":"<pre><code>class PromptProfiler\n  def self.profile_render(prompt_id, parameters = {})\n    profiler = RubyProf.profile do\n      prompt = PromptManager::Prompt.new(id: prompt_id)\n      prompt.render(parameters)\n    end\n\n    # Generate reports\n    printer = RubyProf::GraphHtmlPrinter.new(profiler)\n    File.open(\"tmp/profile_#{prompt_id}_#{Time.current.to_i}.html\", 'w') do |file|\n      printer.print(file)\n    end\n  end\n\n  def self.benchmark_operations(iterations: 100)\n    Benchmark.bmbm do |x|\n      x.report(\"File read:\") do\n        iterations.times { PromptManager.storage.read('test_prompt') }\n      end\n\n      x.report(\"Template render:\") do\n        prompt = PromptManager::Prompt.new(id: 'test_prompt')\n        iterations.times { prompt.render(name: 'test') }\n      end\n\n      x.report(\"Cached render:\") do\n        iterations.times { CachedPromptManager.render('test_prompt', name: 'test') }\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#production-deployment-optimization","title":"Production Deployment Optimization","text":""},{"location":"advanced/performance/#preloading-and-warmup","title":"Preloading and Warmup","text":"<pre><code>class PromptPreloader\n  def self.preload_critical_prompts\n    critical_prompts = %w[\n      welcome_email\n      password_reset\n      order_confirmation\n      error_notification\n    ]\n\n    critical_prompts.each do |prompt_id|\n      begin\n        prompt = PromptManager::Prompt.new(id: prompt_id)\n\n        # Preload into cache\n        CachedPromptManager.render(prompt_id, {}, expires_in: 1.hour)\n\n        Rails.logger.info \"Preloaded prompt: #{prompt_id}\"\n      rescue =&gt; e\n        Rails.logger.error \"Failed to preload #{prompt_id}: #{e.message}\"\n      end\n    end\n  end\n\n  def self.warmup_processor_pool\n    # Initialize processor pool\n    PROCESSOR_POOL.with_processor do |processor|\n      processor.process(\"//include test\\nWarmup content [TEST]\", \n                       parameters: { test: 'value' })\n    end\n\n    Rails.logger.info \"Processor pool warmed up\"\n  end\nend\n\n# In Rails initializer or deployment script\nRails.application.config.after_initialize do\n  PromptPreloader.preload_critical_prompts\n  PromptPreloader.warmup_processor_pool\nend\n</code></pre>"},{"location":"advanced/performance/#configuration-for-production","title":"Configuration for Production","text":"<pre><code># config/environments/production.rb\nPromptManager.configure do |config|\n  # Use optimized storage adapter\n  config.storage = OptimizedActiveRecordAdapter.new\n\n  # Enable aggressive caching\n  config.cache_prompts = true\n  config.cache_ttl = 3600  # 1 hour\n  config.cache_store = ActiveSupport::Cache::RedisStore.new(\n    url: ENV['REDIS_URL'],\n    pool_size: 10,\n    pool_timeout: 5\n  )\n\n  # Optimize processing\n  config.max_include_depth = 5  # Reduce for performance\n  config.directive_timeout = 10  # Shorter timeout\n\n  # Error handling\n  config.raise_on_missing_prompts = false\n  config.error_handler = -&gt;(error, context) {\n    Rails.logger.error \"Prompt error: #{error.message}\"\n    ErrorTracker.notify(error, context)\n    'Content temporarily unavailable'\n  }\nend\n</code></pre>"},{"location":"advanced/performance/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Cache Aggressively: Cache rendered prompts and frequently accessed content</li> <li>Batch Operations: Process multiple prompts together when possible</li> <li>Monitor Performance: Track render times, memory usage, and error rates</li> <li>Optimize Queries: Use proper indexes and minimize database roundtrips</li> <li>Pool Resources: Reuse expensive objects like processors and connections</li> <li>Profile Regularly: Identify bottlenecks in production workloads</li> <li>Preload Critical Content: Warm up caches with important prompts</li> <li>Handle Errors Gracefully: Provide fallbacks when performance degrades</li> </ol>"},{"location":"advanced/search-integration/","title":"Search Integration","text":"<p>PromptManager provides powerful search capabilities to find, filter, and organize prompts across your entire prompt library.</p>"},{"location":"advanced/search-integration/#basic-search","title":"Basic Search","text":""},{"location":"advanced/search-integration/#simple-text-search","title":"Simple Text Search","text":"<pre><code># Search by prompt content\nresults = PromptManager.search(\"customer service\")\nresults.each do |prompt_id|\n  puts \"Found: #{prompt_id}\"\nend\n\n# Search with options\nresults = PromptManager.search(\n  query: \"email template\",\n  limit: 10,\n  include_content: true\n)\n\nresults.each do |result|\n  puts \"ID: #{result[:id]}\"\n  puts \"Content: #{result[:content][0..100]}...\"\nend\n</code></pre>"},{"location":"advanced/search-integration/#search-by-metadata","title":"Search by Metadata","text":"<pre><code># Search by prompt ID pattern\nemail_prompts = PromptManager.search(id_pattern: /email/)\n\n# Search by file path (FileSystem adapter)\nmarketing_prompts = PromptManager.search(path_pattern: /marketing/)\n\n# Search by tags (if using metadata)\ncustomer_service = PromptManager.search(tags: ['customer-service', 'support'])\n</code></pre>"},{"location":"advanced/search-integration/#advanced-search-features","title":"Advanced Search Features","text":""},{"location":"advanced/search-integration/#full-text-search-with-elasticsearch","title":"Full-Text Search with Elasticsearch","text":"<pre><code># config/initializers/prompt_manager.rb\nPromptManager.configure do |config|\n  config.search_backend = PromptManager::Search::ElasticsearchBackend.new(\n    host: ENV['ELASTICSEARCH_URL'],\n    index: 'prompt_manager_prompts'\n  )\nend\n\nclass PromptManager::Search::ElasticsearchBackend\n  def initialize(host:, index:)\n    @client = Elasticsearch::Client.new(hosts: host)\n    @index = index\n    setup_index\n  end\n\n  def search(query, options = {})\n    search_body = build_search_query(query, options)\n\n    response = @client.search(\n      index: @index,\n      body: search_body\n    )\n\n    parse_search_results(response)\n  end\n\n  def index_prompt(prompt_id, content, metadata = {})\n    document = {\n      id: prompt_id,\n      content: content,\n      metadata: metadata,\n      indexed_at: Time.current.iso8601,\n      parameters: extract_parameters(content),\n      directives: extract_directives(content)\n    }\n\n    @client.index(\n      index: @index,\n      id: prompt_id,\n      body: document\n    )\n  end\n\n  private\n\n  def build_search_query(query, options)\n    {\n      query: {\n        bool: {\n          should: [\n            {\n              match: {\n                content: {\n                  query: query,\n                  boost: 2.0\n                }\n              }\n            },\n            {\n              match: {\n                id: {\n                  query: query,\n                  boost: 1.5\n                }\n              }\n            },\n            {\n              nested: {\n                path: 'metadata',\n                query: {\n                  match: {\n                    'metadata.description': query\n                  }\n                }\n              }\n            }\n          ],\n          filter: build_filters(options)\n        }\n      },\n      highlight: {\n        fields: {\n          content: {},\n          id: {}\n        }\n      },\n      size: options[:limit] || 20,\n      from: options[:offset] || 0\n    }\n  end\nend\n</code></pre>"},{"location":"advanced/search-integration/#faceted-search","title":"Faceted Search","text":"<pre><code>search_results = PromptManager.search(\n  query: \"email\",\n  facets: {\n    tags: {},\n    category: {},\n    last_modified: {\n      ranges: [\n        { to: \"now-1d\", label: \"Last 24 hours\" },\n        { from: \"now-7d\", to: \"now-1d\", label: \"Last week\" },\n        { from: \"now-30d\", to: \"now-7d\", label: \"Last month\" }\n      ]\n    }\n  }\n)\n\nputs \"Results: #{search_results[:total]}\"\nputs \"Facets:\"\nsearch_results[:facets].each do |facet_name, facet_data|\n  puts \"  #{facet_name}:\"\n  facet_data[:buckets].each do |bucket|\n    puts \"    #{bucket[:label]}: #{bucket[:count]}\"\n  end\nend\n</code></pre>"},{"location":"advanced/search-integration/#semantic-search-with-vector-embeddings","title":"Semantic Search with Vector Embeddings","text":"<pre><code>class PromptManager::Search::VectorBackend\n  def initialize(embedding_model: 'text-embedding-ada-002')\n    @openai = OpenAI::Client.new\n    @embedding_model = embedding_model\n    @vector_db = Pinecone::Client.new\n  end\n\n  def index_prompt(prompt_id, content, metadata = {})\n    # Generate embedding\n    embedding_response = @openai.embeddings(\n      parameters: {\n        model: @embedding_model,\n        input: content\n      }\n    )\n\n    embedding = embedding_response['data'][0]['embedding']\n\n    # Store in vector database\n    @vector_db.upsert(\n      namespace: 'prompts',\n      vectors: [{\n        id: prompt_id,\n        values: embedding,\n        metadata: {\n          content: content,\n          **metadata\n        }\n      }]\n    )\n  end\n\n  def semantic_search(query, limit: 10, similarity_threshold: 0.8)\n    # Generate query embedding\n    query_embedding = @openai.embeddings(\n      parameters: {\n        model: @embedding_model,\n        input: query\n      }\n    )['data'][0]['embedding']\n\n    # Search for similar vectors\n    results = @vector_db.query(\n      namespace: 'prompts',\n      vector: query_embedding,\n      top_k: limit,\n      include_metadata: true\n    )\n\n    # Filter by similarity threshold\n    results['matches'].select do |match|\n      match['score'] &gt;= similarity_threshold\n    end\n  end\nend\n\n# Usage\nPromptManager.configure do |config|\n  config.search_backend = PromptManager::Search::VectorBackend.new\nend\n\n# Find semantically similar prompts\nsimilar_prompts = PromptManager.semantic_search(\n  \"greeting message for new customers\",\n  limit: 5\n)\n\nsimilar_prompts.each do |result|\n  puts \"#{result['id']} (similarity: #{result['score']})\"\n  puts result['metadata']['content'][0..100]\n  puts \"---\"\nend\n</code></pre>"},{"location":"advanced/search-integration/#search-integration-patterns","title":"Search Integration Patterns","text":""},{"location":"advanced/search-integration/#auto-completion-and-suggestions","title":"Auto-completion and Suggestions","text":"<pre><code>class PromptSearchController &lt; ApplicationController\n  def autocomplete\n    query = params[:q]\n    suggestions = PromptManager.search(\n      query: query,\n      type: :autocomplete,\n      limit: 10\n    )\n\n    render json: {\n      suggestions: suggestions.map do |result|\n        {\n          id: result[:id],\n          title: result[:title] || result[:id].humanize,\n          description: result[:content][0..100],\n          category: result[:metadata][:category]\n        }\n      end\n    }\n  end\n\n  def search\n    results = PromptManager.search(\n      query: params[:q],\n      filters: search_filters,\n      facets: search_facets,\n      page: params[:page] || 1,\n      per_page: 20\n    )\n\n    render json: {\n      results: results[:items],\n      total: results[:total],\n      facets: results[:facets],\n      pagination: {\n        page: params[:page]&amp;.to_i || 1,\n        total_pages: (results[:total] / 20.0).ceil\n      }\n    }\n  end\n\n  private\n\n  def search_filters\n    filters = {}\n    filters[:category] = params[:category] if params[:category].present?\n    filters[:tags] = params[:tags].split(',') if params[:tags].present?\n    filters[:date_range] = params[:date_range] if params[:date_range].present?\n    filters\n  end\nend\n</code></pre>"},{"location":"advanced/search-integration/#search-analytics","title":"Search Analytics","text":"<pre><code>class SearchAnalytics\n  def self.track_search(query, user_id, results_count)\n    SearchLog.create!(\n      query: query,\n      user_id: user_id,\n      results_count: results_count,\n      searched_at: Time.current\n    )\n  end\n\n  def self.popular_searches(limit: 10)\n    SearchLog\n      .where('searched_at &gt; ?', 30.days.ago)\n      .group(:query)\n      .order('count_all DESC')\n      .limit(limit)\n      .count\n  end\n\n  def self.search_trends\n    SearchLog\n      .where('searched_at &gt; ?', 7.days.ago)\n      .group('DATE(searched_at)')\n      .count\n  end\n\n  def self.no_results_queries\n    SearchLog\n      .where(results_count: 0)\n      .where('searched_at &gt; ?', 7.days.ago)\n      .group(:query)\n      .order('count_all DESC')\n      .limit(20)\n      .count\n  end\nend\n\n# Usage in search\nresults = PromptManager.search(params[:q])\nSearchAnalytics.track_search(params[:q], current_user.id, results.count)\n</code></pre>"},{"location":"advanced/search-integration/#search-result-ranking","title":"Search Result Ranking","text":"<pre><code>class PromptRankingService\n  RANKING_FACTORS = {\n    exact_match: 3.0,\n    title_match: 2.0,\n    content_relevance: 1.0,\n    recency: 0.5,\n    usage_frequency: 1.5,\n    user_preference: 2.0\n  }.freeze\n\n  def self.rank_results(results, query, user_context = {})\n    scored_results = results.map do |result|\n      score = calculate_score(result, query, user_context)\n      result.merge(relevance_score: score)\n    end\n\n    scored_results.sort_by { |r| -r[:relevance_score] }\n  end\n\n  private\n\n  def self.calculate_score(result, query, user_context)\n    score = 0.0\n\n    # Exact match bonus\n    if result[:id].downcase.include?(query.downcase)\n      score += RANKING_FACTORS[:exact_match]\n    end\n\n    # Content relevance\n    content_matches = result[:content].downcase.scan(query.downcase).size\n    score += content_matches * RANKING_FACTORS[:content_relevance]\n\n    # Recency bonus\n    days_old = (Time.current - result[:updated_at]).to_f / 1.day\n    recency_factor = [1.0 - (days_old / 365.0), 0.0].max\n    score += recency_factor * RANKING_FACTORS[:recency]\n\n    # Usage frequency\n    usage_count = PromptUsageLog.where(prompt_id: result[:id])\n                                .where('used_at &gt; ?', 30.days.ago)\n                                .count\n    score += Math.log(usage_count + 1) * RANKING_FACTORS[:usage_frequency]\n\n    # User preference (based on past usage)\n    if user_context[:user_id]\n      user_usage = PromptUsageLog.where(\n        prompt_id: result[:id],\n        user_id: user_context[:user_id]\n      ).count\n      score += Math.log(user_usage + 1) * RANKING_FACTORS[:user_preference]\n    end\n\n    score\n  end\nend\n</code></pre>"},{"location":"advanced/search-integration/#search-ui-components","title":"Search UI Components","text":""},{"location":"advanced/search-integration/#react-search-component","title":"React Search Component","text":"<pre><code>// components/PromptSearch.jsx\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { debounce } from 'lodash';\n\nconst PromptSearch = () =&gt; {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [facets, setFacets] = useState({});\n  const [selectedFilters, setSelectedFilters] = useState({});\n  const [loading, setLoading] = useState(false);\n\n  const debouncedSearch = useMemo(\n    () =&gt; debounce(async (searchQuery, filters) =&gt; {\n      setLoading(true);\n      try {\n        const response = await fetch('/api/prompts/search', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            query: searchQuery,\n            filters: filters\n          }),\n        });\n\n        const data = await response.json();\n        setResults(data.results);\n        setFacets(data.facets);\n      } catch (error) {\n        console.error('Search error:', error);\n      } finally {\n        setLoading(false);\n      }\n    }, 300),\n    []\n  );\n\n  useEffect(() =&gt; {\n    if (query.length &gt; 2) {\n      debouncedSearch(query, selectedFilters);\n    } else {\n      setResults([]);\n    }\n  }, [query, selectedFilters, debouncedSearch]);\n\n  return (\n    &lt;div className=\"prompt-search\"&gt;\n      &lt;div className=\"search-input\"&gt;\n        &lt;input\n          type=\"text\"\n          value={query}\n          onChange={(e) =&gt; setQuery(e.target.value)}\n          placeholder=\"Search prompts...\"\n          className=\"search-field\"\n        /&gt;\n        {loading &amp;&amp; &lt;div className=\"search-spinner\"&gt;Loading...&lt;/div&gt;}\n      &lt;/div&gt;\n\n      &lt;div className=\"search-content\"&gt;\n        &lt;div className=\"search-filters\"&gt;\n          {Object.entries(facets).map(([facetName, facetData]) =&gt; (\n            &lt;div key={facetName} className=\"facet-group\"&gt;\n              &lt;h4&gt;{facetName.charAt(0).toUpperCase() + facetName.slice(1)}&lt;/h4&gt;\n              {facetData.buckets.map(bucket =&gt; (\n                &lt;label key={bucket.key} className=\"facet-option\"&gt;\n                  &lt;input\n                    type=\"checkbox\"\n                    checked={selectedFilters[facetName]?.includes(bucket.key) || false}\n                    onChange={(e) =&gt; handleFilterChange(facetName, bucket.key, e.target.checked)}\n                  /&gt;\n                  {bucket.label} ({bucket.count})\n                &lt;/label&gt;\n              ))}\n            &lt;/div&gt;\n          ))}\n        &lt;/div&gt;\n\n        &lt;div className=\"search-results\"&gt;\n          {results.map(result =&gt; (\n            &lt;div key={result.id} className=\"search-result\"&gt;\n              &lt;h3 className=\"result-title\"&gt;{result.title || result.id}&lt;/h3&gt;\n              &lt;p className=\"result-content\"&gt;{result.snippet}&lt;/p&gt;\n              &lt;div className=\"result-metadata\"&gt;\n                &lt;span className=\"result-category\"&gt;{result.category}&lt;/span&gt;\n                &lt;span className=\"result-score\"&gt;Score: {result.relevance_score?.toFixed(2)}&lt;/span&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          ))}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default PromptSearch;\n</code></pre>"},{"location":"advanced/search-integration/#search-api-implementation","title":"Search API Implementation","text":"<pre><code>class Api::PromptsController &lt; ApplicationController\n  def search\n    search_params = params.require(:search).permit(\n      :query, :page, :per_page,\n      filters: {},\n      facets: []\n    )\n\n    results = PromptManager.search(\n      query: search_params[:query],\n      filters: search_params[:filters] || {},\n      facets: search_params[:facets] || [],\n      page: search_params[:page]&amp;.to_i || 1,\n      per_page: [search_params[:per_page]&amp;.to_i || 20, 100].min\n    )\n\n    # Apply custom ranking\n    ranked_results = PromptRankingService.rank_results(\n      results[:items],\n      search_params[:query],\n      user_context: { user_id: current_user&amp;.id }\n    )\n\n    render json: {\n      results: ranked_results,\n      total: results[:total],\n      facets: results[:facets],\n      query: search_params[:query]\n    }\n  end\n\n  def suggestions\n    query = params[:q]\n\n    suggestions = PromptManager.search(\n      query: query,\n      type: :suggestions,\n      limit: 8\n    )\n\n    render json: {\n      suggestions: suggestions.map do |s|\n        {\n          text: s[:id].humanize,\n          value: s[:id],\n          category: s[:metadata][:category]\n        }\n      end\n    }\n  end\nend\n</code></pre>"},{"location":"advanced/search-integration/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/search-integration/#search-indexing-strategy","title":"Search Indexing Strategy","text":"<pre><code>class PromptIndexer\n  def self.reindex_all\n    total_prompts = PromptManager.list.count\n\n    PromptManager.list.each_with_index do |prompt_id, index|\n      begin\n        prompt = PromptManager::Prompt.new(id: prompt_id)\n        content = prompt.content\n        metadata = extract_metadata(prompt)\n\n        PromptManager.search_backend.index_prompt(\n          prompt_id,\n          content,\n          metadata\n        )\n\n        puts \"Indexed #{index + 1}/#{total_prompts}: #{prompt_id}\"\n      rescue =&gt; e\n        Rails.logger.error \"Failed to index #{prompt_id}: #{e.message}\"\n      end\n    end\n  end\n\n  def self.incremental_index\n    # Index only recently modified prompts\n    recently_modified = PromptManager.list.select do |prompt_id|\n      prompt = PromptManager::Prompt.new(id: prompt_id)\n      last_modified = File.mtime(prompt.file_path) rescue Time.at(0)\n      last_indexed = IndexLog.where(prompt_id: prompt_id).maximum(:indexed_at) || Time.at(0)\n\n      last_modified &gt; last_indexed\n    end\n\n    recently_modified.each do |prompt_id|\n      index_single_prompt(prompt_id)\n    end\n  end\nend\n\n# Schedule regular reindexing\nclass PromptReindexJob &lt; ApplicationJob\n  def perform\n    PromptIndexer.incremental_index\n  end\nend\n\n# Run every hour\n# schedule.rb or similar\nevery 1.hour do\n  PromptReindexJob.perform_later\nend\n</code></pre>"},{"location":"advanced/search-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Index Management: Keep search indexes up to date with prompt changes</li> <li>Query Optimization: Use proper filters and pagination to improve performance</li> <li>Result Ranking: Implement relevance scoring based on user behavior</li> <li>Analytics: Track search patterns to improve the search experience</li> <li>Faceted Navigation: Provide filters to help users narrow down results</li> <li>Error Handling: Gracefully handle search backend failures</li> <li>Caching: Cache frequent searches and autocomplete suggestions</li> <li>Security: Ensure search queries are properly sanitized and authorized</li> </ol>"},{"location":"api/configuration/","title":"Configuration API Reference","text":"<p>PromptManager provides comprehensive configuration options to customize behavior for your specific needs.</p>"},{"location":"api/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>PromptManager.configure do |config|\n  # Storage adapter (default: FileSystemAdapter)\n  config.storage = PromptManager::Storage::FileSystemAdapter.new\n\n  # Default prompts directory (default: ~/prompts_dir/)\n  config.prompts_dir = '/path/to/your/prompts'\n\n  # Enable debug logging (default: false)\n  config.debug = true\n\n  # Custom logger (default: Rails.logger or Logger.new(STDOUT))\n  config.logger = Logger.new('/var/log/prompt_manager.log')\nend\n</code></pre>"},{"location":"api/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"api/configuration/#core-settings","title":"Core Settings","text":""},{"location":"api/configuration/#storage","title":"<code>storage</code>","text":"<p>Type: <code>PromptManager::Storage::Base</code> Default: <code>FileSystemAdapter.new</code></p> <p>The storage adapter to use for reading and writing prompts.</p> <pre><code># FileSystem storage\nconfig.storage = PromptManager::Storage::FileSystemAdapter.new(\n  prompts_dir: '/custom/prompts/path'\n)\n\n# ActiveRecord storage  \nconfig.storage = PromptManager::Storage::ActiveRecordAdapter.new(\n  model_class: Prompt\n)\n\n# Custom storage\nconfig.storage = MyCustomAdapter.new\n</code></pre>"},{"location":"api/configuration/#prompts_dir","title":"<code>prompts_dir</code>","text":"<p>Type: <code>String</code> or <code>Array&lt;String&gt;</code> Default: <code>File.join(Dir.home, 'prompts_dir')</code></p> <p>Directory path(s) to search for prompt files when using FileSystemAdapter.</p> <pre><code># Single directory\nconfig.prompts_dir = '/app/prompts'\n\n# Multiple directories (search in order)\nconfig.prompts_dir = [\n  '/app/prompts',\n  '/shared/prompts', \n  '/system/default_prompts'\n]\n</code></pre>"},{"location":"api/configuration/#debug","title":"<code>debug</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code></p> <p>Enable debug logging for troubleshooting.</p> <pre><code>config.debug = true\n</code></pre>"},{"location":"api/configuration/#logger","title":"<code>logger</code>","text":"<p>Type: <code>Logger</code> Default: <code>Rails.logger</code> or <code>Logger.new(STDOUT)</code></p> <p>Custom logger instance for PromptManager output.</p> <pre><code>config.logger = Logger.new('/var/log/prompt_manager.log')\nconfig.logger.level = Logger::DEBUG\n</code></pre>"},{"location":"api/configuration/#parameter-processing","title":"Parameter Processing","text":""},{"location":"api/configuration/#save_parameter_history","title":"<code>save_parameter_history</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code></p> <p>Whether to save parameter values for reuse in future prompt renderings.</p> <pre><code>config.save_parameter_history = false\n</code></pre>"},{"location":"api/configuration/#parameter_history_file","title":"<code>parameter_history_file</code>","text":"<p>Type: <code>String</code> Default: <code>~/.prompt_manager/parameters_history.yaml</code></p> <p>File path for storing parameter history.</p> <pre><code>config.parameter_history_file = '/app/data/prompt_history.yaml'\n</code></pre>"},{"location":"api/configuration/#max_history_entries","title":"<code>max_history_entries</code>","text":"<p>Type: <code>Integer</code> Default: <code>10</code></p> <p>Maximum number of historical values to store per parameter.</p> <pre><code>config.max_history_entries = 5\n</code></pre>"},{"location":"api/configuration/#erb-processing","title":"ERB Processing","text":""},{"location":"api/configuration/#erb_timeout","title":"<code>erb_timeout</code>","text":"<p>Type: <code>Numeric</code> Default: <code>30</code> (seconds)</p> <p>Timeout for ERB template processing to prevent infinite loops.</p> <pre><code>config.erb_timeout = 60  # 1 minute\n</code></pre>"},{"location":"api/configuration/#erb_safe_level","title":"<code>erb_safe_level</code>","text":"<p>Type: <code>Integer</code> Default: <code>0</code></p> <p>Ruby safe level for ERB evaluation (0-4, higher = more restrictive).</p> <pre><code>config.erb_safe_level = 1  # Slightly more restrictive\n</code></pre>"},{"location":"api/configuration/#directive-processing","title":"Directive Processing","text":""},{"location":"api/configuration/#max_include_depth","title":"<code>max_include_depth</code>","text":"<p>Type: <code>Integer</code> Default: <code>10</code></p> <p>Maximum depth for nested <code>//include</code> directives to prevent circular includes.</p> <pre><code>config.max_include_depth = 5\n</code></pre>"},{"location":"api/configuration/#directive_timeout","title":"<code>directive_timeout</code>","text":"<p>Type: <code>Numeric</code> Default: <code>30</code> (seconds)</p> <p>Timeout for directive processing.</p> <pre><code>config.directive_timeout = 60\n</code></pre>"},{"location":"api/configuration/#caching","title":"Caching","text":""},{"location":"api/configuration/#cache_prompts","title":"<code>cache_prompts</code>","text":"<p>Type: <code>Boolean</code> Default: <code>false</code></p> <p>Enable in-memory caching of prompt content.</p> <pre><code>config.cache_prompts = true\n</code></pre>"},{"location":"api/configuration/#cache_ttl","title":"<code>cache_ttl</code>","text":"<p>Type: <code>Numeric</code> Default: <code>300</code> (5 minutes)</p> <p>Time-to-live for cached prompt content in seconds.</p> <pre><code>config.cache_ttl = 600  # 10 minutes\n</code></pre>"},{"location":"api/configuration/#cache_store","title":"<code>cache_store</code>","text":"<p>Type: <code>ActiveSupport::Cache::Store</code> Default: <code>ActiveSupport::Cache::MemoryStore.new</code></p> <p>Custom cache store for prompt content.</p> <pre><code>config.cache_store = ActiveSupport::Cache::RedisStore.new(\n  url: ENV['REDIS_URL']\n)\n</code></pre>"},{"location":"api/configuration/#error-handling","title":"Error Handling","text":""},{"location":"api/configuration/#error_handler","title":"<code>error_handler</code>","text":"<p>Type: <code>Proc</code> Default: <code>nil</code></p> <p>Custom error handler for prompt processing errors.</p> <pre><code>config.error_handler = -&gt;(error, context) {\n  Rails.logger.error \"Prompt error: #{error.message}\"\n  ErrorReporter.notify(error, context: context)\n\n  # Return fallback content\n  \"Service temporarily unavailable\"\n}\n</code></pre>"},{"location":"api/configuration/#raise_on_missing_prompts","title":"<code>raise_on_missing_prompts</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code></p> <p>Whether to raise exceptions for missing prompts or return nil.</p> <pre><code>config.raise_on_missing_prompts = false\n</code></pre>"},{"location":"api/configuration/#raise_on_missing_parameters","title":"<code>raise_on_missing_parameters</code>","text":"<p>Type: <code>Boolean</code> Default: <code>true</code></p> <p>Whether to raise exceptions for missing parameters or substitute with placeholders.</p> <pre><code>config.raise_on_missing_parameters = false\n</code></pre>"},{"location":"api/configuration/#environment-based-configuration","title":"Environment-based Configuration","text":""},{"location":"api/configuration/#rails-configuration","title":"Rails Configuration","text":"<pre><code># config/environments/development.rb\nRails.application.configure do\n  config.prompt_manager.debug = true\n  config.prompt_manager.prompts_dir = Rails.root.join('app', 'prompts')\n  config.prompt_manager.save_parameter_history = true\nend\n\n# config/environments/production.rb\nRails.application.configure do\n  config.prompt_manager.debug = false\n  config.prompt_manager.cache_prompts = true\n  config.prompt_manager.cache_ttl = 3600  # 1 hour\n\n  config.prompt_manager.error_handler = -&gt;(error, context) {\n    Rollbar.error(error, context)\n    \"Service temporarily unavailable\"\n  }\nend\n</code></pre>"},{"location":"api/configuration/#environment-variables","title":"Environment Variables","text":"<p>PromptManager respects these environment variables:</p> <pre><code># Storage configuration\nPROMPT_MANAGER_PROMPTS_DIR=\"/app/prompts\"\nPROMPT_MANAGER_DEBUG=\"true\"\n\n# Cache configuration  \nPROMPT_MANAGER_CACHE_PROMPTS=\"true\"\nPROMPT_MANAGER_CACHE_TTL=\"600\"\n\n# Database URL for ActiveRecord adapter\nDATABASE_URL=\"postgres://user:pass@localhost/prompts_db\"\n</code></pre>"},{"location":"api/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>Validate your configuration:</p> <pre><code>PromptManager.configure do |config|\n  config.storage = MyAdapter.new\n  config.debug = true\nend\n\n# Validate configuration\nbegin\n  PromptManager.validate_configuration!\n  puts \"Configuration valid\"\nrescue PromptManager::ConfigurationError =&gt; e\n  puts \"Configuration error: #{e.message}\"\nend\n</code></pre>"},{"location":"api/configuration/#runtime-configuration","title":"Runtime Configuration","text":"<p>Access current configuration:</p> <pre><code># Get current storage adapter\nstorage = PromptManager.configuration.storage\n\n# Check debug mode\nif PromptManager.configuration.debug\n  puts \"Debug mode enabled\"\nend\n\n# Access logger\nPromptManager.configuration.logger.info(\"Processing prompt...\")\n</code></pre>"},{"location":"api/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"api/configuration/#development","title":"Development","text":"<pre><code>PromptManager.configure do |config|\n  config.debug = true\n  config.prompts_dir = './prompts'\n  config.save_parameter_history = true\n  config.cache_prompts = false  # Always reload for development\nend\n</code></pre>"},{"location":"api/configuration/#production","title":"Production","text":"<pre><code>PromptManager.configure do |config|\n  config.debug = false\n  config.cache_prompts = true\n  config.cache_ttl = 3600\n\n  config.error_handler = -&gt;(error, context) {\n    ErrorService.notify(error, context)\n    \"Service temporarily unavailable\"\n  }\n\n  # Use database storage for high availability\n  config.storage = PromptManager::Storage::ActiveRecordAdapter.new\nend\n</code></pre>"},{"location":"api/configuration/#testing","title":"Testing","text":"<pre><code># spec/spec_helper.rb\nRSpec.configure do |config|\n  config.before(:each) do\n    PromptManager.configure do |config|\n      config.prompts_dir = Rails.root.join('spec', 'fixtures', 'prompts')\n      config.save_parameter_history = false\n      config.cache_prompts = false\n      config.raise_on_missing_prompts = true\n    end\n  end\nend\n</code></pre>"},{"location":"api/directive-processor/","title":"Directive Processor API Reference","text":"<p>The Directive Processor handles special instructions in prompts that begin with <code>//</code> and enable powerful prompt composition capabilities.</p>"},{"location":"api/directive-processor/#core-classes","title":"Core Classes","text":""},{"location":"api/directive-processor/#promptmanagerdirectiveprocessor","title":"<code>PromptManager::DirectiveProcessor</code>","text":"<p>The main class responsible for processing directives within prompts.</p>"},{"location":"api/directive-processor/#constructor","title":"Constructor","text":"<pre><code>processor = PromptManager::DirectiveProcessor.new(\n  storage: storage_adapter,\n  max_depth: 10,\n  timeout: 30\n)\n</code></pre> <p>Parameters: - <code>storage</code> (Storage::Base): Storage adapter for resolving includes - <code>max_depth</code> (Integer): Maximum include depth to prevent circular references (default: 10) - <code>timeout</code> (Numeric): Processing timeout in seconds (default: 30)</p>"},{"location":"api/directive-processor/#instance-methods","title":"Instance Methods","text":""},{"location":"api/directive-processor/#processcontent-context","title":"<code>process(content, context = {})</code>","text":"<p>Processes all directives in the given content.</p> <p>Parameters: - <code>content</code> (String): The prompt content containing directives - <code>context</code> (Hash): Processing context and variables</p> <p>Returns: String - Processed content with directives resolved</p> <p>Raises: - <code>PromptManager::DirectiveProcessingError</code> - If directive processing fails - <code>PromptManager::CircularIncludeError</code> - If circular includes are detected</p> <pre><code>processor = PromptManager::DirectiveProcessor.new(storage: adapter)\nresult = processor.process(\"//include header.txt\\nHello World!\")\n</code></pre>"},{"location":"api/directive-processor/#register_directivename-handler","title":"<code>register_directive(name, handler)</code>","text":"<p>Registers a custom directive handler.</p> <p>Parameters: - <code>name</code> (String): Directive name (without //) - <code>handler</code> (Proc): Handler that processes the directive</p> <pre><code>processor.register_directive('timestamp') do |args, context|\n  Time.current.strftime('%Y-%m-%d %H:%M:%S')\nend\n</code></pre>"},{"location":"api/directive-processor/#built-in-directives","title":"Built-in Directives","text":""},{"location":"api/directive-processor/#include-alias-import","title":"<code>//include</code> (alias: <code>//import</code>)","text":"<p>Includes content from another prompt file.</p> <p>Syntax: <pre><code>//include path/to/file.txt\n//include [VARIABLE_PATH].txt\n//import common/header.txt\n</code></pre></p> <p>Features: - Parameter substitution in paths: <code>//include templates/[TEMPLATE_TYPE].txt</code> - Relative and absolute path resolution - Circular include detection - Nested include support</p> <p>Examples:</p> <pre><code># Basic include\n//include common/header.txt\n\n# With parameter substitution\n//include templates/[EMAIL_TYPE].txt\n\n# Nested directory structure\n//include emails/marketing/[CAMPAIGN_TYPE]/template.txt\n</code></pre>"},{"location":"api/directive-processor/#set","title":"<code>//set</code>","text":"<p>Sets variables for use within the current prompt.</p> <p>Syntax: <pre><code>//set VARIABLE_NAME value\n//set CURRENT_DATE &lt;%= Date.today %&gt;\n</code></pre></p> <p>Examples:</p> <pre><code>//set COMPANY_NAME Acme Corporation\n//set SUPPORT_EMAIL support@[COMPANY_DOMAIN]\n//set GREETING Hello [CUSTOMER_NAME]\n\nYour message: [GREETING]\nContact us: [SUPPORT_EMAIL]\n</code></pre>"},{"location":"api/directive-processor/#if-endif","title":"<code>//if</code> / <code>//endif</code>","text":"<p>Conditional content inclusion.</p> <p>Syntax: <pre><code>//if CONDITION\ncontent to include if condition is true\n//endif\n</code></pre></p> <p>Examples:</p> <pre><code>//if [USER_TYPE] == 'premium'\n\ud83c\udf1f Premium features are available!\n//endif\n\n//if [ORDER_TOTAL] &gt; 100\n\ud83d\ude9a Free shipping applied!\n//endif\n</code></pre>"},{"location":"api/directive-processor/#custom-directive-development","title":"Custom Directive Development","text":""},{"location":"api/directive-processor/#simple-directive-handler","title":"Simple Directive Handler","text":"<pre><code># Register a simple directive\nprocessor.register_directive('upper') do |args, context|\n  args.upcase\nend\n\n# Usage in prompt:\n# //upper hello world\n# Result: HELLO WORLD\n</code></pre>"},{"location":"api/directive-processor/#complex-directive-handler","title":"Complex Directive Handler","text":"<pre><code># Register directive with parameter processing\nprocessor.register_directive('format_currency') do |args, context|\n  amount, currency = args.split(',').map(&amp;:strip)\n  formatted_amount = sprintf('%.2f', amount.to_f)\n\n  case currency.downcase\n  when 'usd', '$'\n    \"$#{formatted_amount}\"\n  when 'eur', '\u20ac'\n    \"\u20ac#{formatted_amount}\"\n  else\n    \"#{formatted_amount} #{currency}\"\n  end\nend\n\n# Usage in prompt:\n# //format_currency [ORDER_TOTAL], USD\n# Result: $123.45\n</code></pre>"},{"location":"api/directive-processor/#directive-with-context-access","title":"Directive with Context Access","text":"<pre><code>processor.register_directive('user_greeting') do |args, context|\n  user_name = context.dig(:parameters, :user_name) || 'Guest'\n  time_of_day = Time.current.hour &lt; 12 ? 'morning' : 'afternoon'\n\n  \"Good #{time_of_day}, #{user_name}!\"\nend\n\n# Usage in prompt:\n# //user_greeting\n# Result: Good morning, Alice!\n</code></pre>"},{"location":"api/directive-processor/#error-handling","title":"Error Handling","text":""},{"location":"api/directive-processor/#directive-processing-errors","title":"Directive Processing Errors","text":"<pre><code>begin\n  result = processor.process(content)\nrescue PromptManager::DirectiveProcessingError =&gt; e\n  puts \"Directive error at line #{e.line_number}: #{e.message}\"\n  puts \"Directive: #{e.directive}\"\nrescue PromptManager::CircularIncludeError =&gt; e\n  puts \"Circular include detected: #{e.include_chain.join(' -&gt; ')}\"\nend\n</code></pre>"},{"location":"api/directive-processor/#custom-error-handling","title":"Custom Error Handling","text":"<pre><code>processor.register_directive('safe_include') do |args, context|\n  begin\n    storage.read(args)\n  rescue PromptManager::PromptNotFoundError\n    \"&lt;!-- Template #{args} not found --&gt;\"\n  end\nend\n</code></pre>"},{"location":"api/directive-processor/#advanced-features","title":"Advanced Features","text":""},{"location":"api/directive-processor/#conditional-directives","title":"Conditional Directives","text":"<pre><code>processor.register_directive('feature_flag') do |args, context|\n  feature_name, content = args.split(':', 2)\n\n  if FeatureFlag.enabled?(feature_name)\n    processor.process(content.strip, context)\n  else\n    ''\n  end\nend\n\n# Usage:\n# //feature_flag new_ui: Welcome to our new interface!\n</code></pre>"},{"location":"api/directive-processor/#loop-directives","title":"Loop Directives","text":"<pre><code>processor.register_directive('foreach') do |args, context|\n  array_name, template = args.split(':', 2)\n  array_data = context.dig(:parameters, array_name.to_sym) || []\n\n  array_data.map.with_index do |item, index|\n    item_context = context.merge(\n      parameters: context[:parameters].merge(\n        item: item,\n        index: index,\n        first: index == 0,\n        last: index == array_data.length - 1\n      )\n    )\n    processor.process(template.strip, item_context)\n  end.join(\"\\n\")\nend\n\n# Usage:\n# //foreach items: - [ITEM.NAME]: $[ITEM.PRICE]\n</code></pre>"},{"location":"api/directive-processor/#template-inheritance","title":"Template Inheritance","text":"<pre><code>class TemplateInheritanceProcessor &lt; PromptManager::DirectiveProcessor\n  def initialize(**options)\n    super(**options)\n    register_built_in_directives\n  end\n\n  private\n\n  def register_built_in_directives\n    register_directive('extends') do |args, context|\n      parent_content = storage.read(args)\n      context[:parent_content] = parent_content\n      ''  # Don't include anything at this point\n    end\n\n    register_directive('block') do |args, context|\n      block_name, content = args.split(':', 2)\n      context[:blocks] ||= {}\n      context[:blocks][block_name] = content.strip\n      ''  # Blocks are processed later\n    end\n\n    register_directive('yield') do |args, context|\n      block_name = args.strip\n      context.dig(:blocks, block_name) || ''\n    end\n  end\n\n  def process(content, context = {})\n    # First pass: extract blocks and parent template\n    super(content, context)\n\n    # Second pass: process parent template with blocks\n    if context[:parent_content]\n      super(context[:parent_content], context)\n    else\n      super(content, context)\n    end\n  end\nend\n\n# Usage:\n# child.txt:\n# //extends parent.txt\n# //block content: This is child content\n# //block title: Child Page\n\n# parent.txt:\n# &lt;h1&gt;//yield title&lt;/h1&gt;\n# &lt;div&gt;//yield content&lt;/div&gt;\n</code></pre>"},{"location":"api/directive-processor/#configuration","title":"Configuration","text":""},{"location":"api/directive-processor/#global-configuration","title":"Global Configuration","text":"<pre><code>PromptManager.configure do |config|\n  config.directive_processor_class = CustomDirectiveProcessor\n  config.max_include_depth = 5\n  config.directive_timeout = 60\nend\n</code></pre>"},{"location":"api/directive-processor/#custom-processor","title":"Custom Processor","text":"<pre><code>class CustomDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def initialize(**options)\n    super(**options)\n    register_custom_directives\n  end\n\n  private\n\n  def register_custom_directives\n    register_directive('env') { |args, context| ENV[args] }\n    register_directive('random') { |args, context| rand(args.to_i) }\n    register_directive('uuid') { |args, context| SecureRandom.uuid }\n  end\nend\n</code></pre>"},{"location":"api/directive-processor/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/directive-processor/#caching-directive-results","title":"Caching Directive Results","text":"<pre><code>class CachedDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def initialize(**options)\n    super(**options)\n    @directive_cache = {}\n  end\n\n  def register_directive(name, &amp;handler)\n    cached_handler = lambda do |args, context|\n      cache_key = \"#{name}:#{args}:#{context.hash}\"\n\n      @directive_cache[cache_key] ||= handler.call(args, context)\n    end\n\n    super(name, &amp;cached_handler)\n  end\n\n  def clear_cache\n    @directive_cache.clear\n  end\nend\n</code></pre>"},{"location":"api/directive-processor/#parallel-processing","title":"Parallel Processing","text":"<pre><code>class ParallelDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def process_includes(content, context)\n    includes = extract_includes(content)\n\n    # Process includes in parallel\n    results = Parallel.map(includes) do |include_directive|\n      process_single_include(include_directive, context)\n    end\n\n    # Replace includes with results\n    replace_includes(content, includes, results)\n  end\nend\n</code></pre>"},{"location":"api/directive-processor/#testing-directives","title":"Testing Directives","text":""},{"location":"api/directive-processor/#rspec-examples","title":"RSpec Examples","text":"<pre><code>describe 'Custom Directive' do\n  let(:processor) { PromptManager::DirectiveProcessor.new(storage: storage) }\n  let(:storage) { instance_double(PromptManager::Storage::Base) }\n\n  before do\n    processor.register_directive('test') do |args, context|\n      \"processed: #{args}\"\n    end\n  end\n\n  it 'processes custom directive' do\n    content = \"//test hello world\"\n    result = processor.process(content)\n\n    expect(result).to eq \"processed: hello world\"\n  end\n\n  it 'handles directive errors gracefully' do\n    processor.register_directive('error') { |args, context| raise 'test error' }\n\n    expect {\n      processor.process(\"//error test\")\n    }.to raise_error(PromptManager::DirectiveProcessingError)\n  end\nend\n</code></pre>"},{"location":"api/directive-processor/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always handle errors gracefully in directive handlers</li> <li>Performance: Cache expensive operations in directive handlers</li> <li>Security: Validate and sanitize directive arguments</li> <li>Documentation: Document custom directive syntax and behavior</li> <li>Testing: Write comprehensive tests for custom directives</li> <li>Naming: Use descriptive names for custom directives</li> <li>Context: Use context parameter to access prompt rendering state</li> </ol>"},{"location":"api/prompt-class/","title":"Prompt Class API Reference","text":"<p>The <code>PromptManager::Prompt</code> class is the core interface for working with prompts in PromptManager.</p>"},{"location":"api/prompt-class/#class-methods","title":"Class Methods","text":""},{"location":"api/prompt-class/#newid-options","title":"<code>new(id:, **options)</code>","text":"<p>Creates a new Prompt instance.</p> <p>Parameters: - <code>id</code> (String): Unique identifier for the prompt - <code>options</code> (Hash): Optional configuration parameters</p> <p>Options: - <code>erb_flag</code> (Boolean): Enable ERB template processing (default: false) - <code>envar_flag</code> (Boolean): Enable environment variable substitution (default: false) - <code>storage</code> (Storage::Base): Custom storage adapter (default: configured adapter)</p> <p>Returns: <code>PromptManager::Prompt</code> instance</p> <p>Examples:</p> <pre><code># Basic prompt\nprompt = PromptManager::Prompt.new(id: 'welcome_message')\n\n# With ERB processing\nprompt = PromptManager::Prompt.new(\n  id: 'dynamic_prompt', \n  erb_flag: true\n)\n\n# With environment variables\nprompt = PromptManager::Prompt.new(\n  id: 'system_prompt',\n  envar_flag: true\n)\n\n# All options\nprompt = PromptManager::Prompt.new(\n  id: 'advanced_prompt',\n  erb_flag: true,\n  envar_flag: true\n)\n</code></pre>"},{"location":"api/prompt-class/#instance-methods","title":"Instance Methods","text":""},{"location":"api/prompt-class/#renderparameters","title":"<code>render(parameters = {})</code>","text":"<p>Renders the prompt with the provided parameters.</p> <p>Parameters: - <code>parameters</code> (Hash): Key-value pairs for parameter substitution</p> <p>Returns: String - The rendered prompt content</p> <p>Raises: - <code>PromptNotFoundError</code> - If the prompt file cannot be found - <code>MissingParametersError</code> - If required parameters are not provided - <code>DirectiveProcessingError</code> - If directive processing fails</p> <p>Examples:</p> <pre><code># Basic rendering\nresult = prompt.render\n\n# With parameters\nresult = prompt.render(\n  customer_name: 'John Doe',\n  order_id: 'ORD-123'\n)\n\n# With complex parameters\nresult = prompt.render(\n  user: {\n    name: 'Alice',\n    email: 'alice@example.com'\n  },\n  items: ['Item 1', 'Item 2'],\n  total: 99.99\n)\n</code></pre>"},{"location":"api/prompt-class/#savecontent-metadata","title":"<code>save(content, **metadata)</code>","text":"<p>Saves prompt content to storage.</p> <p>Parameters: - <code>content</code> (String): The prompt content to save - <code>metadata</code> (Hash): Optional metadata to store with the prompt</p> <p>Returns: Boolean - Success status</p> <p>Examples:</p> <pre><code># Save content\nprompt.save(\"Hello [NAME], welcome to our service!\")\n\n# Save with metadata\nprompt.save(\n  \"Your order [ORDER_ID] is ready!\",\n  category: 'notifications',\n  author: 'system',\n  version: '1.0'\n)\n</code></pre>"},{"location":"api/prompt-class/#content","title":"<code>content</code>","text":"<p>Retrieves the raw prompt content from storage.</p> <p>Returns: String - The raw prompt content</p> <p>Example:</p> <pre><code>raw_content = prompt.content\nputs raw_content  # \"Hello [NAME]!\"\n</code></pre>"},{"location":"api/prompt-class/#parameters","title":"<code>parameters</code>","text":"<p>Extracts parameter names from the prompt content.</p> <p>Returns: Array - List of parameter names found in the prompt <p>Example:</p> <pre><code># Prompt content: \"Hello [NAME], your order [ORDER_ID] is ready!\"\nparams = prompt.parameters\nputs params  # ['NAME', 'ORDER_ID']\n</code></pre>"},{"location":"api/prompt-class/#delete","title":"<code>delete</code>","text":"<p>Removes the prompt from storage.</p> <p>Returns: Boolean - Success status</p> <p>Example:</p> <pre><code>prompt.delete\n</code></pre>"},{"location":"api/prompt-class/#exists","title":"<code>exists?</code>","text":"<p>Checks if the prompt exists in storage.</p> <p>Returns: Boolean - True if prompt exists</p> <p>Example:</p> <pre><code>if prompt.exists?\n  puts \"Prompt found\"\nelse\n  puts \"Prompt not found\"\nend\n</code></pre>"},{"location":"api/prompt-class/#properties","title":"Properties","text":""},{"location":"api/prompt-class/#id","title":"<code>id</code>","text":"<p>Type: String (read-only)</p> <p>The unique identifier for the prompt.</p> <pre><code>prompt = PromptManager::Prompt.new(id: 'welcome')\nputs prompt.id  # \"welcome\"\n</code></pre>"},{"location":"api/prompt-class/#erb_flag","title":"<code>erb_flag</code>","text":"<p>Type: Boolean</p> <p>Whether ERB processing is enabled.</p> <pre><code>prompt.erb_flag = true\n</code></pre>"},{"location":"api/prompt-class/#envar_flag","title":"<code>envar_flag</code>","text":"<p>Type: Boolean</p> <p>Whether environment variable substitution is enabled.</p> <pre><code>prompt.envar_flag = true\n</code></pre>"},{"location":"api/prompt-class/#storage","title":"<code>storage</code>","text":"<p>Type: Storage::Base</p> <p>The storage adapter used by this prompt.</p> <pre><code>prompt.storage = PromptManager::Storage::FileSystemAdapter.new\n</code></pre>"},{"location":"api/prompt-class/#parameter-processing","title":"Parameter Processing","text":""},{"location":"api/prompt-class/#parameter-syntax","title":"Parameter Syntax","text":"<p>Parameters use square bracket syntax: <code>[PARAMETER_NAME]</code></p> <pre><code># In prompt file:\n# \"Hello [NAME], your balance is $[BALANCE]\"\n\nprompt.render(\n  name: 'Alice',\n  balance: 1500.00\n)\n# Result: \"Hello Alice, your balance is $1500.0\"\n</code></pre>"},{"location":"api/prompt-class/#nested-parameters","title":"Nested Parameters","text":"<p>Parameters can reference nested hash values:</p> <pre><code># In prompt file:\n# \"User: [USER.NAME] ([USER.EMAIL])\"\n\nprompt.render(\n  user: {\n    name: 'Bob',\n    email: 'bob@example.com'\n  }\n)\n# Result: \"User: Bob (bob@example.com)\"\n</code></pre>"},{"location":"api/prompt-class/#array-parameters","title":"Array Parameters","text":"<p>Arrays are joined with commas by default:</p> <pre><code># In prompt file:\n# \"Items: [ITEMS]\"\n\nprompt.render(items: ['Apple', 'Banana', 'Orange'])\n# Result: \"Items: Apple, Banana, Orange\"\n</code></pre>"},{"location":"api/prompt-class/#error-handling","title":"Error Handling","text":""},{"location":"api/prompt-class/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>PromptManager::Error\n\u251c\u2500\u2500 PromptNotFoundError\n\u251c\u2500\u2500 MissingParametersError  \n\u251c\u2500\u2500 DirectiveProcessingError\n\u2514\u2500\u2500 StorageError\n</code></pre>"},{"location":"api/prompt-class/#error-details","title":"Error Details","text":"<pre><code>begin\n  prompt.render\nrescue PromptManager::MissingParametersError =&gt; e\n  puts e.message              # Human readable message\n  puts e.missing_parameters   # Array of missing parameter names\n  puts e.prompt_id           # ID of the prompt that failed\nrescue PromptManager::DirectiveProcessingError =&gt; e\n  puts e.message             # Error details\n  puts e.line_number        # Line where error occurred (if available)\n  puts e.directive          # The directive that failed\nend\n</code></pre>"},{"location":"api/prompt-class/#threading-and-concurrency","title":"Threading and Concurrency","text":""},{"location":"api/prompt-class/#thread-safety","title":"Thread Safety","text":"<p>Prompt instances are not thread-safe. Create separate instances for each thread:</p> <pre><code># Thread-safe usage\nthreads = []\n(1..10).each do |i|\n  threads &lt;&lt; Thread.new do\n    # Each thread gets its own instance\n    prompt = PromptManager::Prompt.new(id: 'worker_prompt')\n    result = prompt.render(worker_id: i)\n    puts result\n  end\nend\n\nthreads.each(&amp;:join)\n</code></pre>"},{"location":"api/prompt-class/#shared-storage","title":"Shared Storage","text":"<p>Storage adapters handle their own thread safety. Multiple Prompt instances can safely share the same storage adapter.</p>"},{"location":"api/prompt-class/#best-practices","title":"Best Practices","text":""},{"location":"api/prompt-class/#instance-reuse","title":"Instance Reuse","text":"<pre><code># Good: Reuse instances when possible\nprompt = PromptManager::Prompt.new(id: 'email_template')\n\ncustomers.each do |customer|\n  email_content = prompt.render(\n    name: customer.name,\n    email: customer.email\n  )\n  send_email(customer, email_content)\nend\n</code></pre>"},{"location":"api/prompt-class/#parameter-validation","title":"Parameter Validation","text":"<pre><code># Validate parameters before rendering\nrequired_params = prompt.parameters\nmissing_params = required_params - params.keys\n\nunless missing_params.empty?\n  raise \"Missing parameters: #{missing_params.join(', ')}\"\nend\n\nresult = prompt.render(params)\n</code></pre>"},{"location":"api/prompt-class/#error-recovery","title":"Error Recovery","text":"<pre><code>def safe_render(prompt_id, params = {})\n  prompt = PromptManager::Prompt.new(id: prompt_id)\n  prompt.render(params)\nrescue PromptManager::PromptNotFoundError\n  \"Default message when prompt unavailable\"\nrescue PromptManager::MissingParametersError =&gt; e\n  \"Missing: #{e.missing_parameters.join(', ')}\"\nrescue =&gt; e\n  Rails.logger.error \"Prompt render error: #{e.message}\"\n  \"An error occurred\"\nend\n</code></pre>"},{"location":"api/storage-adapters/","title":"Storage Adapters API Reference","text":"<p>PromptManager uses a storage adapter pattern to provide flexible backends for prompt storage and retrieval.</p>"},{"location":"api/storage-adapters/#base-storage-adapter","title":"Base Storage Adapter","text":"<p>All storage adapters inherit from <code>PromptManager::Storage::Base</code> and must implement the core interface.</p>"},{"location":"api/storage-adapters/#promptmanagerstoragebase","title":"<code>PromptManager::Storage::Base</code>","text":"<p>The abstract base class that defines the storage adapter interface.</p>"},{"location":"api/storage-adapters/#required-methods","title":"Required Methods","text":""},{"location":"api/storage-adapters/#readprompt_id","title":"<code>read(prompt_id)</code>","text":"<p>Reads prompt content from storage.</p> <p>Parameters: - <code>prompt_id</code> (String): Unique identifier for the prompt</p> <p>Returns: String - The prompt content</p> <p>Raises: - <code>PromptManager::PromptNotFoundError</code> - If prompt doesn't exist - <code>PromptManager::StorageError</code> - For storage-related errors</p> <pre><code>def read(prompt_id)\n  # Implementation must return prompt content as string\n  # or raise PromptNotFoundError if not found\nend\n</code></pre>"},{"location":"api/storage-adapters/#writeprompt_id-content","title":"<code>write(prompt_id, content)</code>","text":"<p>Writes prompt content to storage.</p> <p>Parameters: - <code>prompt_id</code> (String): Unique identifier for the prompt - <code>content</code> (String): The prompt content to store</p> <p>Returns: Boolean - True on success</p> <p>Raises: - <code>PromptManager::StorageError</code> - For storage-related errors</p> <pre><code>def write(prompt_id, content)\n  # Implementation must store content and return true\n  # or raise StorageError on failure\nend\n</code></pre>"},{"location":"api/storage-adapters/#existprompt_id","title":"<code>exist?(prompt_id)</code>","text":"<p>Checks if a prompt exists in storage.</p> <p>Parameters: - <code>prompt_id</code> (String): Unique identifier for the prompt</p> <p>Returns: Boolean - True if prompt exists</p> <pre><code>def exist?(prompt_id)\n  # Implementation must return boolean\nend\n</code></pre>"},{"location":"api/storage-adapters/#deleteprompt_id","title":"<code>delete(prompt_id)</code>","text":"<p>Removes a prompt from storage.</p> <p>Parameters: - <code>prompt_id</code> (String): Unique identifier for the prompt</p> <p>Returns: Boolean - True if successfully deleted</p> <pre><code>def delete(prompt_id)\n  # Implementation must remove prompt and return success status\nend\n</code></pre>"},{"location":"api/storage-adapters/#list","title":"<code>list</code>","text":"<p>Returns all available prompt identifiers.</p> <p>Returns: Array - Array of prompt IDs <pre><code>def list\n  # Implementation must return array of all prompt IDs\nend\n</code></pre>"},{"location":"api/storage-adapters/#optional-methods","title":"Optional Methods","text":""},{"location":"api/storage-adapters/#initializeoptions","title":"<code>initialize(**options)</code>","text":"<p>Constructor for storage adapter configuration.</p> <pre><code>def initialize(**options)\n  super\n  # Custom initialization logic\nend\n</code></pre>"},{"location":"api/storage-adapters/#clear","title":"<code>clear</code>","text":"<p>Removes all prompts from storage (optional).</p> <p>Returns: Boolean - True on success</p> <pre><code>def clear\n  # Optional: implement to support clearing all prompts\nend\n</code></pre>"},{"location":"api/storage-adapters/#built-in-storage-adapters","title":"Built-in Storage Adapters","text":""},{"location":"api/storage-adapters/#filesystemadapter","title":"FileSystemAdapter","text":"<p>Stores prompts as files in a directory structure.</p> <pre><code>adapter = PromptManager::Storage::FileSystemAdapter.new(\n  prompts_dir: '/path/to/prompts',\n  file_extensions: ['.txt', '.md', '.prompt'],\n  create_directories: true\n)\n</code></pre> <p>Configuration Options:</p> <ul> <li><code>prompts_dir</code> (String|Array): Directory path(s) to search</li> <li><code>file_extensions</code> (Array): File extensions to recognize (default: <code>['.txt', '.md']</code>)</li> <li><code>create_directories</code> (Boolean): Create directories if they don't exist (default: <code>true</code>)</li> </ul> <p>Features: - Hierarchical prompt organization with subdirectories - Multiple search paths with fallback - Automatic file extension detection - Thread-safe file operations</p>"},{"location":"api/storage-adapters/#activerecordadapter","title":"ActiveRecordAdapter","text":"<p>Stores prompts in a database using ActiveRecord.</p> <pre><code>adapter = PromptManager::Storage::ActiveRecordAdapter.new(\n  model_class: Prompt,\n  id_column: :prompt_id,\n  content_column: :content,\n  scope: -&gt; { where(active: true) }\n)\n</code></pre> <p>Configuration Options:</p> <ul> <li><code>model_class</code> (Class): ActiveRecord model class</li> <li><code>id_column</code> (Symbol): Column containing prompt ID (default: <code>:prompt_id</code>)</li> <li><code>content_column</code> (Symbol): Column containing prompt content (default: <code>:content</code>)</li> <li><code>scope</code> (Proc): Additional query scope (optional)</li> </ul> <p>Features: - Full database integration with Rails - Transaction support - Query optimization - Multi-tenancy support</p>"},{"location":"api/storage-adapters/#custom-adapter-implementation","title":"Custom Adapter Implementation","text":""},{"location":"api/storage-adapters/#example-memoryadapter","title":"Example: MemoryAdapter","text":"<pre><code>class MemoryAdapter &lt; PromptManager::Storage::Base\n  def initialize(**options)\n    super\n    @prompts = {}\n    @mutex = Mutex.new\n  end\n\n  def read(prompt_id)\n    @mutex.synchronize do\n      content = @prompts[prompt_id]\n      raise PromptManager::PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\") unless content\n      content\n    end\n  end\n\n  def write(prompt_id, content)\n    @mutex.synchronize do\n      @prompts[prompt_id] = content\n    end\n    true\n  end\n\n  def exist?(prompt_id)\n    @mutex.synchronize { @prompts.key?(prompt_id) }\n  end\n\n  def delete(prompt_id)\n    @mutex.synchronize do\n      @prompts.delete(prompt_id) ? true : false\n    end\n  end\n\n  def list\n    @mutex.synchronize { @prompts.keys }\n  end\n\n  def clear\n    @mutex.synchronize { @prompts.clear }\n    true\n  end\nend\n</code></pre>"},{"location":"api/storage-adapters/#example-httpadapter","title":"Example: HTTPAdapter","text":"<pre><code>require 'net/http'\nrequire 'json'\n\nclass HTTPAdapter &lt; PromptManager::Storage::Base\n  def initialize(base_url:, api_token: nil, **options)\n    super(**options)\n    @base_url = base_url.chomp('/')\n    @api_token = api_token\n  end\n\n  def read(prompt_id)\n    response = http_get(\"/prompts/#{prompt_id}\")\n\n    case response.code\n    when '200'\n      JSON.parse(response.body)['content']\n    when '404'\n      raise PromptManager::PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\")\n    else\n      raise PromptManager::StorageError.new(\"HTTP error: #{response.code}\")\n    end\n  end\n\n  def write(prompt_id, content)\n    body = { content: content }.to_json\n    response = http_post(\"/prompts/#{prompt_id}\", body)\n\n    response.code == '200' || response.code == '201'\n  end\n\n  def exist?(prompt_id)\n    response = http_head(\"/prompts/#{prompt_id}\")\n    response.code == '200'\n  rescue\n    false\n  end\n\n  def delete(prompt_id)\n    response = http_delete(\"/prompts/#{prompt_id}\")\n    response.code == '200' || response.code == '204'\n  end\n\n  def list\n    response = http_get(\"/prompts\")\n    return [] unless response.code == '200'\n\n    JSON.parse(response.body)['prompt_ids']\n  end\n\n  private\n\n  def http_get(path)\n    uri = URI(\"#{@base_url}#{path}\")\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = uri.scheme == 'https'\n\n    request = Net::HTTP::Get.new(uri)\n    add_auth_header(request)\n\n    http.request(request)\n  end\n\n  def http_post(path, body)\n    uri = URI(\"#{@base_url}#{path}\")\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = uri.scheme == 'https'\n\n    request = Net::HTTP::Post.new(uri)\n    request['Content-Type'] = 'application/json'\n    request.body = body\n    add_auth_header(request)\n\n    http.request(request)\n  end\n\n  def add_auth_header(request)\n    return unless @api_token\n    request['Authorization'] = \"Bearer #{@api_token}\"\n  end\nend\n</code></pre>"},{"location":"api/storage-adapters/#adapter-registration","title":"Adapter Registration","text":"<p>Register your custom adapter:</p> <pre><code># Global configuration\nPromptManager.configure do |config|\n  config.storage = CustomAdapter.new(option: 'value')\nend\n\n# Per-prompt configuration\nprompt = PromptManager::Prompt.new(\n  id: 'special_prompt',\n  storage: CustomAdapter.new\n)\n</code></pre>"},{"location":"api/storage-adapters/#error-handling","title":"Error Handling","text":""},{"location":"api/storage-adapters/#standard-exceptions","title":"Standard Exceptions","text":"<p>All adapters should raise these standard exceptions:</p> <pre><code># Prompt not found\nraise PromptManager::PromptNotFoundError.new(\"Prompt 'xyz' not found\")\n\n# Storage operation failed\nraise PromptManager::StorageError.new(\"Connection timeout\")\n\n# Configuration error\nraise PromptManager::ConfigurationError.new(\"Invalid database URL\")\n</code></pre>"},{"location":"api/storage-adapters/#error-context","title":"Error Context","text":"<p>Provide context in error messages:</p> <pre><code>begin\n  content = storage.read(prompt_id)\nrescue =&gt; e\n  raise PromptManager::StorageError.new(\n    \"Failed to read prompt '#{prompt_id}': #{e.message}\"\n  )\nend\n</code></pre>"},{"location":"api/storage-adapters/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/storage-adapters/#connection-pooling","title":"Connection Pooling","text":"<pre><code>class PooledAdapter &lt; PromptManager::Storage::Base\n  def initialize(pool_size: 10, **options)\n    super(**options)\n    @pool = ConnectionPool.new(size: pool_size) do\n      create_connection\n    end\n  end\n\n  def read(prompt_id)\n    @pool.with { |conn| conn.read(prompt_id) }\n  end\nend\n</code></pre>"},{"location":"api/storage-adapters/#caching","title":"Caching","text":"<pre><code>class CachedAdapter &lt; PromptManager::Storage::Base\n  def initialize(cache_ttl: 300, **options)\n    super(**options)\n    @cache = {}\n    @cache_ttl = cache_ttl\n  end\n\n  def read(prompt_id)\n    cached = @cache[prompt_id]\n    if cached &amp;&amp; (Time.current - cached[:timestamp]) &lt; @cache_ttl\n      return cached[:content]\n    end\n\n    content = super(prompt_id)\n    @cache[prompt_id] = {\n      content: content,\n      timestamp: Time.current\n    }\n    content\n  end\nend\n</code></pre>"},{"location":"api/storage-adapters/#testing-adapters","title":"Testing Adapters","text":""},{"location":"api/storage-adapters/#rspec-shared-examples","title":"RSpec Shared Examples","text":"<pre><code># spec/support/shared_examples/storage_adapter.rb\nRSpec.shared_examples 'a storage adapter' do\n  let(:prompt_id) { 'test_prompt' }\n  let(:content) { 'Hello [NAME]!' }\n\n  describe '#write and #read' do\n    it 'stores and retrieves content' do\n      expect(adapter.write(prompt_id, content)).to be true\n      expect(adapter.read(prompt_id)).to eq content\n    end\n  end\n\n  describe '#exist?' do\n    it 'returns false for non-existent prompts' do\n      expect(adapter.exist?('non_existent')).to be false\n    end\n\n    it 'returns true for existing prompts' do\n      adapter.write(prompt_id, content)\n      expect(adapter.exist?(prompt_id)).to be true\n    end\n  end\n\n  describe '#delete' do\n    it 'removes prompts' do\n      adapter.write(prompt_id, content)\n      expect(adapter.delete(prompt_id)).to be true\n      expect(adapter.exist?(prompt_id)).to be false\n    end\n  end\n\n  describe '#list' do\n    it 'returns all prompt IDs' do\n      adapter.write('prompt1', 'content1')\n      adapter.write('prompt2', 'content2')\n\n      expect(adapter.list).to contain_exactly('prompt1', 'prompt2')\n    end\n  end\nend\n\n# Usage in adapter specs\ndescribe CustomAdapter do\n  let(:adapter) { described_class.new(options) }\n\n  include_examples 'a storage adapter'\nend\n</code></pre>"},{"location":"api/storage-adapters/#best-practices","title":"Best Practices","text":"<ol> <li>Thread Safety: Ensure adapter operations are thread-safe</li> <li>Error Handling: Use standard PromptManager exceptions</li> <li>Resource Management: Properly close connections and clean up resources</li> <li>Configuration Validation: Validate configuration parameters in constructor</li> <li>Documentation: Document all configuration options and behavior</li> <li>Testing: Use shared examples to ensure consistent behavior</li> <li>Performance: Consider caching and connection pooling for remote storage</li> </ol>"},{"location":"core-features/comments/","title":"Comments and Documentation","text":"<p>PromptManager supports comprehensive inline documentation through comments and special sections.</p>"},{"location":"core-features/comments/#line-comments","title":"Line Comments","text":"<p>Lines beginning with <code>#</code> are treated as comments and ignored during processing:</p> <pre><code># This is a comment describing the prompt\n# Author: Your Name\n# Version: 1.0\n\nHello [NAME]! This text will be processed.\n</code></pre>"},{"location":"core-features/comments/#block-comments","title":"Block Comments","text":"<p>Everything after <code>__END__</code> is ignored, creating a documentation section:</p> <pre><code>Your prompt content here...\n\n__END__\nThis section is completely ignored by PromptManager.\n\nDevelopment notes:\n- TODO: Add more parameters\n- Version history\n- Usage examples\n</code></pre>"},{"location":"core-features/comments/#documentation-best-practices","title":"Documentation Best Practices","text":"<pre><code># Description: Customer service greeting template\n# Tags: customer-service, greeting\n# Version: 1.2\n# Author: Support Team\n# Last Updated: 2024-01-15\n\n//include common/header.txt\n\nYour prompt content...\n\n__END__\nInternal notes and documentation go here.\n</code></pre>"},{"location":"core-features/directive-processing/","title":"Directive Processing","text":"<p>Directives are special instructions in your prompts that begin with <code>//</code> and provide powerful prompt composition capabilities.</p>"},{"location":"core-features/directive-processing/#overview","title":"Overview","text":"<p>Directives allow you to: - Include content from other files - Create modular, reusable prompt components - Build dynamic prompt structures - Process commands during prompt generation</p>"},{"location":"core-features/directive-processing/#built-in-directives","title":"Built-in Directives","text":""},{"location":"core-features/directive-processing/#include-alias-import","title":"<code>//include</code> (alias: <code>//import</code>)","text":"<p>Include content from other files:</p> <pre><code>//include common/header.txt\n//import templates/[TEMPLATE_TYPE].txt\n\nYour main prompt content here...\n</code></pre>"},{"location":"core-features/directive-processing/#example","title":"Example","text":"customer_response.txt<pre><code>//include common/header.txt\n\nDear [CUSTOMER_NAME],\n\nThank you for your inquiry about [TOPIC].\n\n//include common/footer.txt\n</code></pre> <p>For detailed examples and advanced usage, see the Basic Examples.</p>"},{"location":"core-features/erb-integration/","title":"ERB Integration","text":"<p>PromptManager supports ERB (Embedded Ruby) templating for dynamic content generation.</p>"},{"location":"core-features/erb-integration/#enabling-erb","title":"Enabling ERB","text":"<pre><code>prompt = PromptManager::Prompt.new(\n  id: 'dynamic_prompt',\n  erb_flag: true\n)\n</code></pre>"},{"location":"core-features/erb-integration/#basic-usage","title":"Basic Usage","text":"dynamic_prompt.txt<pre><code>Current date: &lt;%= Date.today.strftime('%B %d, %Y') %&gt;\n\n&lt;% if '[PRIORITY]' == 'high' %&gt;\n\ud83d\udea8 URGENT: This requires immediate attention!\n&lt;% else %&gt;\n\ud83d\udccb Standard processing request.\n&lt;% end %&gt;\n\nGenerated at: &lt;%= Time.now %&gt;\n</code></pre>"},{"location":"core-features/erb-integration/#advanced-examples","title":"Advanced Examples","text":""},{"location":"core-features/erb-integration/#system-information-template","title":"System Information Template","text":"<pre><code>**Timestamp**: &lt;%= Time.now.strftime('%A, %B %d, %Y at %I:%M:%S %p %Z') %&gt;\n**Analysis Duration**: &lt;%= Time.now - Time.parse('2024-01-01') %&gt; seconds since 2024 began\n\n&lt;% if RUBY_PLATFORM.include?('darwin') %&gt;\n**Platform**: macOS/Darwin System\n**Ruby Platform**: &lt;%= RUBY_PLATFORM %&gt;\n**Ruby Version**: &lt;%= RUBY_VERSION %&gt;\n**Ruby Engine**: &lt;%= RUBY_ENGINE %&gt;\n&lt;% elsif RUBY_PLATFORM.include?('linux') %&gt;\n**Platform**: Linux System  \n**Ruby Platform**: &lt;%= RUBY_PLATFORM %&gt;\n**Ruby Version**: &lt;%= RUBY_VERSION %&gt;\n**Ruby Engine**: &lt;%= RUBY_ENGINE %&gt;\n&lt;% else %&gt;\n**Platform**: Other Unix-like System\n**Ruby Platform**: &lt;%= RUBY_PLATFORM %&gt;\n**Ruby Version**: &lt;%= RUBY_VERSION %&gt;\n**Ruby Engine**: &lt;%= RUBY_ENGINE %&gt;\n&lt;% end %&gt;\n\n**Performance Context**: &lt;%= `uptime`.strip rescue 'Unable to determine' %&gt;\n</code></pre>"},{"location":"core-features/erb-integration/#complete-integration-example","title":"Complete Integration Example","text":"<p>See the complete advanced_integrations.rb example that demonstrates:</p> <ul> <li>ERB templating with system information</li> <li>Dynamic timestamp generation</li> <li>Platform-specific content rendering</li> <li>Integration with OpenAI API streaming</li> <li>Professional UI with <code>tty-spinner</code></li> </ul> <p>This example shows how to create sophisticated prompts that adapt to your system environment and generate technical analysis reports.</p> <p>For more comprehensive ERB examples, see the Examples documentation.</p>"},{"location":"core-features/error-handling/","title":"Error Handling","text":"<p>PromptManager provides comprehensive error handling to help you identify and resolve issues during prompt processing.</p>"},{"location":"core-features/error-handling/#common-exceptions","title":"Common Exceptions","text":""},{"location":"core-features/error-handling/#promptnotfounderror","title":"<code>PromptNotFoundError</code>","text":"<p>Raised when a prompt cannot be located:</p> <pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'nonexistent_prompt')\nrescue PromptManager::PromptNotFoundError =&gt; e\n  puts \"Prompt not found: #{e.message}\"\n  # Handle gracefully - perhaps show available prompts\nend\n</code></pre>"},{"location":"core-features/error-handling/#missingparameterserror","title":"<code>MissingParametersError</code>","text":"<p>Raised when required parameters are not provided:</p> <pre><code>begin\n  result = prompt.render  # Missing required parameters\nrescue PromptManager::MissingParametersError =&gt; e\n  puts \"Missing parameters: #{e.missing_parameters.join(', ')}\"\n  # Prompt user for missing values\nend\n</code></pre>"},{"location":"core-features/error-handling/#directiveprocessingerror","title":"<code>DirectiveProcessingError</code>","text":"<p>Raised when directive processing fails:</p> <pre><code>begin\n  result = prompt.render\nrescue PromptManager::DirectiveProcessingError =&gt; e\n  puts \"Directive error: #{e.message}\"\n  puts \"Line: #{e.line_number}\" if e.respond_to?(:line_number)\nend\n</code></pre>"},{"location":"core-features/error-handling/#storageerror","title":"<code>StorageError</code>","text":"<p>Raised when storage operations fail:</p> <pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'my_prompt')\nrescue PromptManager::StorageError =&gt; e\n  puts \"Storage error: #{e.message}\"\n  # Check file permissions, disk space, etc.\nend\n</code></pre>"},{"location":"core-features/error-handling/#error-recovery-strategies","title":"Error Recovery Strategies","text":""},{"location":"core-features/error-handling/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>def safe_render_prompt(prompt_id, params = {})\n  begin\n    prompt = PromptManager::Prompt.new(id: prompt_id)\n    prompt.render(params)\n  rescue PromptManager::PromptNotFoundError\n    \"Default response when prompt is unavailable\"\n  rescue PromptManager::MissingParametersError =&gt; e\n    \"Please provide: #{e.missing_parameters.join(', ')}\"\n  rescue =&gt; e\n    logger.error \"Unexpected error rendering prompt: #{e.message}\"\n    \"An error occurred processing your request\"\n  end\nend\n</code></pre>"},{"location":"core-features/error-handling/#retry-logic","title":"Retry Logic","text":"<pre><code>def render_with_retry(prompt, params, max_retries: 3)\n  retries = 0\n\n  begin\n    prompt.render(params)\n  rescue PromptManager::StorageError =&gt; e\n    retries += 1\n    if retries &lt;= max_retries\n      sleep(0.5 * retries)  # Exponential backoff\n      retry\n    else\n      raise e\n    end\n  end\nend\n</code></pre>"},{"location":"core-features/error-handling/#validation-and-prevention","title":"Validation and Prevention","text":""},{"location":"core-features/error-handling/#parameter-validation","title":"Parameter Validation","text":"<pre><code>def validate_parameters(params, required_params)\n  missing = required_params - params.keys\n\n  unless missing.empty?\n    raise PromptManager::MissingParametersError.new(\n      \"Missing required parameters: #{missing.join(', ')}\",\n      missing_parameters: missing\n    )\n  end\nend\n\n# Usage\nvalidate_parameters(user_params, [:customer_name, :order_id])\n</code></pre>"},{"location":"core-features/error-handling/#pre-flight-checks","title":"Pre-flight Checks","text":"<pre><code>def preflight_check(prompt_id)\n  # Check if prompt exists\n  unless PromptManager.storage.exist?(prompt_id)\n    raise PromptManager::PromptNotFoundError, \"Prompt '#{prompt_id}' not found\"\n  end\n\n  # Check for circular includes\n  check_circular_includes(prompt_id)\n\n  # Validate syntax\n  validate_prompt_syntax(prompt_id)\nend\n</code></pre>"},{"location":"core-features/error-handling/#logging-and-debugging","title":"Logging and Debugging","text":""},{"location":"core-features/error-handling/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>PromptManager.configure do |config|\n  config.debug = true\n  config.logger = Logger.new(STDOUT)\nend\n</code></pre>"},{"location":"core-features/error-handling/#custom-error-handlers","title":"Custom Error Handlers","text":"<pre><code>PromptManager.configure do |config|\n  config.error_handler = -&gt;(error, context) {\n    # Custom error handling\n    ErrorReporter.notify(error, context: context)\n\n    # Return fallback response\n    case error\n    when PromptManager::PromptNotFoundError\n      \"Prompt temporarily unavailable\"\n    when PromptManager::MissingParametersError\n      \"Please check your input parameters\"\n    else\n      \"Service temporarily unavailable\"\n    end\n  }\nend\n</code></pre>"},{"location":"core-features/error-handling/#testing-error-conditions","title":"Testing Error Conditions","text":""},{"location":"core-features/error-handling/#rspec-examples","title":"RSpec Examples","text":"<pre><code>describe \"Error handling\" do\n  it \"handles missing prompts gracefully\" do\n    expect {\n      PromptManager::Prompt.new(id: 'nonexistent')\n    }.to raise_error(PromptManager::PromptNotFoundError)\n  end\n\n  it \"validates required parameters\" do\n    prompt = PromptManager::Prompt.new(id: 'test_prompt')\n\n    expect {\n      prompt.render  # No parameters provided\n    }.to raise_error(PromptManager::MissingParametersError)\n  end\nend\n</code></pre>"},{"location":"core-features/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always Handle Exceptions: Never let PromptManager exceptions bubble up unhandled</li> <li>Provide Meaningful Fallbacks: Return sensible defaults when prompts fail</li> <li>Log Errors: Capture error details for debugging and monitoring</li> <li>Validate Early: Check parameters and conditions before processing</li> <li>Test Error Paths: Include error scenarios in your test suite</li> <li>Monitor in Production: Set up alerts for prompt processing failures</li> </ol>"},{"location":"core-features/parameter-history/","title":"Parameter History","text":"<p>PromptManager automatically tracks parameter usage history to help you reuse previously entered values and maintain consistency across prompt executions.</p>"},{"location":"core-features/parameter-history/#automatic-history-tracking","title":"Automatic History Tracking","text":"<p>When you use parameters in your prompts, PromptManager automatically saves the values you provide:</p> <pre><code>prompt = PromptManager::Prompt.new(id: 'customer_email')\nresult = prompt.render(customer_name: 'John Doe', product: 'Pro Plan')\n# These values are automatically saved to history\n</code></pre>"},{"location":"core-features/parameter-history/#history-file-location","title":"History File Location","text":"<p>Parameter history is stored in <code>~/.prompt_manager/parameters_history.yaml</code> by default.</p>"},{"location":"core-features/parameter-history/#accessing-history","title":"Accessing History","text":"<p>Previous parameter values are automatically suggested when you use the same parameter names in subsequent prompts:</p> <pre><code># First time - you provide values\nprompt.render(api_key: 'sk-123', model: 'gpt-4')\n\n# Second time - previous values are available\nprompt.render  # Will suggest previously used api_key and model values\n</code></pre>"},{"location":"core-features/parameter-history/#history-management","title":"History Management","text":""},{"location":"core-features/parameter-history/#viewing-history","title":"Viewing History","text":"<pre><code># Access stored parameter values\nhistory = PromptManager.configuration.parameter_history\nputs history['api_key']  # Shows previously used API keys\n</code></pre>"},{"location":"core-features/parameter-history/#clearing-history","title":"Clearing History","text":"<pre><code># Clear all parameter history\nPromptManager.configuration.clear_parameter_history\n\n# Clear specific parameter\nPromptManager.configuration.clear_parameter('api_key')\n</code></pre>"},{"location":"core-features/parameter-history/#configuration","title":"Configuration","text":"<p>Configure history behavior in your application:</p> <pre><code>PromptManager.configure do |config|\n  config.save_parameter_history = true  # Enable/disable history (default: true)\n  config.parameter_history_file = 'custom_history.yaml'  # Custom file location\n  config.max_history_entries = 10  # Limit stored values per parameter\nend\n</code></pre>"},{"location":"core-features/parameter-history/#privacy-considerations","title":"Privacy Considerations","text":"<p>Parameter history is stored locally and never transmitted. However, be mindful of sensitive data:</p> <ul> <li>API keys and tokens are stored in plain text</li> <li>Consider clearing history for sensitive parameters</li> <li>Use environment variables for truly sensitive data instead of parameter history</li> </ul>"},{"location":"core-features/parameter-history/#best-practices","title":"Best Practices","text":"<ol> <li>Regular Cleanup: Periodically clear old parameter values</li> <li>Sensitive Data: Don't rely on history for secrets - use environment variables</li> <li>Team Sharing: History files are user-specific, not shared across team members</li> <li>Backup: Consider backing up important parameter configurations</li> </ol>"},{"location":"core-features/parameterized-prompts/","title":"Parameterized Prompts","text":"<p>Parameterized prompts are the heart of PromptManager. They allow you to create reusable template prompts with placeholders (keywords) that can be filled with different values.</p>"},{"location":"core-features/parameterized-prompts/#basic-concepts","title":"Basic Concepts","text":""},{"location":"core-features/parameterized-prompts/#what-are-keywords","title":"What are Keywords?","text":"<p>Keywords are placeholders in your prompt text that get replaced with actual values. By default, they follow the pattern <code>[UPPERCASE_TEXT]</code>:</p> <pre><code>Hello [NAME]! Today is [DATE] and you have [COUNT] messages.\n</code></pre>"},{"location":"core-features/parameterized-prompts/#parameter-substitution","title":"Parameter Substitution","text":"<p>When you provide parameter values, PromptManager replaces keywords with their corresponding values:</p> <pre><code>prompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[DATE]\" =&gt; \"2024-01-15\", \n  \"[COUNT]\" =&gt; \"3\"\n}\n\nputs prompt.to_s\n# Output: Hello Alice! Today is 2024-01-15 and you have 3 messages.\n</code></pre>"},{"location":"core-features/parameterized-prompts/#keyword-formats","title":"Keyword Formats","text":""},{"location":"core-features/parameterized-prompts/#default-format","title":"Default Format","text":"<p>The default keyword pattern is <code>[UPPERCASE_WITH_UNDERSCORES_AND_SPACES]</code>:</p> <pre><code># Valid keywords\n[NAME]\n[USER_NAME] \n[FIRST_NAME]\n[ORDER NUMBER]  # Spaces allowed\n[API_KEY]\n</code></pre>"},{"location":"core-features/parameterized-prompts/#custom-keyword-patterns","title":"Custom Keyword Patterns","text":"<p>You can customize the keyword pattern to match your preferences:</p> Mustache StyleColon StyleDollar Style <pre><code>PromptManager::Prompt.parameter_regex = /(\\{\\{[a-z_]+\\}\\})/\n\n# Now use: {{name}}, {{user_name}}, {{api_key}}\nprompt_text = \"Hello {{name}}, your key is {{api_key}}\"\n</code></pre> <pre><code>PromptManager::Prompt.parameter_regex = /(:[a-z_]+)/\n\n# Now use: :name, :user_name, :api_key  \nprompt_text = \"Hello :name, your key is :api_key\"\n</code></pre> <pre><code>PromptManager::Prompt.parameter_regex = /(\\$[A-Z_]+)/\n\n# Now use: $NAME, $USER_NAME, $API_KEY\nprompt_text = \"Hello $NAME, your key is $API_KEY\"\n</code></pre> <p>Regex Requirements</p> <p>Your custom regex must include capturing parentheses <code>()</code> to extract the keyword. The capture group should include the delimiter characters.</p>"},{"location":"core-features/parameterized-prompts/#working-with-parameters","title":"Working with Parameters","text":""},{"location":"core-features/parameterized-prompts/#setting-parameters","title":"Setting Parameters","text":"<p>There are several ways to set parameter values:</p> Direct AssignmentIndividual AssignmentBatch Update <pre><code>prompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[EMAIL]\" =&gt; \"alice@example.com\"\n}\n</code></pre> <pre><code>prompt.parameters[\"[NAME]\"] = \"Bob\"\nprompt.parameters[\"[EMAIL]\"] = \"bob@example.com\"\n</code></pre> <pre><code>new_params = {\n  \"[NAME]\" =&gt; \"Charlie\",\n  \"[ROLE]\" =&gt; \"Administrator\"\n}\nprompt.parameters.merge!(new_params)\n</code></pre>"},{"location":"core-features/parameterized-prompts/#parameter-history-v030","title":"Parameter History (v0.3.0+)","text":"<p>Since version 0.3.0, parameters maintain a history of values as arrays:</p> <pre><code># Setting a single value\nprompt.parameters[\"[NAME]\"] = \"Alice\"\n\n# Internally stored as: [\"Alice\"]\n# The last value is always the most recent\n\n# Adding more values\nprompt.parameters[\"[NAME]\"] = [\"Alice\", \"Bob\", \"Charlie\"]\n\n# Get the current value\ncurrent_name = prompt.parameters[\"[NAME]\"].last  # \"Charlie\"\n\n# Get the full history\nall_names = prompt.parameters[\"[NAME]\"]  # [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre> <p>This history is useful for:</p> <ul> <li>Building dropdown lists in UIs</li> <li>Providing auto-completion</li> <li>Tracking parameter usage over time</li> <li>Implementing \"recent values\" functionality</li> </ul>"},{"location":"core-features/parameterized-prompts/#getting-available-keywords","title":"Getting Available Keywords","text":"<p>Discover what keywords are available in a prompt:</p> <pre><code>prompt = PromptManager::Prompt.new(id: 'email_template')\nkeywords = prompt.keywords\nputs \"Required parameters: #{keywords.join(', ')}\"\n# Output: Required parameters: [TO_NAME], [FROM_NAME], [SUBJECT], [BODY]\n</code></pre>"},{"location":"core-features/parameterized-prompts/#checking-for-missing-parameters","title":"Checking for Missing Parameters","text":"<pre><code>def check_missing_parameters(prompt)\n  required = prompt.keywords.to_set\n  provided = prompt.parameters.keys.to_set\n  missing = required - provided\n\n  unless missing.empty?\n    puts \"\u26a0\ufe0f  Missing parameters: #{missing.to_a.join(', ')}\"\n    return false\n  end\n\n  puts \"\u2705 All parameters provided\"\n  true\nend\n</code></pre>"},{"location":"core-features/parameterized-prompts/#advanced-parameter-techniques","title":"Advanced Parameter Techniques","text":""},{"location":"core-features/parameterized-prompts/#conditional-parameters","title":"Conditional Parameters","text":"<p>Use ERB to make parameters conditional:</p> conditional_greeting.txt<pre><code>Hello [NAME]!\n\n&lt;% if '[ROLE]' == 'admin' %&gt;\nYou have administrative privileges.\n&lt;% elsif '[ROLE]' == 'user' %&gt;\nYou have standard user access.\n&lt;% else %&gt;\nPlease contact support to set up your account.\n&lt;% end %&gt;\n\nYour last login was [LAST_LOGIN].\n</code></pre> <pre><code>prompt = PromptManager::Prompt.new(id: 'conditional_greeting', erb_flag: true)\nprompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[ROLE]\" =&gt; \"admin\",\n  \"[LAST_LOGIN]\" =&gt; \"2024-01-15 09:30\"\n}\n</code></pre>"},{"location":"core-features/parameterized-prompts/#nested-parameter-substitution","title":"Nested Parameter Substitution","text":"<p>Parameters can reference other parameters:</p> nested_example.txt<pre><code>Welcome to [COMPANY_NAME], [USER_NAME]!\n\nYour profile: [USER_PROFILE_URL]\nSupport email: [SUPPORT_EMAIL]\n</code></pre> <pre><code>prompt.parameters = {\n  \"[COMPANY_NAME]\" =&gt; \"Acme Corp\",\n  \"[USER_NAME]\" =&gt; \"alice\",\n  \"[USER_PROFILE_URL]\" =&gt; \"https://[COMPANY_NAME].com/users/[USER_NAME]\".downcase,\n  \"[SUPPORT_EMAIL]\" =&gt; \"support@[COMPANY_NAME].com\".downcase\n}\n\n# First pass replaces top-level parameters\n# Additional processing may be needed for nested substitution\n</code></pre>"},{"location":"core-features/parameterized-prompts/#dynamic-parameter-generation","title":"Dynamic Parameter Generation","text":"<p>Generate parameters programmatically:</p> <pre><code>def generate_user_parameters(user)\n  {\n    \"[USER_ID]\" =&gt; user.id.to_s,\n    \"[USER_NAME]\" =&gt; user.full_name,\n    \"[USER_EMAIL]\" =&gt; user.email,\n    \"[USER_ROLE]\" =&gt; user.role.upcase,\n    \"[JOIN_DATE]\" =&gt; user.created_at.strftime('%B %Y'),\n    \"[LAST_ACTIVE]\" =&gt; time_ago_in_words(user.last_seen_at)\n  }\nend\n\n# Usage\nuser = User.find(123)\nprompt.parameters = generate_user_parameters(user)\n</code></pre>"},{"location":"core-features/parameterized-prompts/#parameter-validation","title":"Parameter Validation","text":"<p>Implement custom validation for your parameters:</p> <pre><code>class ParameterValidator\n  def self.validate(prompt)\n    errors = []\n\n    prompt.parameters.each do |key, value|\n      case key\n      when \"[EMAIL]\"\n        unless value =~ URI::MailTo::EMAIL_REGEXP\n          errors &lt;&lt; \"#{key} must be a valid email address\"\n        end\n      when \"[DATE]\"\n        begin\n          Date.parse(value)\n        rescue ArgumentError\n          errors &lt;&lt; \"#{key} must be a valid date\"\n        end\n      when \"[COUNT]\"\n        unless value.to_i.to_s == value &amp;&amp; value.to_i &gt;= 0\n          errors &lt;&lt; \"#{key} must be a non-negative integer\"\n        end\n      end\n    end\n\n    errors\n  end\nend\n\n# Usage\nerrors = ParameterValidator.validate(prompt)\nif errors.any?\n  puts \"Validation errors:\"\n  errors.each { |error| puts \"  - #{error}\" }\nend\n</code></pre>"},{"location":"core-features/parameterized-prompts/#real-world-examples","title":"Real-World Examples","text":""},{"location":"core-features/parameterized-prompts/#email-template","title":"Email Template","text":"welcome_email.txt<pre><code>Subject: Welcome to [COMPANY_NAME], [FIRST_NAME]!\n\nDear [FULL_NAME],\n\nWelcome to [COMPANY_NAME]! We're excited to have you join our community.\n\nHere are your account details:\n- Username: [USERNAME]\n- Email: [EMAIL]\n- Account Type: [ACCOUNT_TYPE]\n- Member Since: [JOIN_DATE]\n\nNext steps:\n1. Complete your profile at [PROFILE_URL]\n2. Download our mobile app: [APP_STORE_URL]\n3. Join our community forum: [FORUM_URL]\n\nIf you have any questions, contact us at [SUPPORT_EMAIL] or \ncall [SUPPORT_PHONE].\n\nBest regards,\n[SENDER_NAME]\n[SENDER_TITLE]\n[COMPANY_NAME]\n</code></pre>"},{"location":"core-features/parameterized-prompts/#api-documentation-template","title":"API Documentation Template","text":"api_doc_template.txt<pre><code># [API_NAME] API Documentation\n\n## Endpoint: [HTTP_METHOD] [ENDPOINT_URL]\n\n### Description\n[DESCRIPTION]\n\n### Authentication\n[AUTH_TYPE]: `[AUTH_HEADER]: [AUTH_VALUE]`\n\n### Parameters\n\n| Parameter | Type | Required | Description |\n|-----------|------|----------|-------------|\n[PARAMETER_TABLE]\n\n### Example Request\n\n```[REQUEST_LANGUAGE]\n[REQUEST_EXAMPLE]\n</code></pre>"},{"location":"core-features/parameterized-prompts/#example-response","title":"Example Response","text":"<pre><code>[RESPONSE_EXAMPLE]\n</code></pre>"},{"location":"core-features/parameterized-prompts/#error-codes","title":"Error Codes","text":"<p>[ERROR_TABLE]</p> <p>Last updated: [LAST_UPDATED] API Version: [API_VERSION] <pre><code>### Customer Support Template\n\n```text title=\"support_response.txt\"\n//include common/support_header.txt\n\nDear [CUSTOMER_NAME],\n\nThank you for contacting [COMPANY_NAME] support regarding \nticket #[TICKET_ID].\n\nIssue Summary: [ISSUE_SUMMARY]\nPriority Level: [PRIORITY]\nAssigned Agent: [AGENT_NAME]\n\n&lt;% if '[PRIORITY]' == 'urgent' %&gt;\n\ud83d\udea8 This is marked as urgent. We're prioritizing your request \nand aim to resolve it within [URGENT_SLA] hours.\n&lt;% else %&gt;\nWe aim to resolve your issue within [STANDARD_SLA] business days.\n&lt;% end %&gt;\n\nOur preliminary investigation shows:\n[INVESTIGATION_NOTES]\n\nNext steps:\n[NEXT_STEPS]\n\nYou can track your ticket status at: [TICKET_URL]\n\nBest regards,\n[AGENT_NAME]\n[COMPANY_NAME] Support Team\n\n//include common/support_footer.txt\n</code></pre></p>"},{"location":"core-features/parameterized-prompts/#best-practices","title":"Best Practices","text":""},{"location":"core-features/parameterized-prompts/#1-use-descriptive-keywords","title":"1. Use Descriptive Keywords","text":"<pre><code># Good - Clear and descriptive\n\"[USER_FIRST_NAME]\", \"[ORDER_TOTAL_AMOUNT]\", \"[DELIVERY_DATE]\"\n\n# Avoid - Ambiguous abbreviations\n\"[UFN]\", \"[OTA]\", \"[DD]\"\n</code></pre>"},{"location":"core-features/parameterized-prompts/#2-consistent-naming-convention","title":"2. Consistent Naming Convention","text":"<pre><code># Choose one style and stick with it\n\"[USER_NAME]\"      # snake_case\n\"[UserName]\"       # PascalCase  \n\"[user_name]\"      # lowercase\n\n# Be consistent with plurality\n\"[ITEM]\" + \"[ITEM_COUNT]\"     # Singular + count\n\"[ITEMS]\"                     # Plural when multiple\n</code></pre>"},{"location":"core-features/parameterized-prompts/#3-document-your-keywords","title":"3. Document Your Keywords","text":"<pre><code># Email welcome template\n# Keywords:\n#   [USER_NAME] - Full display name of the user\n#   [EMAIL] - User's email address  \n#   [JOIN_DATE] - Date user created account (YYYY-MM-DD format)\n#   [COMPANY_NAME] - Our company name\n\nWelcome [USER_NAME]!\nYour account ([EMAIL]) was created on [JOIN_DATE].\n</code></pre>"},{"location":"core-features/parameterized-prompts/#4-provide-defaults","title":"4. Provide Defaults","text":"<pre><code>def apply_defaults(prompt)\n  defaults = {\n    \"[DATE]\" =&gt; Date.today.to_s,\n    \"[TIME]\" =&gt; Time.now.strftime('%H:%M'),\n    \"[COMPANY_NAME]\" =&gt; \"Your Company\",\n    \"[SUPPORT_EMAIL]\" =&gt; \"support@yourcompany.com\"\n  }\n\n  defaults.each do |key, value|\n    prompt.parameters[key] ||= value\n  end\nend\n</code></pre>"},{"location":"core-features/parameterized-prompts/#5-handle-missing-parameters-gracefully","title":"5. Handle Missing Parameters Gracefully","text":"<pre><code>class SafePrompt\n  def initialize(prompt)\n    @prompt = prompt\n  end\n\n  def to_s\n    text = @prompt.to_s\n\n    # Check for unreplaced keywords\n    unreplaced = text.scan(@prompt.class.parameter_regex).flatten\n\n    if unreplaced.any?\n      puts \"\u26a0\ufe0f  Warning: Unreplaced keywords: #{unreplaced.join(', ')}\"\n\n      # Optionally replace with placeholder\n      unreplaced.each do |keyword|\n        text.gsub!(keyword, \"[MISSING:#{keyword}]\")\n      end\n    end\n\n    text\n  end\nend\n\n# Usage\nsafe_prompt = SafePrompt.new(prompt)\nputs safe_prompt.to_s\n</code></pre>"},{"location":"core-features/parameterized-prompts/#troubleshooting","title":"Troubleshooting","text":""},{"location":"core-features/parameterized-prompts/#keywords-not-being-replaced","title":"Keywords Not Being Replaced","text":"<ol> <li>Check keyword format: Ensure keywords match your regex pattern</li> <li>Verify parameter keys: Keys must exactly match keywords (case-sensitive)</li> <li>Confirm parameter values: Make sure values are set and not nil</li> </ol>"},{"location":"core-features/parameterized-prompts/#parameter-history-issues","title":"Parameter History Issues","text":"<ol> <li>Array format: Remember parameters are arrays since v0.3.0</li> <li>Access latest value: Use <code>.last</code> to get the most recent value</li> <li>Backward compatibility: Single values are automatically converted to arrays</li> </ol>"},{"location":"core-features/parameterized-prompts/#performance-with-large-parameter-sets","title":"Performance with Large Parameter Sets","text":"<ol> <li>Cache keyword extraction: Don't re-parse keywords unnecessarily</li> <li>Batch parameter updates: Use <code>merge!</code> instead of individual assignments</li> <li>Consider parameter validation: Validate early to catch errors sooner</li> </ol>"},{"location":"core-features/parameterized-prompts/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Directive Processing for including other files</li> <li>Explore ERB Integration for dynamic content generation  </li> <li>See Advanced Examples for complex use cases</li> </ul>"},{"location":"core-features/shell-integration/","title":"Shell Integration","text":"<p>PromptManager can automatically substitute environment variables and integrate with shell commands.</p>"},{"location":"core-features/shell-integration/#environment-variables","title":"Environment Variables","text":"<p>Enable environment variable substitution:</p> <pre><code>prompt = PromptManager::Prompt.new(\n  id: 'system_prompt',\n  envar_flag: true\n)\n</code></pre> <p>Environment variables in your prompt text will be automatically replaced.</p>"},{"location":"core-features/shell-integration/#example","title":"Example","text":"system_prompt.txt<pre><code>System: $USER\nHome: $HOME\nPath: $PATH\n\nWorking directory: &lt;%= Dir.pwd %&gt;\n</code></pre>"},{"location":"core-features/shell-integration/#shell-command-execution","title":"Shell Command Execution","text":"<p>PromptManager also supports shell command substitution using <code>$(command)</code> syntax:</p> system_info.txt<pre><code>Current system load: $(uptime)\nDisk usage: $(df -h / | tail -1)\nMemory info: $(vm_stat | head -5)\n</code></pre> <p>Commands are executed when the prompt is processed, with output substituted in place.</p>"},{"location":"core-features/shell-integration/#advanced-example","title":"Advanced Example","text":"<p>The advanced_integrations.rb example demonstrates comprehensive shell integration:</p> <pre><code>### Hardware Platform Details\n**Architecture**: $HOSTTYPE$MACHTYPE\n**Hostname**: $HOSTNAME  \n**Operating System**: $OSTYPE\n**Shell**: $SHELL (version: $BASH_VERSION)\n**User**: $USER\n**Home Directory**: $HOME\n**Current Path**: $PWD\n**Terminal**: $TERM\n\n### Environment Configuration\n**PATH**: $PATH\n**Language**: $LANG\n**Editor**: $EDITOR\n**Pager**: $PAGER\n\n### Performance Context\n**Load Average**: &lt;%= `uptime`.strip rescue 'Unable to determine' %&gt;\n**Memory Info**: &lt;%= `vm_stat | head -5`.strip rescue 'Unable to determine' if RUBY_PLATFORM.include?('darwin') %&gt;\n**Disk Usage**: &lt;%= `df -h / | tail -1`.strip rescue 'Unable to determine' %&gt;\n</code></pre> <p>This creates dynamic prompts that capture real-time system information for analysis.</p>"},{"location":"core-features/shell-integration/#configuration","title":"Configuration","text":"<p>Set environment variables that your prompts will use:</p> <pre><code>export API_KEY=\"your-api-key\"\nexport ENVIRONMENT=\"production\"\nexport OPENAI_API_KEY=\"your-openai-key\"\n</code></pre> <p>For more shell integration examples, see the Examples documentation.</p>"},{"location":"development/architecture/","title":"Architecture","text":"<p>PromptManager follows a modular, layered architecture designed for flexibility, extensibility, and maintainability.</p>"},{"location":"development/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        APP[Your Application]\n        CLI[CLI Tools]\n        WEB[Web Interface]\n    end\n\n    subgraph \"Core Layer\"\n        PROMPT[PromptManager::Prompt]\n        DP[DirectiveProcessor]\n        ERB[ERB Engine]\n        PARAM[Parameter Manager]\n    end\n\n    subgraph \"Storage Layer\"\n        SA[Storage Adapter Interface]\n        FS[FileSystemAdapter]\n        AR[ActiveRecordAdapter] \n        CUSTOM[Custom Adapters]\n    end\n\n    subgraph \"Data Layer\"\n        FILES[File System]\n        DB[Database]\n        API[External APIs]\n    end\n\n    APP --&gt; PROMPT\n    CLI --&gt; PROMPT\n    WEB --&gt; PROMPT\n\n    PROMPT --&gt; DP\n    PROMPT --&gt; ERB\n    PROMPT --&gt; PARAM\n    PROMPT --&gt; SA\n\n    SA --&gt; FS\n    SA --&gt; AR\n    SA --&gt; CUSTOM\n\n    FS --&gt; FILES\n    AR --&gt; DB\n    CUSTOM --&gt; API</code></pre>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#1-prompt-class","title":"1. Prompt Class","text":"<p>The central <code>PromptManager::Prompt</code> class orchestrates all functionality:</p> <pre><code>class PromptManager::Prompt\n  attr_accessor :id, :parameters, :context\n  attr_reader :keywords, :directives\n\n  def initialize(options = {})\n    @id = options[:id]\n    @context = options[:context] || []\n    @directives_processor = options[:directives_processor]\n    @erb_flag = options[:erb_flag] || false\n    @envar_flag = options[:envar_flag] || false\n  end\n\n  def to_s\n    # Processing pipeline\n    text = load_raw_text\n    text = process_directives(text)\n    text = process_erb(text) if @erb_flag\n    text = substitute_envars(text) if @envar_flag\n    text = substitute_parameters(text)\n    text\n  end\nend\n</code></pre>"},{"location":"development/architecture/#2-storage-adapter-pattern","title":"2. Storage Adapter Pattern","text":"<p>Storage adapters implement a common interface:</p> <pre><code>classDiagram\n    class StorageAdapter {\n        &lt;&lt;interface&gt;&gt;\n        +get(id) String, Hash\n        +save(id, text, params) void\n        +delete(id) void\n        +list() Array~String~\n        +search(query) Array~String~\n    }\n\n    class FileSystemAdapter {\n        +prompts_dir Path\n        +prompt_extension String\n        +params_extension String\n        +search_proc Proc\n        +get(id) String, Hash\n        +save(id, text, params) void\n    }\n\n    class ActiveRecordAdapter {\n        +model Class\n        +id_column Symbol\n        +text_column Symbol  \n        +parameters_column Symbol\n        +get(id) String, Hash\n        +save(id, text, params) void\n    }\n\n    StorageAdapter &lt;|-- FileSystemAdapter\n    StorageAdapter &lt;|-- ActiveRecordAdapter</code></pre>"},{"location":"development/architecture/#3-processing-pipeline","title":"3. Processing Pipeline","text":"<p>The prompt processing follows a well-defined pipeline:</p> <pre><code>graph LR\n    A[Raw Text] --&gt; B[Parse Comments]\n    B --&gt; C[Extract Keywords]\n    C --&gt; D[Process Directives]\n    D --&gt; E[Apply ERB]\n    E --&gt; F[Substitute Envars]\n    F --&gt; G[Replace Parameters]\n    G --&gt; H[Final Text]\n\n    subgraph \"Error Handling\"\n        I[Validation]\n        J[Error Recovery]\n    end\n\n    C --&gt; I\n    D --&gt; I\n    E --&gt; I\n    F --&gt; I\n    G --&gt; I\n    I --&gt; J</code></pre>"},{"location":"development/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"development/architecture/#1-adapter-pattern","title":"1. Adapter Pattern","text":"<p>Storage adapters use the Adapter pattern to provide a consistent interface across different storage backends:</p> <pre><code># Common interface\nmodule StorageAdapter\n  def get(id)\n    raise NotImplementedError\n  end\n\n  def save(id, text, parameters)  \n    raise NotImplementedError\n  end\nend\n\n# Specific implementations\nclass FileSystemAdapter\n  include StorageAdapter\n\n  def get(id)\n    text = File.read(prompt_path(id))\n    params = JSON.parse(File.read(params_path(id)))\n    [text, params]\n  end\nend\n</code></pre>"},{"location":"development/architecture/#2-strategy-pattern","title":"2. Strategy Pattern","text":"<p>Directive processing uses the Strategy pattern for different directive types:</p> <pre><code>class DirectiveProcessor\n  def process_directive(directive, prompt)\n    case directive\n    when /^\\/\\/include (.+)$/\n      IncludeStrategy.new.process($1, prompt)\n    when /^\\/\\/import (.+)$/  \n      ImportStrategy.new.process($1, prompt)\n    else\n      raise \"Unknown directive: #{directive}\"\n    end\n  end\nend\n</code></pre>"},{"location":"development/architecture/#3-template-method-pattern","title":"3. Template Method Pattern","text":"<p>The prompt generation uses Template Method pattern:</p> <pre><code>class Prompt\n  def to_s\n    template_method\n  end\n\n  private\n\n  def template_method\n    text = load_text          # Hook 1\n    text = preprocess(text)   # Hook 2  \n    text = process(text)      # Hook 3\n    text = postprocess(text)  # Hook 4\n    text\n  end\n\n  # Hooks can be overridden by subclasses\n  def preprocess(text); text; end\n  def process(text); substitute_parameters(text); end\n  def postprocess(text); text; end\nend\n</code></pre>"},{"location":"development/architecture/#4-configuration-object-pattern","title":"4. Configuration Object Pattern","text":"<p>Storage adapters use configuration objects for flexible setup:</p> <pre><code>class FileSystemAdapter\n  attr_reader :config\n\n  def self.config(&amp;block)\n    @config ||= Configuration.new\n    block.call(@config) if block_given?\n    self\n  end\n\n  class Configuration  \n    attr_accessor :prompts_dir, :prompt_extension, :params_extension\n\n    def initialize\n      @prompts_dir = nil\n      @prompt_extension = '.txt'\n      @params_extension = '.json'\n    end\n  end\nend\n</code></pre>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":""},{"location":"development/architecture/#1-prompt-loading","title":"1. Prompt Loading","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant P as Prompt\n    participant SA as StorageAdapter\n    participant FS as FileSystem\n\n    App-&gt;&gt;P: new(id: 'greeting')\n    P-&gt;&gt;SA: get('greeting')\n    SA-&gt;&gt;FS: read greeting.txt\n    FS--&gt;&gt;SA: raw text\n    SA-&gt;&gt;FS: read greeting.json  \n    FS--&gt;&gt;SA: parameters\n    SA--&gt;&gt;P: text, parameters\n    P--&gt;&gt;App: Prompt instance</code></pre>"},{"location":"development/architecture/#2-prompt-processing","title":"2. Prompt Processing","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant P as Prompt\n    participant DP as DirectiveProcessor\n    participant ERB as ERB Engine\n\n    App-&gt;&gt;P: to_s()\n    P-&gt;&gt;P: extract_keywords()\n    P-&gt;&gt;DP: process_directives(text)\n    DP--&gt;&gt;P: processed text\n    P-&gt;&gt;ERB: process_erb(text)\n    ERB--&gt;&gt;P: templated text\n    P-&gt;&gt;P: substitute_parameters()\n    P--&gt;&gt;App: final text</code></pre>"},{"location":"development/architecture/#3-parameter-management","title":"3. Parameter Management","text":"<pre><code>graph TD\n    A[Set Parameters] --&gt; B{New Format?}\n    B --&gt;|v0.3.0+| C[Store as Array]\n    B --&gt;|Legacy| D[Convert to Array]\n    C --&gt; E[Parameter History]\n    D --&gt; E\n    E --&gt; F[Get Latest Value]\n    E --&gt; G[Get Full History]\n    F --&gt; H[Parameter Substitution]\n    G --&gt; I[UI Dropdowns]</code></pre>"},{"location":"development/architecture/#extension-points","title":"Extension Points","text":"<p>The architecture provides several extension points for customization:</p>"},{"location":"development/architecture/#1-custom-storage-adapters","title":"1. Custom Storage Adapters","text":"<pre><code>class RedisAdapter\n  include PromptManager::StorageAdapter\n\n  def initialize(redis_client)\n    @redis = redis_client\n  end\n\n  def get(id)\n    text = @redis.get(\"prompt:#{id}:text\")\n    params_json = @redis.get(\"prompt:#{id}:params\")\n    params = JSON.parse(params_json || '{}')\n    [text, params]\n  end\nend\n</code></pre>"},{"location":"development/architecture/#2-custom-directive-processors","title":"2. Custom Directive Processors","text":"<pre><code>class CustomDirectiveProcessor &lt; PromptManager::DirectiveProcessor\n  def process_directive(directive, prompt)\n    case directive\n    when /^\\/\\/model (.+)$/\n      @model = $1\n      \"\"  # Remove directive from output\n    when /^\\/\\/temperature (.+)$/\n      @temperature = $1.to_f\n      \"\"\n    else\n      super  # Delegate to parent\n    end\n  end\nend\n</code></pre>"},{"location":"development/architecture/#3-custom-keyword-patterns","title":"3. Custom Keyword Patterns","text":"<pre><code># Support multiple keyword formats\nclass MultiPatternPrompt &lt; PromptManager::Prompt\n  PATTERNS = [\n    /(\\[[A-Z _|]+\\])/,           # [KEYWORD]\n    /(\\{\\{[a-z_]+\\}\\})/,         # {{keyword}}  \n    /(:[a-z_]+)/                 # :keyword\n  ]\n\n  def extract_keywords(text)\n    keywords = []\n    PATTERNS.each do |pattern|\n      keywords.concat(text.scan(pattern).flatten)\n    end\n    keywords.uniq\n  end\nend\n</code></pre>"},{"location":"development/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"development/architecture/#1-lazy-loading","title":"1. Lazy Loading","text":"<pre><code>class Prompt\n  def keywords\n    @keywords ||= extract_keywords(@raw_text)\n  end\n\n  def raw_text\n    @raw_text ||= storage_adapter.get(@id).first\n  end\nend\n</code></pre>"},{"location":"development/architecture/#2-caching","title":"2. Caching","text":"<pre><code>class CachingStorageAdapter\n  def initialize(adapter, cache_store = {})\n    @adapter = adapter\n    @cache = cache_store\n  end\n\n  def get(id)\n    @cache[id] ||= @adapter.get(id)\n  end\nend\n</code></pre>"},{"location":"development/architecture/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>class BatchProcessor  \n  def process_prompts(prompt_ids)\n    # Load all prompts at once\n    prompts_data = storage_adapter.get_batch(prompt_ids)\n\n    # Process in parallel\n    results = prompts_data.map do |id, (text, params)|\n      Thread.new { process_single_prompt(id, text, params) }\n    end.map(&amp;:value)\n\n    results\n  end\nend\n</code></pre>"},{"location":"development/architecture/#error-handling-architecture","title":"Error Handling Architecture","text":"<pre><code>graph TD\n    A[Operation] --&gt; B{Success?}\n    B --&gt;|Yes| C[Return Result]\n    B --&gt;|No| D[Classify Error]\n    D --&gt; E{Error Type}\n    E --&gt;|Storage| F[StorageError]\n    E --&gt;|Parameter| G[ParameterError]\n    E --&gt;|Configuration| H[ConfigurationError]\n    E --&gt;|Processing| I[ProcessingError]\n\n    F --&gt; J[Log &amp; Report]\n    G --&gt; J\n    H --&gt; J  \n    I --&gt; J\n\n    J --&gt; K{Recoverable?}\n    K --&gt;|Yes| L[Apply Recovery Strategy]\n    K --&gt;|No| M[Propagate Error]\n\n    L --&gt; A</code></pre>"},{"location":"development/architecture/#error-hierarchy","title":"Error Hierarchy","text":"<pre><code>module PromptManager\n  class Error &lt; StandardError; end\n\n  class StorageError &lt; Error\n    attr_reader :operation, :id\n\n    def initialize(message, operation: nil, id: nil)\n      super(message)\n      @operation = operation\n      @id = id\n    end\n  end\n\n  class ParameterError &lt; Error\n    attr_reader :missing_params, :invalid_params\n  end\n\n  class ConfigurationError &lt; Error\n    attr_reader :setting, :value\n  end\n\n  class ProcessingError &lt; Error\n    attr_reader :stage, :directive\n  end\nend\n</code></pre>"},{"location":"development/architecture/#security-considerations","title":"Security Considerations","text":""},{"location":"development/architecture/#1-parameter-sanitization","title":"1. Parameter Sanitization","text":"<pre><code>class SecurePrompt &lt; Prompt\n  def substitute_parameters(text)\n    safe_params = sanitize_parameters(@parameters)\n    super(text, safe_params)\n  end\n\n  private\n\n  def sanitize_parameters(params)\n    params.transform_values do |value|\n      # Remove potential injection attacks\n      value.gsub(/[&lt;&gt;'\"&amp;]/, '')\n    end\n  end\nend\n</code></pre>"},{"location":"development/architecture/#2-file-system-security","title":"2. File System Security","text":"<pre><code>class SecureFileSystemAdapter &lt; FileSystemAdapter\n  def prompt_path(id)\n    # Prevent directory traversal\n    sanitized_id = id.gsub(/[^a-zA-Z0-9_-]/, '')\n    raise SecurityError, \"Invalid prompt ID\" if sanitized_id != id\n\n    File.join(@config.prompts_dir, \"#{sanitized_id}.txt\")\n  end\nend\n</code></pre>"},{"location":"development/architecture/#testing-architecture","title":"Testing Architecture","text":"<p>The architecture supports comprehensive testing at multiple levels:</p>"},{"location":"development/architecture/#1-unit-tests","title":"1. Unit Tests","text":"<ul> <li>Individual component testing</li> <li>Mock storage adapters for isolation</li> <li>Parameter validation testing</li> </ul>"},{"location":"development/architecture/#2-integration-tests","title":"2. Integration Tests","text":"<ul> <li>End-to-end prompt processing</li> <li>Multiple storage adapter combinations</li> <li>Error handling scenarios</li> </ul>"},{"location":"development/architecture/#3-performance-tests","title":"3. Performance Tests","text":"<ul> <li>Large prompt collections</li> <li>Concurrent access patterns  </li> <li>Memory usage optimization</li> </ul>"},{"location":"development/architecture/#future-architecture-goals","title":"Future Architecture Goals","text":""},{"location":"development/architecture/#1-plugin-system","title":"1. Plugin System","text":"<ul> <li>Dynamic directive loading</li> <li>Community-contributed processors</li> <li>Runtime plugin management</li> </ul>"},{"location":"development/architecture/#2-distributed-storage","title":"2. Distributed Storage","text":"<ul> <li>Multi-node prompt storage</li> <li>Replication and consistency</li> <li>Fault tolerance</li> </ul>"},{"location":"development/architecture/#3-real-time-updates","title":"3. Real-time Updates","text":"<ul> <li>Live prompt editing</li> <li>Change notification system</li> <li>Collaborative editing support</li> </ul> <p>This architecture provides a solid foundation for current needs while remaining flexible enough to support future enhancements and extensions.</p>"},{"location":"development/contributing/","title":"Contributing to PromptManager","text":"<p>Thank you for your interest in contributing to PromptManager! This guide will help you get started with contributing to the project.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ruby 3.0 or higher</li> <li>Git</li> <li>A GitHub account</li> </ul>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/YOUR_USERNAME/prompt_manager.git\ncd prompt_manager\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>bundle install\n</code></pre></p> </li> <li> <p>Run the tests to ensure everything is working:    <pre><code>bundle exec rspec\n</code></pre></p> </li> <li> <p>Create a feature branch:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>We follow standard Ruby conventions and use RuboCop for code style enforcement:</p> <pre><code># Check code style\nbundle exec rubocop\n\n# Auto-fix style issues\nbundle exec rubocop -a\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>We use RSpec for testing. Please ensure all tests pass and add tests for new features:</p> <pre><code># Run all tests\nbundle exec rspec\n\n# Run specific test file\nbundle exec rspec spec/prompt_spec.rb\n\n# Run tests with coverage\nCOVERAGE=true bundle exec rspec\n</code></pre>"},{"location":"development/contributing/#test-coverage","title":"Test Coverage","text":"<p>We aim for high test coverage. Check coverage after running tests:</p> <pre><code>open coverage/index.html  # macOS\nxdg-open coverage/index.html  # Linux\n</code></pre>"},{"location":"development/contributing/#making-changes","title":"Making Changes","text":""},{"location":"development/contributing/#adding-new-features","title":"Adding New Features","text":"<ol> <li>Create an issue first to discuss the feature</li> <li>Write tests for your feature (TDD approach preferred)</li> <li>Implement the feature with clear, readable code</li> <li>Update documentation as needed</li> <li>Ensure all tests pass</li> </ol>"},{"location":"development/contributing/#bug-fixes","title":"Bug Fixes","text":"<ol> <li>Create a failing test that reproduces the bug</li> <li>Fix the bug with minimal changes</li> <li>Ensure the test now passes</li> <li>Check for any regressions</li> </ol>"},{"location":"development/contributing/#example-adding-a-new-storage-adapter","title":"Example: Adding a New Storage Adapter","text":"<pre><code># 1. Create the adapter class\nclass MyCustomAdapter &lt; PromptManager::Storage::Base\n  def read(prompt_id)\n    # Implementation\n  end\n\n  def write(prompt_id, content)\n    # Implementation\n  end\n\n  # ... other required methods\nend\n\n# 2. Add comprehensive tests\nRSpec.describe MyCustomAdapter do\n  let(:adapter) { described_class.new(config_options) }\n\n  include_examples 'a storage adapter'\n\n  describe 'custom functionality' do\n    it 'handles specific use case' do\n      # Test implementation\n    end\n  end\nend\n\n# 3. Update documentation\n# Add to docs/storage/custom-adapters.md\n</code></pre>"},{"location":"development/contributing/#code-guidelines","title":"Code Guidelines","text":""},{"location":"development/contributing/#ruby-style-guide","title":"Ruby Style Guide","text":"<ul> <li>Use 2 spaces for indentation</li> <li>Follow Ruby naming conventions (snake_case for methods and variables)</li> <li>Keep line length under 100 characters</li> <li>Use descriptive method and variable names</li> <li>Add comments for complex logic</li> </ul>"},{"location":"development/contributing/#architecture-principles","title":"Architecture Principles","text":"<ul> <li>Single Responsibility: Each class should have one clear purpose</li> <li>Open/Closed: Open for extension, closed for modification</li> <li>Dependency Injection: Avoid hard dependencies, use dependency injection</li> <li>Error Handling: Handle errors gracefully with meaningful messages</li> </ul>"},{"location":"development/contributing/#example-code-structure","title":"Example Code Structure","text":"<pre><code>module PromptManager\n  module Storage\n    class CustomAdapter &lt; Base\n      # Clear initialization with validation\n      def initialize(connection_string:, **options)\n        validate_connection_string(connection_string)\n        @connection = establish_connection(connection_string)\n        super(**options)\n      end\n\n      # Clear method responsibilities\n      def read(prompt_id)\n        validate_prompt_id(prompt_id)\n\n        result = @connection.get(key_for(prompt_id))\n        raise PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\") unless result\n\n        result\n      rescue ConnectionError =&gt; e\n        raise StorageError.new(\"Connection failed: #{e.message}\")\n      end\n\n      private\n\n      # Helper methods are private and focused\n      def validate_prompt_id(prompt_id)\n        raise ArgumentError, 'prompt_id cannot be nil' if prompt_id.nil?\n        raise ArgumentError, 'prompt_id cannot be empty' if prompt_id.empty?\n      end\n\n      def key_for(prompt_id)\n        \"prompts:#{prompt_id}\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"development/contributing/#test-structure","title":"Test Structure","text":"<pre><code>RSpec.describe PromptManager::Prompt do\n  # Use let blocks for test setup\n  let(:prompt_id) { 'test_prompt' }\n  let(:storage) { instance_double(PromptManager::Storage::Base) }\n  let(:prompt) { described_class.new(id: prompt_id, storage: storage) }\n\n  describe '#render' do\n    context 'when prompt exists' do\n      before do\n        allow(storage).to receive(:read)\n          .with(prompt_id)\n          .and_return('Hello [NAME]!')\n      end\n\n      it 'renders with parameters' do\n        result = prompt.render(name: 'World')\n        expect(result).to eq 'Hello World!'\n      end\n\n      it 'handles missing parameters gracefully' do\n        expect {\n          prompt.render\n        }.to raise_error(PromptManager::MissingParametersError)\n      end\n    end\n\n    context 'when prompt does not exist' do\n      before do\n        allow(storage).to receive(:read)\n          .with(prompt_id)\n          .and_raise(PromptManager::PromptNotFoundError)\n      end\n\n      it 'raises PromptNotFoundError' do\n        expect {\n          prompt.render\n        }.to raise_error(PromptManager::PromptNotFoundError)\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"development/contributing/#shared-examples","title":"Shared Examples","text":"<p>Use shared examples for common behavior:</p> <pre><code># spec/support/shared_examples/storage_adapter.rb\nRSpec.shared_examples 'a storage adapter' do\n  describe 'required interface' do\n    it 'implements read method' do\n      expect(adapter).to respond_to(:read)\n    end\n\n    it 'implements write method' do\n      expect(adapter).to respond_to(:write)\n    end\n\n    it 'implements exist? method' do\n      expect(adapter).to respond_to(:exist?)\n    end\n  end\n\n  describe 'basic functionality' do\n    let(:prompt_id) { 'test_prompt' }\n    let(:content) { 'Hello [NAME]!' }\n\n    it 'stores and retrieves content' do\n      adapter.write(prompt_id, content)\n      expect(adapter.read(prompt_id)).to eq content\n    end\n  end\nend\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#code-documentation","title":"Code Documentation","text":"<p>Use YARD for inline documentation:</p> <pre><code># Renders a prompt with the given parameters\n#\n# @param parameters [Hash] Key-value pairs for parameter substitution\n# @return [String] The rendered prompt content\n# @raise [PromptNotFoundError] If the prompt cannot be found\n# @raise [MissingParametersError] If required parameters are missing\n#\n# @example Basic usage\n#   prompt = PromptManager::Prompt.new(id: 'welcome')\n#   result = prompt.render(name: 'John', company: 'Acme Corp')\n#\n# @example With nested parameters\n#   prompt.render(user: { name: 'Jane', email: 'jane@example.com' })\ndef render(parameters = {})\n  # Implementation\nend\n</code></pre>"},{"location":"development/contributing/#readme-updates","title":"README Updates","text":"<p>Update the main README.md if your changes affect: - Installation instructions - Basic usage examples - Configuration options - Major features</p>"},{"location":"development/contributing/#changelog","title":"Changelog","text":"<p>Add entries to CHANGELOG.md for: - New features - Bug fixes - Breaking changes - Deprecations</p> <p>Format: <pre><code>## [Unreleased]\n\n### Added\n- New feature description\n\n### Changed\n- Changed behavior description\n\n### Fixed\n- Bug fix description\n\n### Deprecated\n- Deprecated feature description\n</code></pre></p>"},{"location":"development/contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"development/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li>Ensure all tests pass: <code>bundle exec rspec</code></li> <li>Check code style: <code>bundle exec rubocop</code></li> <li>Update documentation as needed</li> <li>Add changelog entry if applicable</li> <li>Rebase your branch on the latest main branch</li> </ol>"},{"location":"development/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ol> <li> <p>Create a clear title: \"Add Redis storage adapter\" or \"Fix parameter parsing bug\"</p> </li> <li> <p>Write a detailed description:    <pre><code>## Summary\nBrief description of what this PR does\n\n## Changes\n- Specific change 1\n- Specific change 2\n\n## Testing\n- Added tests for new functionality\n- All existing tests pass\n\n## Documentation\n- Updated relevant documentation files\n</code></pre></p> </li> <li> <p>Link related issues: \"Closes #123\" or \"Fixes #456\"</p> </li> <li> <p>Request appropriate reviewers</p> </li> </ol>"},{"location":"development/contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests added/updated and passing</li> <li> Code follows style guidelines</li> <li> Documentation updated</li> <li> Changelog updated (if applicable)</li> <li> No merge conflicts with main branch</li> <li> PR description is clear and complete</li> </ul>"},{"location":"development/contributing/#development-resources","title":"Development Resources","text":""},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>prompt_manager/\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 prompt_manager/\n\u2502       \u251c\u2500\u2500 prompt.rb              # Core Prompt class\n\u2502       \u251c\u2500\u2500 storage/               # Storage adapters\n\u2502       \u251c\u2500\u2500 directive_processor.rb # Directive processing\n\u2502       \u2514\u2500\u2500 configuration.rb      # Configuration management\n\u251c\u2500\u2500 spec/                          # Test files\n\u2502   \u251c\u2500\u2500 prompt_manager/\n\u2502   \u251c\u2500\u2500 support/                   # Test helpers\n\u2502   \u2514\u2500\u2500 fixtures/                  # Test data\n\u251c\u2500\u2500 docs/                          # Documentation\n\u2514\u2500\u2500 examples/                      # Usage examples\n</code></pre>"},{"location":"development/contributing/#key-classes-and-modules","title":"Key Classes and Modules","text":"<ul> <li><code>PromptManager::Prompt</code> - Main interface for prompt operations</li> <li><code>PromptManager::Storage::Base</code> - Abstract storage adapter</li> <li><code>PromptManager::DirectiveProcessor</code> - Handles <code>//include</code> and custom directives</li> <li><code>PromptManager::Configuration</code> - Configuration management</li> </ul>"},{"location":"development/contributing/#common-development-tasks","title":"Common Development Tasks","text":"<pre><code># Run tests for specific component\nbundle exec rspec spec/prompt_manager/storage/\n\n# Generate test coverage report\nCOVERAGE=true bundle exec rspec\n\n# Check for security vulnerabilities\nbundle audit\n\n# Update dependencies\nbundle update\n\n# Generate documentation\nyard doc\n</code></pre>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: For bug reports and feature requests</li> <li>Discussions: For questions and general discussion</li> <li>Email: For security-related issues</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - <code>CONTRIBUTORS.md</code> file - Release notes for major contributions - GitHub contributor statistics</p> <p>Thank you for contributing to PromptManager! \ud83c\udf89</p>"},{"location":"development/roadmap/","title":"Roadmap","text":"<p>This roadmap outlines the planned features, improvements, and long-term direction for PromptManager.</p>"},{"location":"development/roadmap/#current-version-05x","title":"Current Version (0.5.x)","text":""},{"location":"development/roadmap/#completed","title":"Completed \u2705","text":"<ul> <li>Core prompt management functionality</li> <li>FileSystem and ActiveRecord storage adapters</li> <li>Parameter substitution with nested object support</li> <li>ERB template integration</li> <li>Basic directive processing (<code>//include</code>)</li> <li>Environment variable substitution</li> <li>Parameter history tracking</li> <li>Comprehensive error handling</li> <li>Documentation website</li> </ul>"},{"location":"development/roadmap/#in-progress","title":"In Progress \ud83d\udea7","text":"<ul> <li>Performance optimization for large prompt libraries</li> <li>Enhanced search and filtering capabilities</li> <li>Improved error messages and debugging tools</li> </ul>"},{"location":"development/roadmap/#version-100-stable-foundation-q2-2024","title":"Version 1.0.0 - Stable Foundation (Q2 2024)","text":""},{"location":"development/roadmap/#major-features","title":"Major Features","text":"<ul> <li>Stable API: Finalized public API with semantic versioning commitment</li> <li>Enhanced Storage Options: </li> <li>Redis adapter</li> <li>S3/cloud storage adapter</li> <li>Encrypted storage support</li> <li>Advanced Templating:</li> <li>Custom directive system</li> <li>Template inheritance</li> <li>Conditional rendering improvements</li> <li>Developer Experience:</li> <li>CLI tool for prompt management</li> <li>VS Code extension for syntax highlighting</li> <li>Interactive prompt editor</li> </ul>"},{"location":"development/roadmap/#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Lazy loading for large prompt libraries</li> <li>Caching layer improvements</li> <li>Bulk operations API</li> <li>Memory usage optimization</li> </ul>"},{"location":"development/roadmap/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>95%+ test coverage</li> <li>Performance benchmarking</li> <li>Security audit</li> <li>Documentation completeness review</li> </ul>"},{"location":"development/roadmap/#version-110-collaboration-features-q3-2024","title":"Version 1.1.0 - Collaboration Features (Q3 2024)","text":""},{"location":"development/roadmap/#team-collaboration","title":"Team Collaboration","text":"<ul> <li>Version Control Integration:</li> <li>Git-based prompt versioning</li> <li>Diff and merge capabilities for prompts</li> <li>Branch-based development workflows</li> <li>Multi-user Support:</li> <li>User permissions and access control</li> <li>Approval workflows for prompt changes</li> <li>Audit logging for all operations</li> </ul>"},{"location":"development/roadmap/#content-management","title":"Content Management","text":"<ul> <li>Prompt Organization:</li> <li>Tags and categories</li> <li>Collections and workspaces</li> <li>Advanced search with faceted navigation</li> <li>Quality Control:</li> <li>Prompt linting and validation</li> <li>A/B testing framework</li> <li>Usage analytics and insights</li> </ul>"},{"location":"development/roadmap/#version-120-ai-integration-q4-2024","title":"Version 1.2.0 - AI Integration (Q4 2024)","text":""},{"location":"development/roadmap/#ai-powered-features","title":"AI-Powered Features","text":"<ul> <li>Intelligent Prompt Assistance:</li> <li>AI-powered prompt generation</li> <li>Optimization suggestions</li> <li>Automatic parameter extraction</li> <li>Smart Search:</li> <li>Semantic search using embeddings</li> <li>Similar prompt recommendations</li> <li>Context-aware suggestions</li> </ul>"},{"location":"development/roadmap/#integration-capabilities","title":"Integration Capabilities","text":"<ul> <li>LLM Provider Integration:</li> <li>Direct integration with OpenAI, Anthropic, etc.</li> <li>Prompt testing and validation</li> <li>Response caching and optimization</li> <li>Workflow Automation:</li> <li>Automated prompt testing</li> <li>Performance monitoring</li> <li>Quality metrics tracking</li> </ul>"},{"location":"development/roadmap/#version-200-enterprise-platform-q2-2025","title":"Version 2.0.0 - Enterprise Platform (Q2 2025)","text":""},{"location":"development/roadmap/#enterprise-features","title":"Enterprise Features","text":"<ul> <li>Scalability:</li> <li>Multi-tenant architecture</li> <li>Horizontal scaling support</li> <li>Enterprise-grade security</li> <li>Integration Platform:</li> <li>REST API and GraphQL endpoints</li> <li>Webhook system</li> <li>Third-party integrations (Slack, Teams, etc.)</li> </ul>"},{"location":"development/roadmap/#advanced-analytics","title":"Advanced Analytics","text":"<ul> <li>Usage Intelligence:</li> <li>Prompt performance analytics</li> <li>User behavior insights</li> <li>ROI tracking and reporting</li> <li>Optimization Engine:</li> <li>Automatic prompt optimization</li> <li>Performance regression detection</li> <li>Resource usage optimization</li> </ul>"},{"location":"development/roadmap/#governance-compliance","title":"Governance &amp; Compliance","text":"<ul> <li>Security &amp; Compliance:</li> <li>SOC 2 Type II compliance</li> <li>GDPR/CCPA compliance tools</li> <li>Data encryption at rest and in transit</li> <li>Governance:</li> <li>Policy management</li> <li>Compliance reporting</li> <li>Data retention controls</li> </ul>"},{"location":"development/roadmap/#long-term-vision-2025","title":"Long-term Vision (2025+)","text":""},{"location":"development/roadmap/#platform-evolution","title":"Platform Evolution","text":"<ul> <li>Microservices Architecture: Break down into specialized services</li> <li>Event-Driven Architecture: Real-time prompt updates and notifications  </li> <li>Global CDN: Distributed prompt delivery for low latency</li> <li>Multi-Language Support: Native support for multiple programming languages</li> </ul>"},{"location":"development/roadmap/#aiml-advancements","title":"AI/ML Advancements","text":"<ul> <li>Prompt Evolution: AI that learns and improves prompts over time</li> <li>Contextual Intelligence: Automatic context injection based on usage patterns</li> <li>Predictive Analytics: Forecast prompt performance and usage trends</li> </ul>"},{"location":"development/roadmap/#developer-ecosystem","title":"Developer Ecosystem","text":"<ul> <li>Plugin System: Extensible architecture for third-party plugins</li> <li>Marketplace: Community-driven prompt and template sharing</li> <li>SDK Library: Native SDKs for popular languages and frameworks</li> </ul>"},{"location":"development/roadmap/#feature-requests-community-input","title":"Feature Requests &amp; Community Input","text":""},{"location":"development/roadmap/#highly-requested-features","title":"Highly Requested Features","text":"<ol> <li>Visual Prompt Editor - GUI for non-technical users</li> <li>Prompt Templates Gallery - Pre-built templates for common use cases</li> <li>Integration Connectors - Native connectors for popular tools</li> <li>Mobile App - Mobile application for prompt management</li> <li>Backup/Export Tools - Data portability and backup solutions</li> </ol>"},{"location":"development/roadmap/#research-exploration","title":"Research &amp; Exploration","text":"<ul> <li>Prompt Compression: Techniques to reduce prompt size while maintaining effectiveness</li> <li>Multi-Modal Prompts: Support for image, audio, and video prompts</li> <li>Federated Learning: Collaborative improvement without sharing sensitive data</li> <li>Quantum-Safe Encryption: Future-proof security measures</li> </ul>"},{"location":"development/roadmap/#release-schedule","title":"Release Schedule","text":""},{"location":"development/roadmap/#release-cadence","title":"Release Cadence","text":"<ul> <li>Major Releases: Every 6-9 months</li> <li>Minor Releases: Every 2-3 months  </li> <li>Patch Releases: As needed (security, critical bugs)</li> <li>Beta/RC Releases: 2-4 weeks before major releases</li> </ul>"},{"location":"development/roadmap/#version-support-policy","title":"Version Support Policy","text":"<ul> <li>Latest Major Version: Full support (features, bugs, security)</li> <li>Previous Major Version: Bug fixes and security updates for 18 months</li> <li>Legacy Versions: Security updates only for 12 months after end of life</li> </ul>"},{"location":"development/roadmap/#contributing-to-the-roadmap","title":"Contributing to the Roadmap","text":""},{"location":"development/roadmap/#how-to-influence-the-roadmap","title":"How to Influence the Roadmap","text":"<ol> <li>Feature Requests: Submit detailed feature requests via GitHub Issues</li> <li>Community Discussion: Participate in roadmap discussions</li> <li>User Research: Provide feedback through surveys and interviews</li> <li>Pull Requests: Contribute implementations for planned features</li> </ol>"},{"location":"development/roadmap/#prioritization-criteria","title":"Prioritization Criteria","text":"<ul> <li>User Impact: How many users benefit and to what degree</li> <li>Strategic Alignment: Fits with long-term vision and goals</li> <li>Technical Feasibility: Implementation complexity and maintainability</li> <li>Community Support: Level of community interest and contribution</li> <li>Business Value: Commercial viability and sustainability</li> </ul>"},{"location":"development/roadmap/#feedback-channels","title":"Feedback Channels","text":"<ul> <li>GitHub Discussions: For feature ideas and architectural discussions</li> <li>User Surveys: Quarterly surveys on feature priorities</li> <li>Community Calls: Monthly calls with active contributors</li> <li>Beta Programs: Early access to new features for feedback</li> </ul>"},{"location":"development/roadmap/#migration-compatibility","title":"Migration &amp; Compatibility","text":""},{"location":"development/roadmap/#breaking-changes-policy","title":"Breaking Changes Policy","text":"<ul> <li>Semantic Versioning: Follow strict semantic versioning</li> <li>Deprecation Warnings: 6-month warning period before removal</li> <li>Migration Guides: Detailed guides for all breaking changes</li> <li>Automated Migration: Tools to assist with major version upgrades</li> </ul>"},{"location":"development/roadmap/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>API Stability: Public API remains stable within major versions</li> <li>Configuration: Configuration format maintained across minor versions</li> <li>Storage Format: Storage adapters maintain backward compatibility</li> <li>Plugin Interface: Plugin API versioning and compatibility matrix</li> </ul>"},{"location":"development/roadmap/#success-metrics","title":"Success Metrics","text":""},{"location":"development/roadmap/#technical-metrics","title":"Technical Metrics","text":"<ul> <li>Performance: Sub-100ms prompt rendering for 95<sup>th</sup> percentile</li> <li>Reliability: 99.9% uptime for cloud-hosted services</li> <li>Scalability: Support for 1M+ prompts per instance</li> <li>Security: Zero critical security vulnerabilities</li> </ul>"},{"location":"development/roadmap/#adoption-metrics","title":"Adoption Metrics","text":"<ul> <li>Community Growth: 10,000+ GitHub stars by end of 2024</li> <li>Enterprise Adoption: 100+ enterprise customers by 2025</li> <li>Ecosystem: 50+ community-contributed plugins and integrations</li> <li>Documentation: 95%+ documentation coverage for all features</li> </ul>"},{"location":"development/roadmap/#quality-metrics","title":"Quality Metrics","text":"<ul> <li>Code Coverage: Maintain 90%+ test coverage</li> <li>Documentation Score: 4.5/5 average user rating</li> <li>Support Response: &lt;24 hour response time for critical issues</li> <li>Community Satisfaction: 8/10 average satisfaction score</li> </ul> <p>This roadmap is a living document that evolves based on user feedback, market conditions, and technical discoveries. While we strive to deliver on these plans, priorities may shift to better serve our community.</p> <p>Last Updated: January 2024 Next Review: April 2024</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers testing strategies, patterns, and best practices for PromptManager development.</p>"},{"location":"development/testing/#test-framework-setup","title":"Test Framework Setup","text":""},{"location":"development/testing/#rspec-configuration","title":"RSpec Configuration","text":"<pre><code># spec/spec_helper.rb\nrequire 'simplecov'\nSimpleCov.start do\n  add_filter '/spec/'\n  minimum_coverage 90\nend\n\nrequire 'prompt_manager'\nrequire 'rspec'\nrequire 'webmock/rspec'\n\nRSpec.configure do |config|\n  # Use expect syntax only\n  config.expect_with :rspec do |expectations|\n    expectations.syntax = :expect\n  end\n\n  # Mock framework\n  config.mock_with :rspec do |mocks|\n    mocks.verify_partial_doubles = true\n  end\n\n  # Shared examples and helpers\n  config.shared_context_metadata_behavior = :apply_to_host_groups\n\n  # Test isolation\n  config.before(:each) do\n    # Reset PromptManager configuration\n    PromptManager.reset_configuration!\n\n    # Clear any cached data\n    if defined?(Rails) &amp;&amp; Rails.cache\n      Rails.cache.clear\n    end\n  end\n\n  config.after(:each) do\n    # Clean up test files\n    FileUtils.rm_rf('tmp/test_prompts') if Dir.exist?('tmp/test_prompts')\n  end\nend\n\n# Load support files\nDir[File.join(__dir__, 'support', '**', '*.rb')].each { |f| require f }\n</code></pre>"},{"location":"development/testing/#test-support-files","title":"Test Support Files","text":"<pre><code># spec/support/shared_examples/storage_adapter.rb\nRSpec.shared_examples 'a storage adapter' do\n  let(:prompt_id) { 'test_prompt' }\n  let(:content) { 'Hello [NAME]!' }\n  let(:updated_content) { 'Updated: [NAME]!' }\n\n  describe 'required interface' do\n    it 'implements all required methods' do\n      expect(adapter).to respond_to(:read)\n      expect(adapter).to respond_to(:write)\n      expect(adapter).to respond_to(:exist?)\n      expect(adapter).to respond_to(:delete)\n      expect(adapter).to respond_to(:list)\n    end\n  end\n\n  describe '#write and #read' do\n    it 'stores and retrieves content' do\n      expect(adapter.write(prompt_id, content)).to be true\n      expect(adapter.read(prompt_id)).to eq content\n    end\n\n    it 'overwrites existing content' do\n      adapter.write(prompt_id, content)\n      adapter.write(prompt_id, updated_content)\n      expect(adapter.read(prompt_id)).to eq updated_content\n    end\n\n    it 'raises PromptNotFoundError for non-existent prompts' do\n      expect {\n        adapter.read('non_existent')\n      }.to raise_error(PromptManager::PromptNotFoundError)\n    end\n  end\n\n  describe '#exist?' do\n    it 'returns false for non-existent prompts' do\n      expect(adapter.exist?('non_existent')).to be false\n    end\n\n    it 'returns true for existing prompts' do\n      adapter.write(prompt_id, content)\n      expect(adapter.exist?(prompt_id)).to be true\n    end\n  end\n\n  describe '#delete' do\n    context 'when prompt exists' do\n      before { adapter.write(prompt_id, content) }\n\n      it 'removes the prompt' do\n        expect(adapter.delete(prompt_id)).to be true\n        expect(adapter.exist?(prompt_id)).to be false\n      end\n    end\n\n    context 'when prompt does not exist' do\n      it 'returns false' do\n        expect(adapter.delete('non_existent')).to be false\n      end\n    end\n  end\n\n  describe '#list' do\n    it 'returns empty array when no prompts exist' do\n      expect(adapter.list).to eq []\n    end\n\n    it 'returns all prompt IDs' do\n      adapter.write('prompt1', 'content1')\n      adapter.write('prompt2', 'content2')\n\n      expect(adapter.list).to contain_exactly('prompt1', 'prompt2')\n    end\n  end\nend\n\n# spec/support/helpers/prompt_helpers.rb\nmodule PromptHelpers\n  def create_test_prompt(id, content, storage: nil)\n    storage ||= test_storage\n    storage.write(id, content)\n\n    PromptManager::Prompt.new(id: id, storage: storage)\n  end\n\n  def test_storage\n    @test_storage ||= PromptManager::Storage::FileSystemAdapter.new(\n      prompts_dir: 'tmp/test_prompts'\n    )\n  end\n\n  def create_test_storage_with_prompts(prompts = {})\n    storage = test_storage\n    prompts.each { |id, content| storage.write(id, content) }\n    storage\n  end\nend\n\nRSpec.configure do |config|\n  config.include PromptHelpers\nend\n</code></pre>"},{"location":"development/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"development/testing/#testing-the-prompt-class","title":"Testing the Prompt Class","text":"<pre><code># spec/prompt_manager/prompt_spec.rb\nRSpec.describe PromptManager::Prompt do\n  let(:prompt_id) { 'test_prompt' }\n  let(:storage) { instance_double(PromptManager::Storage::Base) }\n  let(:prompt) { described_class.new(id: prompt_id, storage: storage) }\n\n  describe '#initialize' do\n    it 'requires an id parameter' do\n      expect {\n        described_class.new\n      }.to raise_error(ArgumentError)\n    end\n\n    it 'accepts optional parameters' do\n      prompt = described_class.new(\n        id: 'test',\n        erb_flag: true,\n        envar_flag: true\n      )\n\n      expect(prompt.id).to eq 'test'\n      expect(prompt.erb_flag).to be true\n      expect(prompt.envar_flag).to be true\n    end\n  end\n\n  describe '#render' do\n    context 'with simple parameter substitution' do\n      let(:content) { 'Hello [NAME]!' }\n\n      before do\n        allow(storage).to receive(:read).with(prompt_id).and_return(content)\n      end\n\n      it 'substitutes parameters' do\n        result = prompt.render(name: 'World')\n        expect(result).to eq 'Hello World!'\n      end\n\n      it 'handles missing parameters' do\n        expect {\n          prompt.render\n        }.to raise_error(PromptManager::MissingParametersError) do |error|\n          expect(error.missing_parameters).to contain_exactly('NAME')\n        end\n      end\n\n      it 'preserves case in parameter names' do\n        content = 'Hello [name] and [NAME]!'\n        allow(storage).to receive(:read).with(prompt_id).and_return(content)\n\n        result = prompt.render(name: 'Alice', NAME: 'BOB')\n        expect(result).to eq 'Hello Alice and BOB!'\n      end\n    end\n\n    context 'with nested parameters' do\n      let(:content) { 'User: [USER.NAME] ([USER.EMAIL])' }\n\n      before do\n        allow(storage).to receive(:read).with(prompt_id).and_return(content)\n      end\n\n      it 'handles nested hash parameters' do\n        result = prompt.render(\n          user: {\n            name: 'John Doe',\n            email: 'john@example.com'\n          }\n        )\n\n        expect(result).to eq 'User: John Doe (john@example.com)'\n      end\n\n      it 'handles missing nested parameters' do\n        expect {\n          prompt.render(user: { name: 'John' })\n        }.to raise_error(PromptManager::MissingParametersError) do |error|\n          expect(error.missing_parameters).to include('USER.EMAIL')\n        end\n      end\n    end\n\n    context 'with array parameters' do\n      let(:content) { 'Items: [ITEMS]' }\n\n      before do\n        allow(storage).to receive(:read).with(prompt_id).and_return(content)\n      end\n\n      it 'joins array elements with commas' do\n        result = prompt.render(items: ['Apple', 'Banana', 'Cherry'])\n        expect(result).to eq 'Items: Apple, Banana, Cherry'\n      end\n\n      it 'handles empty arrays' do\n        result = prompt.render(items: [])\n        expect(result).to eq 'Items: '\n      end\n    end\n\n    context 'with ERB processing' do\n      let(:prompt) { described_class.new(id: prompt_id, storage: storage, erb_flag: true) }\n      let(:content) { 'Today is &lt;%= Date.today.strftime(\"%B %d, %Y\") %&gt;' }\n\n      before do\n        allow(storage).to receive(:read).with(prompt_id).and_return(content)\n        allow(Date).to receive(:today).and_return(Date.new(2024, 1, 15))\n      end\n\n      it 'processes ERB templates' do\n        result = prompt.render\n        expect(result).to eq 'Today is January 15, 2024'\n      end\n    end\n  end\n\n  describe '#parameters' do\n    before do\n      allow(storage).to receive(:read)\n        .with(prompt_id)\n        .and_return('Hello [NAME], your order [ORDER_ID] is ready!')\n    end\n\n    it 'extracts parameter names from content' do\n      expect(prompt.parameters).to contain_exactly('NAME', 'ORDER_ID')\n    end\n  end\n\n  describe '#content' do\n    let(:expected_content) { 'Raw prompt content' }\n\n    before do\n      allow(storage).to receive(:read).with(prompt_id).and_return(expected_content)\n    end\n\n    it 'returns raw content from storage' do\n      expect(prompt.content).to eq expected_content\n    end\n  end\n\n  describe 'error handling' do\n    it 'raises PromptNotFoundError when prompt does not exist' do\n      allow(storage).to receive(:read)\n        .with(prompt_id)\n        .and_raise(PromptManager::PromptNotFoundError.new(\"Prompt not found\"))\n\n      expect {\n        prompt.render\n      }.to raise_error(PromptManager::PromptNotFoundError)\n    end\n  end\nend\n</code></pre>"},{"location":"development/testing/#testing-storage-adapters","title":"Testing Storage Adapters","text":"<pre><code># spec/prompt_manager/storage/file_system_adapter_spec.rb\nRSpec.describe PromptManager::Storage::FileSystemAdapter do\n  let(:test_dir) { 'tmp/test_prompts' }\n  let(:adapter) { described_class.new(prompts_dir: test_dir) }\n\n  before do\n    FileUtils.mkdir_p(test_dir)\n  end\n\n  after do\n    FileUtils.rm_rf(test_dir)\n  end\n\n  include_examples 'a storage adapter'\n\n  describe 'file system specific behavior' do\n    describe '#initialize' do\n      it 'creates directory if it does not exist' do\n        new_dir = 'tmp/new_prompts'\n        expect(Dir.exist?(new_dir)).to be false\n\n        described_class.new(prompts_dir: new_dir)\n        expect(Dir.exist?(new_dir)).to be true\n\n        FileUtils.rm_rf(new_dir)\n      end\n\n      it 'accepts multiple directories' do\n        dirs = ['tmp/prompts1', 'tmp/prompts2']\n        adapter = described_class.new(prompts_dir: dirs)\n\n        dirs.each do |dir|\n          expect(Dir.exist?(dir)).to be true\n          FileUtils.rm_rf(dir)\n        end\n      end\n    end\n\n    describe 'file extensions' do\n      it 'finds .txt files' do\n        File.write(File.join(test_dir, 'test.txt'), 'content')\n        expect(adapter.exist?('test')).to be true\n      end\n\n      it 'finds .md files' do\n        File.write(File.join(test_dir, 'test.md'), 'content')\n        expect(adapter.exist?('test')).to be true\n      end\n\n      it 'prioritizes .txt over .md' do\n        File.write(File.join(test_dir, 'test.txt'), 'txt content')\n        File.write(File.join(test_dir, 'test.md'), 'md content')\n\n        expect(adapter.read('test')).to eq 'txt content'\n      end\n    end\n\n    describe 'subdirectories' do\n      it 'handles nested prompt IDs' do\n        subdir = File.join(test_dir, 'emails')\n        FileUtils.mkdir_p(subdir)\n        File.write(File.join(subdir, 'welcome.txt'), 'Welcome!')\n\n        expect(adapter.read('emails/welcome')).to eq 'Welcome!'\n      end\n    end\n  end\nend\n\n# spec/prompt_manager/storage/active_record_adapter_spec.rb\nRSpec.describe PromptManager::Storage::ActiveRecordAdapter do\n  # Mock ActiveRecord model\n  let(:model_class) do\n    Class.new do\n      def self.name\n        'TestPrompt'\n      end\n\n      attr_accessor :prompt_id, :content\n\n      def initialize(attributes = {})\n        attributes.each { |key, value| send(\"#{key}=\", value) }\n      end\n\n      def save!\n        # Mock save\n      end\n\n      def destroy!\n        # Mock destroy\n      end\n\n      # Mock class methods\n      def self.find_by(conditions)\n        # Override in tests\n      end\n\n      def self.where(conditions)\n        # Override in tests  \n      end\n\n      def self.pluck(*columns)\n        # Override in tests\n      end\n    end\n  end\n\n  let(:adapter) { described_class.new(model_class: model_class) }\n\n  include_examples 'a storage adapter' do\n    # Setup mock expectations for shared examples\n    before do\n      @records = {}\n\n      allow(model_class).to receive(:find_by) do |conditions|\n        id = conditions[:prompt_id]\n        record_data = @records[id]\n        record_data ? model_class.new(record_data) : nil\n      end\n\n      allow(model_class).to receive(:create!) do |attributes|\n        @records[attributes[:prompt_id]] = attributes\n        model_class.new(attributes)\n      end\n\n      allow_any_instance_of(model_class).to receive(:update!) do |instance, attributes|\n        @records[instance.prompt_id].merge!(attributes)\n      end\n\n      allow_any_instance_of(model_class).to receive(:destroy!) do |instance|\n        @records.delete(instance.prompt_id)\n      end\n\n      allow(model_class).to receive(:pluck) do |*columns|\n        @records.values.map { |record| columns.map { |col| record[col] } }\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"development/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"development/testing/#full-stack-integration-tests","title":"Full Stack Integration Tests","text":"<pre><code># spec/integration/prompt_rendering_spec.rb\nRSpec.describe 'Prompt Rendering Integration' do\n  let(:test_dir) { 'tmp/integration_test' }\n  let(:storage) { PromptManager::Storage::FileSystemAdapter.new(prompts_dir: test_dir) }\n\n  before do\n    FileUtils.mkdir_p(test_dir)\n    FileUtils.mkdir_p(File.join(test_dir, 'common'))\n\n    # Create test prompts\n    File.write(\n      File.join(test_dir, 'common', 'header.txt'),\n      'Company: [COMPANY_NAME]'\n    )\n\n    File.write(\n      File.join(test_dir, 'email_template.txt'),\n      \"//include common/header.txt\\n\\nDear [CUSTOMER_NAME],\\nYour order [ORDER_ID] is ready!\"\n    )\n\n    File.write(\n      File.join(test_dir, 'erb_template.txt'),\n      \"&lt;%= erb_flag = true %&gt;\\nGenerated at: &lt;%= Time.current.strftime('%Y-%m-%d') %&gt;\\nHello [NAME]!\"\n    )\n\n    PromptManager.configure do |config|\n      config.storage = storage\n    end\n  end\n\n  after do\n    FileUtils.rm_rf(test_dir)\n  end\n\n  describe 'directive processing' do\n    it 'processes includes and parameter substitution' do\n      prompt = PromptManager::Prompt.new(id: 'email_template')\n\n      result = prompt.render(\n        company_name: 'Acme Corp',\n        customer_name: 'John Doe',\n        order_id: 'ORD-123'\n      )\n\n      expect(result).to eq \"Company: Acme Corp\\n\\nDear John Doe,\\nYour order ORD-123 is ready!\"\n    end\n  end\n\n  describe 'ERB processing' do\n    it 'processes ERB templates with parameters' do\n      prompt = PromptManager::Prompt.new(id: 'erb_template', erb_flag: true)\n\n      # Mock Time.current for consistent testing\n      allow(Time).to receive(:current).and_return(Time.parse('2024-01-15 10:00:00'))\n\n      result = prompt.render(name: 'Alice')\n\n      expect(result).to eq \"Generated at: 2024-01-15\\nHello Alice!\"\n    end\n  end\n\n  describe 'error scenarios' do\n    it 'handles missing includes gracefully' do\n      File.write(\n        File.join(test_dir, 'broken_template.txt'),\n        \"//include non_existent.txt\\nContent\"\n      )\n\n      prompt = PromptManager::Prompt.new(id: 'broken_template')\n\n      expect {\n        prompt.render\n      }.to raise_error(PromptManager::DirectiveProcessingError)\n    end\n  end\nend\n</code></pre>"},{"location":"development/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/testing/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code># spec/performance/rendering_performance_spec.rb\nrequire 'benchmark/ips'\n\nRSpec.describe 'Rendering Performance' do\n  let(:storage) { create_test_storage_with_prompts(test_prompts) }\n\n  let(:test_prompts) do\n    {\n      'simple' =&gt; 'Hello [NAME]!',\n      'complex' =&gt; (1..100).map { |i| \"Line #{i}: [PARAM_#{i}]\" }.join(\"\\n\"),\n      'with_include' =&gt; \"//include simple\\nAdditional content: [VALUE]\"\n    }\n  end\n\n  let(:simple_params) { { name: 'John' } }\n  let(:complex_params) do\n    (1..100).each_with_object({}) { |i, hash| hash[\"param_#{i}\".to_sym] = \"value_#{i}\" }\n  end\n\n  describe 'simple prompt rendering' do\n    it 'renders efficiently' do\n      prompt = PromptManager::Prompt.new(id: 'simple', storage: storage)\n\n      expect {\n        prompt.render(simple_params)\n      }.to perform_under(0.001).sec\n    end\n  end\n\n  describe 'complex prompt rendering' do\n    it 'handles many parameters efficiently' do\n      prompt = PromptManager::Prompt.new(id: 'complex', storage: storage)\n\n      expect {\n        prompt.render(complex_params)\n      }.to perform_under(0.01).sec\n    end\n  end\n\n  describe 'bulk rendering performance' do\n    it 'processes multiple prompts efficiently' do\n      prompts = Array.new(100) { PromptManager::Prompt.new(id: 'simple', storage: storage) }\n\n      expect {\n        prompts.each { |prompt| prompt.render(simple_params) }\n      }.to perform_under(0.1).sec\n    end\n  end\n\n  # Benchmark comparison\n  it 'compares different rendering strategies', :benchmark do\n    prompt = PromptManager::Prompt.new(id: 'simple', storage: storage)\n\n    Benchmark.ips do |x|\n      x.config(time: 2, warmup: 1)\n\n      x.report('direct render') do\n        prompt.render(simple_params)\n      end\n\n      x.report('cached render') do\n        CachedPromptManager.render('simple', simple_params)\n      end\n\n      x.compare!\n    end\n  end\nend\n</code></pre>"},{"location":"development/testing/#memory-usage-tests","title":"Memory Usage Tests","text":"<pre><code># spec/performance/memory_usage_spec.rb\nRSpec.describe 'Memory Usage' do\n  def measure_memory_usage\n    GC.start\n    before = GC.stat[:heap_allocated_pages]\n\n    yield\n\n    GC.start\n    after = GC.stat[:heap_allocated_pages]\n\n    (after - before) * GC::INTERNAL_CONSTANTS[:HEAP_PAGE_SIZE]\n  end\n\n  it 'does not leak memory during rendering' do\n    storage = create_test_storage_with_prompts({\n      'test' =&gt; 'Hello [NAME]!'\n    })\n\n    prompt = PromptManager::Prompt.new(id: 'test', storage: storage)\n\n    memory_used = measure_memory_usage do\n      1000.times do\n        prompt.render(name: 'Test')\n      end\n    end\n\n    # Should not use excessive memory (adjust threshold as needed)\n    expect(memory_used).to be &lt; 10 * 1024 * 1024 # 10MB\n  end\nend\n</code></pre>"},{"location":"development/testing/#mock-and-stub-patterns","title":"Mock and Stub Patterns","text":""},{"location":"development/testing/#storage-mocking","title":"Storage Mocking","text":"<pre><code># spec/support/storage_mocks.rb\nmodule StorageMocks\n  def mock_storage_with_prompts(prompts = {})\n    storage = instance_double(PromptManager::Storage::Base)\n\n    # Mock read method\n    allow(storage).to receive(:read) do |prompt_id|\n      content = prompts[prompt_id]\n      if content\n        content\n      else\n        raise PromptManager::PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\")\n      end\n    end\n\n    # Mock exist? method\n    allow(storage).to receive(:exist?) do |prompt_id|\n      prompts.key?(prompt_id)\n    end\n\n    # Mock write method\n    allow(storage).to receive(:write) do |prompt_id, content|\n      prompts[prompt_id] = content\n      true\n    end\n\n    # Mock delete method\n    allow(storage).to receive(:delete) do |prompt_id|\n      prompts.delete(prompt_id) ? true : false\n    end\n\n    # Mock list method\n    allow(storage).to receive(:list) { prompts.keys }\n\n    storage\n  end\nend\n\nRSpec.configure do |config|\n  config.include StorageMocks\nend\n</code></pre>"},{"location":"development/testing/#external-service-mocking","title":"External Service Mocking","text":"<pre><code># For testing prompts that make external API calls\nRSpec.describe 'API Integration Prompts' do\n  before do\n    # Mock HTTP calls\n    stub_request(:get, 'https://api.example.com/users/123')\n      .to_return(\n        status: 200,\n        body: { name: 'John Doe', email: 'john@example.com' }.to_json,\n        headers: { 'Content-Type' =&gt; 'application/json' }\n      )\n  end\n\n  it 'handles API responses in prompts' do\n    # Test prompt that makes API calls\n  end\nend\n</code></pre>"},{"location":"development/testing/#test-data-management","title":"Test Data Management","text":""},{"location":"development/testing/#fixtures","title":"Fixtures","text":"<pre><code># spec/fixtures/prompts.yml\nsimple_greeting:\n  id: 'simple_greeting'\n  content: 'Hello [NAME]!'\n\ncomplex_email:\n  id: 'complex_email'\n  content: |\n    //include headers/email_header.txt\n\n    Dear [CUSTOMER.NAME],\n\n    Your order #[ORDER.ID] has been processed.\n\n    //include footers/email_footer.txt\n\n# spec/support/fixture_helpers.rb\nmodule FixtureHelpers\n  def load_prompt_fixtures\n    YAML.load_file(File.join(__dir__, '..', 'fixtures', 'prompts.yml'))\n  end\n\n  def create_prompt_from_fixture(fixture_name)\n    fixtures = load_prompt_fixtures\n    fixture = fixtures[fixture_name.to_s]\n\n    storage = mock_storage_with_prompts(fixture['id'] =&gt; fixture['content'])\n    PromptManager::Prompt.new(id: fixture['id'], storage: storage)\n  end\nend\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"development/testing/#github-actions-test-configuration","title":"GitHub Actions Test Configuration","text":"<pre><code># .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        ruby-version: ['3.0', '3.1', '3.2']\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Ruby ${{ matrix.ruby-version }}\n      uses: ruby/setup-ruby@v1\n      with:\n        ruby-version: ${{ matrix.ruby-version }}\n        bundler-cache: true\n\n    - name: Run tests\n      run: |\n        bundle exec rspec --format progress --format RspecJunitFormatter --out tmp/test-results.xml\n\n    - name: Check test coverage\n      run: |\n        bundle exec rspec\n        if [ -f coverage/.resultset.json ]; then\n          echo \"Coverage report generated\"\n        fi\n\n    - name: Upload test results\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: test-results-${{ matrix.ruby-version }}\n        path: tmp/test-results.xml\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Test Isolation: Each test should be independent and not rely on other tests</li> <li>Clear Naming: Test names should clearly describe what is being tested</li> <li>Arrange-Act-Assert: Structure tests with clear setup, action, and verification phases</li> <li>Mock External Dependencies: Don't rely on external services in unit tests</li> <li>Test Edge Cases: Include tests for error conditions and edge cases</li> <li>Performance Testing: Include performance benchmarks for critical paths</li> <li>Documentation: Use tests as documentation of expected behavior</li> <li>Continuous Integration: Run tests automatically on all changes</li> </ol>"},{"location":"examples/advanced/","title":"Advanced Examples","text":"<p>This section demonstrates advanced usage patterns and real-world scenarios with PromptManager.</p>"},{"location":"examples/advanced/#complex-parameter-structures","title":"Complex Parameter Structures","text":""},{"location":"examples/advanced/#nested-object-rendering","title":"Nested Object Rendering","text":"<pre><code># prompts/user_profile.txt\nUser Profile Report\n===================\n\nName: [USER.PERSONAL.FIRST_NAME] [USER.PERSONAL.LAST_NAME]\nEmail: [USER.CONTACT.EMAIL]\nPhone: [USER.CONTACT.PHONE]\n\nAddress:\n[USER.ADDRESS.STREET]\n[USER.ADDRESS.CITY], [USER.ADDRESS.STATE] [USER.ADDRESS.ZIP]\n\nAccount Status: [USER.ACCOUNT.STATUS]\nMember Since: [USER.ACCOUNT.CREATED_DATE]\nLast Login: [USER.ACCOUNT.LAST_LOGIN]\n\nPreferences:\n- Newsletter: [USER.PREFERENCES.NEWSLETTER]\n- Notifications: [USER.PREFERENCES.NOTIFICATIONS]\n</code></pre> <pre><code># Usage\nprompt = PromptManager::Prompt.new(id: 'user_profile')\n\nuser_data = {\n  user: {\n    personal: {\n      first_name: 'John',\n      last_name: 'Doe'\n    },\n    contact: {\n      email: 'john@example.com',\n      phone: '555-0123'\n    },\n    address: {\n      street: '123 Main St',\n      city: 'Springfield',\n      state: 'IL',\n      zip: '62701'\n    },\n    account: {\n      status: 'Active',\n      created_date: '2023-01-15',\n      last_login: '2024-01-20'\n    },\n    preferences: {\n      newsletter: 'Enabled',\n      notifications: 'Email + SMS'\n    }\n  }\n}\n\nreport = prompt.render(user_data)\n</code></pre>"},{"location":"examples/advanced/#dynamic-content-with-erb","title":"Dynamic Content with ERB","text":""},{"location":"examples/advanced/#conditional-content-generation","title":"Conditional Content Generation","text":"<pre><code># prompts/order_confirmation.txt\n&lt;%= erb_flag = true %&gt;\n\nOrder Confirmation #[ORDER_ID]\n==============================\n\nDear [CUSTOMER_NAME],\n\n&lt;% if '[ORDER_STATUS]' == 'express' %&gt;\n\ud83d\ude80 EXPRESS ORDER - Expected delivery: &lt;%= Date.parse('[ORDER_DATE]') + 1 %&gt;\n&lt;% elsif '[ORDER_STATUS]' == 'standard' %&gt;\n\ud83d\udce6 STANDARD ORDER - Expected delivery: &lt;%= Date.parse('[ORDER_DATE]') + 5 %&gt;\n&lt;% else %&gt;\n\ud83d\udcec ECONOMY ORDER - Expected delivery: &lt;%= Date.parse('[ORDER_DATE]') + 10 %&gt;\n&lt;% end %&gt;\n\nItems Ordered:\n&lt;% '[ITEMS]'.split(',').each_with_index do |item, index| %&gt;\n&lt;%= index + 1 %&gt;. &lt;%= item.strip %&gt;\n&lt;% end %&gt;\n\n&lt;% total = '[TOTAL]'.to_f %&gt;\nSubtotal: $&lt;%= sprintf('%.2f', total * 0.9) %&gt;\nTax: $&lt;%= sprintf('%.2f', total * 0.1) %&gt;\nTotal: $&lt;%= sprintf('%.2f', total) %&gt;\n\n&lt;% if total &gt; 100 %&gt;\n\ud83c\udf89 You saved $&lt;%= sprintf('%.2f', total * 0.05) %&gt; with free shipping!\n&lt;% end %&gt;\n\nTrack your order: [TRACKING_URL]\n\nThank you for your business!\n</code></pre> <pre><code>prompt = PromptManager::Prompt.new(id: 'order_confirmation', erb_flag: true)\n\nconfirmation = prompt.render(\n  order_id: 'ORD-2024-001',\n  customer_name: 'Alice Johnson',\n  order_status: 'express',\n  order_date: '2024-01-15',\n  items: 'Laptop Pro, Wireless Mouse, USB-C Hub',\n  total: 1299.99,\n  tracking_url: 'https://track.example.com/ORD-2024-001'\n)\n</code></pre>"},{"location":"examples/advanced/#dynamic-loop-generation","title":"Dynamic Loop Generation","text":"<pre><code># prompts/product_catalog.txt\n&lt;%= erb_flag = true %&gt;\n\nProduct Catalog - [CATEGORY]\n============================\n\n&lt;% products = JSON.parse('[PRODUCTS_JSON]') %&gt;\n&lt;% products.each do |product| %&gt;\n**&lt;%= product['name'] %&gt;**\nPrice: $&lt;%= product['price'] %&gt;\n&lt;% if product['sale_price'] %&gt;\n\ud83c\udff7\ufe0f SALE PRICE: $&lt;%= product['sale_price'] %&gt; (Save $&lt;%= product['price'] - product['sale_price'] %&gt;)\n&lt;% end %&gt;\nRating: &lt;%= '\u2b50' * product['rating'] %&gt;\n&lt;%= product['description'] %&gt;\n\n---\n&lt;% end %&gt;\n\nTotal Products: &lt;%= products.length %&gt;\nAverage Price: $&lt;%= sprintf('%.2f', products.sum { |p| p['sale_price'] || p['price'] } / products.length) %&gt;\n</code></pre> <pre><code>products_data = [\n  { name: 'Laptop Pro', price: 1299.99, sale_price: 999.99, rating: 5, description: 'High-performance laptop' },\n  { name: 'Wireless Mouse', price: 49.99, rating: 4, description: 'Ergonomic wireless mouse' },\n  { name: 'USB-C Hub', price: 79.99, sale_price: 59.99, rating: 4, description: '7-in-1 connectivity hub' }\n]\n\nprompt = PromptManager::Prompt.new(id: 'product_catalog', erb_flag: true)\ncatalog = prompt.render(\n  category: 'Electronics',\n  products_json: products_data.to_json\n)\n</code></pre>"},{"location":"examples/advanced/#advanced-directive-usage","title":"Advanced Directive Usage","text":""},{"location":"examples/advanced/#hierarchical-template-system","title":"Hierarchical Template System","text":"<pre><code># prompts/layouts/base.txt\n//include headers/company_header.txt\n\n[CONTENT]\n\n//include footers/standard_footer.txt\n\n# prompts/layouts/email.txt  \n//include layouts/base.txt\n\nEmail Settings:\n- Unsubscribe: [UNSUBSCRIBE_URL]\n- Update Preferences: [PREFERENCES_URL]\n\n# prompts/headers/company_header.txt\n[COMPANY_NAME] - [DEPARTMENT]\nCustomer Service Portal\nGenerated: &lt;%= Date.today.strftime('%B %d, %Y') %&gt;\n\n# prompts/footers/standard_footer.txt\n--\nThis message was generated automatically.\nFor assistance, contact support@[COMPANY_DOMAIN]\n</code></pre> <pre><code># prompts/customer_notification.txt\n//include layouts/email.txt\n\nDear [CUSTOMER_NAME],\n\nYour account status has been updated to: [STATUS]\n\n&lt;% if '[STATUS]' == 'premium' %&gt;\n\ud83c\udf1f Welcome to Premium! You now have access to:\n- Priority support\n- Advanced features  \n- Exclusive content\n&lt;% end %&gt;\n\nBest regards,\nThe [COMPANY_NAME] Team\n</code></pre>"},{"location":"examples/advanced/#dynamic-template-selection","title":"Dynamic Template Selection","text":"<pre><code># prompts/invoice_template.txt\n&lt;%= erb_flag = true %&gt;\n\n&lt;% template_type = '[TEMPLATE_TYPE]' || 'standard' %&gt;\n//include templates/invoice_&lt;%= template_type %&gt;.txt\n\nInvoice #[INVOICE_ID]\nAmount: $[AMOUNT]\nDue Date: [DUE_DATE]\n\n# prompts/templates/invoice_standard.txt\nStandard Invoice Template\n=========================\nPayment terms: Net 30\n\n# prompts/templates/invoice_premium.txt  \nPremium Invoice Template\n========================\n\u2b50 Priority Processing\nPayment terms: Net 15\n</code></pre>"},{"location":"examples/advanced/#environment-integration","title":"Environment Integration","text":""},{"location":"examples/advanced/#system-information-prompts","title":"System Information Prompts","text":"<pre><code># prompts/system_report.txt  \n&lt;%= envar_flag = true %&gt;\n&lt;%= erb_flag = true %&gt;\n\nSystem Status Report\n===================\nGenerated: &lt;%= Time.now.strftime('%Y-%m-%d %H:%M:%S') %&gt;\n\nEnvironment: $RAILS_ENV\nVersion: $APP_VERSION\nServer: $HOSTNAME\nUser: $USER\n\nDatabase Status: [DB_STATUS]\nCache Status: [CACHE_STATUS]\nQueue Status: [QUEUE_STATUS]\n\n&lt;% if ENV['RAILS_ENV'] == 'production' %&gt;\n\ud83d\udd34 PRODUCTION ENVIRONMENT - Handle with care!\n&lt;% else %&gt;\n\ud83d\udfe1 Development Environment\n&lt;% end %&gt;\n\nMemory Usage: &lt;%= `ps -o pid,ppid,pmem,comm -p #{Process.pid}`.split(\"\\n\").last %&gt;\n</code></pre>"},{"location":"examples/advanced/#configuration-driven-prompts","title":"Configuration-Driven Prompts","text":"<pre><code># config/prompt_config.yml\ndevelopment:\n  api_endpoints:\n    user_service: \"http://localhost:3001\"\n    payment_service: \"http://localhost:3002\"\n  debug_mode: true\n\nproduction:\n  api_endpoints:\n    user_service: \"https://api.example.com/users\"\n    payment_service: \"https://api.example.com/payments\"  \n  debug_mode: false\n\n# prompts/api_integration.txt\n&lt;%= erb_flag = true %&gt;\n&lt;%= envar_flag = true %&gt;\n\n&lt;% config = YAML.load_file(\"config/prompt_config.yml\")[ENV['RAILS_ENV']] %&gt;\n\nAPI Integration Guide\n====================\n\nUser Service: &lt;%= config['api_endpoints']['user_service'] %&gt;\nPayment Service: &lt;%= config['api_endpoints']['payment_service'] %&gt;\n\n&lt;% if config['debug_mode'] %&gt;\nDebug Mode: Enabled\n- Verbose logging active\n- Request/response tracing enabled  \n&lt;% end %&gt;\n\nRequest Headers:\n- Authorization: Bearer $API_TOKEN\n- Content-Type: application/json\n- X-Client-Version: $APP_VERSION\n</code></pre>"},{"location":"examples/advanced/#error-handling-and-fallbacks","title":"Error Handling and Fallbacks","text":""},{"location":"examples/advanced/#graceful-degradation-system","title":"Graceful Degradation System","text":"<pre><code>class RobustPromptRenderer\n  def initialize(primary_prompt_id, fallback_prompt_id = nil)\n    @primary_prompt_id = primary_prompt_id\n    @fallback_prompt_id = fallback_prompt_id\n  end\n\n  def render(parameters = {})\n    render_primary(parameters)\n  rescue PromptManager::PromptNotFoundError\n    render_fallback(parameters)\n  rescue PromptManager::MissingParametersError =&gt; e\n    render_with_defaults(parameters, e.missing_parameters)\n  rescue =&gt; e\n    render_error_response(e, parameters)\n  end\n\n  private\n\n  def render_primary(parameters)\n    prompt = PromptManager::Prompt.new(id: @primary_prompt_id)\n    prompt.render(parameters)\n  end\n\n  def render_fallback(parameters)\n    return \"Service temporarily unavailable\" unless @fallback_prompt_id\n\n    prompt = PromptManager::Prompt.new(id: @fallback_prompt_id)\n    prompt.render(parameters)\n  rescue\n    \"Default response: Thank you for your request.\"\n  end\n\n  def render_with_defaults(parameters, missing_params)\n    # Provide default values for missing parameters\n    defaults = {\n      'customer_name' =&gt; 'Valued Customer',\n      'order_id' =&gt; 'N/A',\n      'date' =&gt; Date.today.to_s\n    }\n\n    filled_params = parameters.dup\n    missing_params.each do |param|\n      filled_params[param.downcase.to_sym] = defaults[param] || \"[#{param}]\"\n    end\n\n    render_primary(filled_params)\n  end\n\n  def render_error_response(error, parameters)\n    Rails.logger.error \"Prompt rendering failed: #{error.message}\"\n    Rails.logger.error \"Parameters: #{parameters.inspect}\"\n\n    \"We're sorry, but we encountered an error processing your request. Please try again later.\"\n  end\nend\n\n# Usage\nrenderer = RobustPromptRenderer.new('customer_welcome', 'generic_welcome')\nmessage = renderer.render(customer_name: 'John Doe')\n</code></pre>"},{"location":"examples/advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"examples/advanced/#prompt-caching-strategy","title":"Prompt Caching Strategy","text":"<pre><code>class CachedPromptRenderer\n  include ActiveSupport::Benchmarkable\n\n  def initialize(cache_store = Rails.cache)\n    @cache = cache_store\n  end\n\n  def render(prompt_id, parameters = {}, cache_options = {})\n    cache_key = generate_cache_key(prompt_id, parameters)\n\n    @cache.fetch(cache_key, cache_options) do\n      benchmark \"Rendering prompt #{prompt_id}\" do\n        prompt = PromptManager::Prompt.new(id: prompt_id)\n        prompt.render(parameters)\n      end\n    end\n  end\n\n  def warm_cache(prompt_configs)\n    prompt_configs.each do |config|\n      render(config[:prompt_id], config[:parameters], expires_in: 1.hour)\n    end\n  end\n\n  def invalidate_cache(prompt_id, parameters = nil)\n    if parameters\n      cache_key = generate_cache_key(prompt_id, parameters)\n      @cache.delete(cache_key)\n    else\n      # Invalidate all cached versions of this prompt\n      pattern = \"prompt:#{prompt_id}:*\"\n      @cache.delete_matched(pattern)\n    end\n  end\n\n  private\n\n  def generate_cache_key(prompt_id, parameters)\n    param_hash = Digest::MD5.hexdigest(parameters.to_json)\n    \"prompt:#{prompt_id}:#{param_hash}\"\n  end\nend\n\n# Usage\ncache_renderer = CachedPromptRenderer.new\nresult = cache_renderer.render('welcome_email', { name: 'Alice' }, expires_in: 30.minutes)\n\n# Warm frequently used prompts\ncache_renderer.warm_cache([\n  { prompt_id: 'welcome_email', parameters: { name: 'Default User' } },\n  { prompt_id: 'order_confirmation', parameters: { status: 'pending' } }\n])\n</code></pre>"},{"location":"examples/advanced/#integration-patterns","title":"Integration Patterns","text":""},{"location":"examples/advanced/#background-job-processing","title":"Background Job Processing","text":"<pre><code>class PromptProcessingJob &lt; ApplicationJob\n  queue_as :default\n\n  def perform(prompt_id, parameters, notification_settings = {})\n    prompt = PromptManager::Prompt.new(id: prompt_id)\n    content = prompt.render(parameters)\n\n    case notification_settings[:delivery_method]\n    when 'email'\n      send_email_notification(content, notification_settings)\n    when 'sms'\n      send_sms_notification(content, notification_settings)\n    when 'push'\n      send_push_notification(content, notification_settings)\n    when 'webhook'\n      send_webhook_notification(content, notification_settings)\n    end\n\n    log_notification_sent(prompt_id, parameters, notification_settings)\n\n  rescue =&gt; e\n    handle_processing_error(e, prompt_id, parameters, notification_settings)\n  end\n\n  private\n\n  def send_email_notification(content, settings)\n    NotificationMailer.custom_message(\n      to: settings[:email],\n      subject: settings[:subject],\n      content: content\n    ).deliver_now\n  end\n\n  def send_webhook_notification(content, settings)\n    HTTParty.post(settings[:webhook_url], {\n      body: {\n        content: content,\n        timestamp: Time.current,\n        metadata: settings[:metadata]\n      }.to_json,\n      headers: {\n        'Content-Type' =&gt; 'application/json',\n        'Authorization' =&gt; \"Bearer #{settings[:api_token]}\"\n      }\n    })\n  end\n\n  def handle_processing_error(error, prompt_id, parameters, settings)\n    Rails.logger.error \"Prompt processing failed: #{error.message}\"\n\n    # Send error notification\n    AdminMailer.prompt_processing_error(\n      error: error,\n      prompt_id: prompt_id,\n      parameters: parameters,\n      settings: settings\n    ).deliver_now\n\n    # Retry with fallback prompt if available\n    if settings[:fallback_prompt_id]\n      PromptProcessingJob.perform_later(\n        settings[:fallback_prompt_id],\n        parameters,\n        settings.merge(retry_count: (settings[:retry_count] || 0) + 1)\n      )\n    end\n  end\nend\n\n# Usage\nPromptProcessingJob.perform_later(\n  'order_shipped',\n  {\n    customer_name: 'John Doe',\n    order_id: 'ORD-123',\n    tracking_number: 'TRK-456',\n    estimated_delivery: Date.tomorrow\n  },\n  {\n    delivery_method: 'email',\n    email: 'customer@example.com',\n    subject: 'Your Order Has Shipped!',\n    fallback_prompt_id: 'generic_shipping_notification'\n  }\n)\n</code></pre> <p>These advanced examples demonstrate the full power and flexibility of PromptManager for complex, real-world applications. They show how to handle nested data structures, implement sophisticated error handling, optimize performance, and integrate with background processing systems.</p>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>This section provides practical, ready-to-use examples that demonstrate PromptManager's core functionality. Each example includes complete code and explanations.</p>"},{"location":"examples/basic/#setup","title":"Setup","text":"<p>All examples assume this basic setup:</p> <pre><code>require 'prompt_manager'\n\n# Configure FileSystem adapter\nPromptManager::Prompt.storage_adapter = \n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = File.expand_path('~/.prompts')\n  end.new\n</code></pre>"},{"location":"examples/basic/#example-1-simple-greeting","title":"Example 1: Simple Greeting","text":"<p>The classic \"Hello World\" example for prompts.</p>"},{"location":"examples/basic/#prompt-file","title":"Prompt File","text":"~/.prompts/greeting.txt<pre><code># Simple greeting prompt\n# Keywords: NAME\n\nHello [NAME]! Welcome to PromptManager.\n\nHow can I help you today?\n</code></pre>"},{"location":"examples/basic/#parameters-file","title":"Parameters File","text":"~/.prompts/greeting.json<pre><code>{\n  \"[NAME]\": [\"World\", \"Alice\", \"Bob\"]\n}\n</code></pre>"},{"location":"examples/basic/#ruby-code","title":"Ruby Code","text":"greeting_example.rb<pre><code>#!/usr/bin/env ruby\nrequire 'prompt_manager'\n\n# Configure storage\nPromptManager::Prompt.storage_adapter = \n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = File.expand_path('~/.prompts')\n  end.new\n\n# Load and use the prompt\nprompt = PromptManager::Prompt.new(id: 'greeting')\nprompt.parameters['[NAME]'] = 'Alice'\n\nputs prompt.to_s\n# Output: Hello Alice! Welcome to PromptManager.\\n\\nHow can I help you today?\n</code></pre> <p>Key Learning Points: - Basic prompt loading with <code>new(id: 'greeting')</code> - Parameter setting with direct assignment - Text generation with <code>to_s</code></p>"},{"location":"examples/basic/#example-2-email-template","title":"Example 2: Email Template","text":"<p>A more realistic example showing email template management.</p>"},{"location":"examples/basic/#prompt-file_1","title":"Prompt File","text":"~/.prompts/welcome_email.txt<pre><code># Welcome email template\n# Keywords: USER_NAME, COMPANY_NAME, LOGIN_URL, SUPPORT_EMAIL\n\nSubject: Welcome to [COMPANY_NAME]!\n\nDear [USER_NAME],\n\nWelcome to [COMPANY_NAME]! We're excited to have you join our community.\n\nTo get started:\n1. Log in to your account: [LOGIN_URL]\n2. Complete your profile setup\n3. Explore our features\n\nIf you need any help, don't hesitate to contact us at [SUPPORT_EMAIL].\n\nBest regards,\nThe [COMPANY_NAME] Team\n</code></pre>"},{"location":"examples/basic/#ruby-code_1","title":"Ruby Code","text":"email_example.rb<pre><code>require 'prompt_manager'\n\nclass WelcomeEmailGenerator\n  def initialize\n    @prompt = PromptManager::Prompt.new(id: 'welcome_email')\n  end\n\n  def generate_for_user(user_data)\n    @prompt.parameters = {\n      '[USER_NAME]' =&gt; user_data[:name],\n      '[COMPANY_NAME]' =&gt; 'Acme Corp',\n      '[LOGIN_URL]' =&gt; 'https://app.acme.com/login',\n      '[SUPPORT_EMAIL]' =&gt; 'support@acme.com'\n    }\n\n    @prompt.to_s\n  end\nend\n\n# Usage\ngenerator = WelcomeEmailGenerator.new\nuser = { name: 'Alice Johnson', email: 'alice@example.com' }\n\nemail_content = generator.generate_for_user(user)\nputs email_content\n\n# Save parameters for future use\ngenerator.instance_variable_get(:@prompt).save\n</code></pre> <p>Key Learning Points: - Organizing prompt logic in classes - Batch parameter assignment with hash - Saving parameter changes back to storage</p>"},{"location":"examples/basic/#example-3-dynamic-content-with-erb","title":"Example 3: Dynamic Content with ERB","text":"<p>Using ERB for conditional content and dynamic generation.</p>"},{"location":"examples/basic/#prompt-file_2","title":"Prompt File","text":"~/.prompts/order_confirmation.txt<pre><code># Order confirmation with dynamic content\n# Keywords: CUSTOMER_NAME, ORDER_NUMBER, ITEM_COUNT, TOTAL_AMOUNT, IS_PREMIUM\n\nDear [CUSTOMER_NAME],\n\nThank you for your order #[ORDER_NUMBER]!\n\n&lt;% item_count = '[ITEM_COUNT]'.to_i %&gt;\nYour order contains &lt;%= item_count %&gt; item&lt;%= 's' if item_count != 1 %&gt;.\n\n&lt;% if '[IS_PREMIUM]' == 'true' %&gt;\n\ud83c\udf1f As a premium member, you'll receive:\n- Free express shipping\n- Priority customer support  \n- Extended warranty on all items\n&lt;% else %&gt;\nStandard shipping will be applied to your order.\n&lt;% end %&gt;\n\nOrder Total: $[TOTAL_AMOUNT]\n\n&lt;% if '[TOTAL_AMOUNT]'.to_f &gt; 100 %&gt;\n\ud83c\udf89 Congratulations! You qualify for free shipping!\n&lt;% end %&gt;\n\nBest regards,\nCustomer Service Team\n</code></pre>"},{"location":"examples/basic/#ruby-code_2","title":"Ruby Code","text":"order_confirmation_example.rb<pre><code>require 'prompt_manager'\n\nclass OrderConfirmation\n  def initialize\n    # Enable ERB processing\n    @prompt = PromptManager::Prompt.new(\n      id: 'order_confirmation',\n      erb_flag: true\n    )\n  end\n\n  def generate(order)\n    @prompt.parameters = {\n      '[CUSTOMER_NAME]' =&gt; order[:customer_name],\n      '[ORDER_NUMBER]' =&gt; order[:order_number],\n      '[ITEM_COUNT]' =&gt; order[:items].count.to_s,\n      '[TOTAL_AMOUNT]' =&gt; sprintf('%.2f', order[:total]),\n      '[IS_PREMIUM]' =&gt; order[:premium_member].to_s\n    }\n\n    @prompt.to_s\n  end\nend\n\n# Usage with different order types\nconfirmation = OrderConfirmation.new\n\n# Regular customer order\nregular_order = {\n  customer_name: 'John Smith',\n  order_number: 'ORD-12345',\n  items: ['Widget A', 'Widget B'],\n  total: 85.50,\n  premium_member: false\n}\n\nputs \"=== Regular Order ===\"\nputs confirmation.generate(regular_order)\n\n# Premium customer order\npremium_order = {\n  customer_name: 'Jane Doe',\n  order_number: 'ORD-12346', \n  items: ['Premium Widget', 'Deluxe Kit', 'Accessories'],\n  total: 150.00,\n  premium_member: true\n}\n\nputs \"\\n=== Premium Order ===\"\nputs confirmation.generate(premium_order)\n</code></pre> <p>Key Learning Points: - Enabling ERB with <code>erb_flag: true</code> - Conditional content using ERB syntax - Dynamic content generation based on parameter values</p>"},{"location":"examples/basic/#example-4-directive-processing","title":"Example 4: Directive Processing","text":"<p>Using directives to include shared content and build modular prompts.</p>"},{"location":"examples/basic/#shared-header-file","title":"Shared Header File","text":"~/.prompts/common/header.txt<pre><code>=====================================\n    ACME CORPORATION\n    Customer Service Division\n=====================================\n\nDate: &lt;%= Date.today.strftime('%B %d, %Y') %&gt;\n</code></pre>"},{"location":"examples/basic/#shared-footer-file","title":"Shared Footer File","text":"~/.prompts/common/footer.txt<pre><code>=====================================\n\nFor immediate assistance:\n\ud83d\udcde Call: 1-800-ACME-HELP\n\ud83d\udce7 Email: support@acme.com  \n\ud83c\udf10 Web: https://help.acme.com\n\nOffice Hours: Monday-Friday, 9 AM - 6 PM EST\n</code></pre>"},{"location":"examples/basic/#main-prompt-file","title":"Main Prompt File","text":"~/.prompts/customer_response.txt<pre><code># Customer service response template\n# Keywords: CUSTOMER_NAME, ISSUE_TYPE, RESOLUTION_TIME, AGENT_NAME\n\n//include common/header.txt\n\nDear [CUSTOMER_NAME],\n\nThank you for contacting us regarding your [ISSUE_TYPE] issue.\n\nWe understand your concern and want to resolve this as quickly as possible. \nBased on our initial review, we expect to have this resolved within [RESOLUTION_TIME].\n\nI'll personally be handling your case and will keep you updated on our progress.\n\nBest regards,\n[AGENT_NAME]\nCustomer Service Representative\n\n//include common/footer.txt\n</code></pre>"},{"location":"examples/basic/#ruby-code_3","title":"Ruby Code","text":"customer_response_example.rb<pre><code>require 'prompt_manager'\n\nclass CustomerServiceResponse\n  def initialize\n    @prompt = PromptManager::Prompt.new(\n      id: 'customer_response',\n      erb_flag: true  # Enable ERB for header date processing\n    )\n  end\n\n  def generate_response(case_data)\n    @prompt.parameters = {\n      '[CUSTOMER_NAME]' =&gt; case_data[:customer_name],\n      '[ISSUE_TYPE]' =&gt; case_data[:issue_type],\n      '[RESOLUTION_TIME]' =&gt; case_data[:expected_resolution],\n      '[AGENT_NAME]' =&gt; case_data[:agent_name]\n    }\n\n    @prompt.to_s\n  end\nend\n\n# Usage\nresponse_generator = CustomerServiceResponse.new\n\ncustomer_case = {\n  customer_name: 'Sarah Wilson',\n  issue_type: 'billing discrepancy',\n  expected_resolution: '2-3 business days',\n  agent_name: 'Mike Johnson'\n}\n\nputs response_generator.generate_response(customer_case)\n</code></pre> <p>Key Learning Points: - Using <code>//include</code> directives for shared content - Combining ERB and directive processing - Building modular, reusable prompt components</p>"},{"location":"examples/basic/#example-5-parameter-history-and-management","title":"Example 5: Parameter History and Management","text":"<p>Leveraging parameter history for better user experience.</p>"},{"location":"examples/basic/#ruby-code_4","title":"Ruby Code","text":"parameter_history_example.rb<pre><code>require 'prompt_manager'\n\nclass PromptWithHistory\n  def initialize(prompt_id)\n    @prompt = PromptManager::Prompt.new(id: prompt_id)\n  end\n\n  def set_parameter(key, value)\n    # Get current history\n    current_history = @prompt.parameters[key] || []\n\n    # Add new value if it's different from the last one\n    unless current_history.last == value\n      current_history &lt;&lt; value\n      # Keep only last 10 values\n      current_history = current_history.last(10)\n    end\n\n    @prompt.parameters[key] = current_history\n    @prompt.save\n  end\n\n  def get_parameter_history(key)\n    @prompt.parameters[key] || []\n  end\n\n  def get_current_parameter(key)\n    history = get_parameter_history(key)\n    history.empty? ? nil : history.last\n  end\n\n  def get_parameter_suggestions(key, limit = 5)\n    history = get_parameter_history(key)\n    history.reverse.take(limit)\n  end\n\n  def generate\n    @prompt.to_s\n  end\nend\n\n# Usage example\nclass InteractivePromptBuilder\n  def initialize\n    @prompt_manager = PromptWithHistory.new('greeting')\n  end\n\n  def interactive_session\n    puts \"=== Interactive Prompt Builder ===\"\n    puts \"Available keywords: #{@prompt_manager.instance_variable_get(:@prompt).keywords.join(', ')}\"\n\n    @prompt_manager.instance_variable_get(:@prompt).keywords.each do |keyword|\n      # Show previous values\n      suggestions = @prompt_manager.get_parameter_suggestions(keyword)\n\n      if suggestions.any?\n        puts \"\\nPrevious values for #{keyword}:\"\n        suggestions.each_with_index do |value, index|\n          puts \"  #{index + 1}. #{value}\"\n        end\n        puts \"  #{suggestions.length + 1}. Enter new value\"\n\n        print \"Choose option or enter new value: \"\n        input = gets.chomp\n\n        if input.to_i.between?(1, suggestions.length)\n          selected_value = suggestions[input.to_i - 1]\n          @prompt_manager.set_parameter(keyword, selected_value)\n          puts \"Selected: #{selected_value}\"\n        else\n          @prompt_manager.set_parameter(keyword, input)\n          puts \"New value saved: #{input}\"\n        end\n      else\n        print \"Enter value for #{keyword}: \"\n        value = gets.chomp\n        @prompt_manager.set_parameter(keyword, value)\n      end\n    end\n\n    puts \"\\n=== Generated Prompt ===\"\n    puts @prompt_manager.generate\n  end\nend\n\n# Run interactive session\n# InteractivePromptBuilder.new.interactive_session\n</code></pre> <p>Key Learning Points: - Working with parameter history arrays - Building user-friendly parameter selection - Maintaining parameter history across sessions</p>"},{"location":"examples/basic/#example-6-error-handling","title":"Example 6: Error Handling","text":"<p>Robust error handling for production use.</p>"},{"location":"examples/basic/#ruby-code_5","title":"Ruby Code","text":"error_handling_example.rb<pre><code>require 'prompt_manager'\n\nclass RobustPromptProcessor\n  def initialize(prompt_id)\n    @prompt_id = prompt_id\n    @prompt = nil\n  end\n\n  def process_with_fallback(parameters, fallback_text = nil)\n    begin\n      # Attempt to load prompt\n      @prompt = PromptManager::Prompt.new(id: @prompt_id)\n\n      # Validate required parameters\n      validate_parameters(parameters)\n\n      # Set parameters\n      @prompt.parameters = parameters\n\n      # Generate text\n      result = @prompt.to_s\n\n      # Check for unreplaced keywords\n      check_unreplaced_keywords(result)\n\n      { success: true, text: result }\n\n    rescue PromptManager::StorageError =&gt; e\n      handle_storage_error(e, fallback_text)\n    rescue PromptManager::ParameterError =&gt; e\n      handle_parameter_error(e)  \n    rescue =&gt; e\n      handle_unexpected_error(e, fallback_text)\n    ensure\n      # Always try to save any parameter changes\n      save_parameters_safely if @prompt\n    end\n  end\n\n  private\n\n  def validate_parameters(parameters)\n    return unless @prompt\n\n    required_keywords = @prompt.keywords\n    provided_keywords = parameters.keys\n    missing = required_keywords - provided_keywords\n\n    unless missing.empty?\n      raise PromptManager::ParameterError, \"Missing required parameters: #{missing.join(', ')}\"\n    end\n  end\n\n  def check_unreplaced_keywords(text)\n    # Look for unreplaced keywords (basic pattern)\n    unreplaced = text.scan(/\\[([A-Z_\\s]+)\\]/).flatten\n\n    if unreplaced.any?\n      puts \"\u26a0\ufe0f  Warning: Found unreplaced keywords: #{unreplaced.join(', ')}\"\n    end\n  end\n\n  def handle_storage_error(error, fallback_text)\n    puts \"\u274c Storage Error: #{error.message}\"\n\n    if fallback_text\n      puts \"\ud83d\udcc4 Using fallback text\"\n      { success: false, text: fallback_text, error: :storage_error }\n    else\n      { success: false, error: :storage_error, message: error.message }\n    end\n  end\n\n  def handle_parameter_error(error)\n    puts \"\u274c Parameter Error: #{error.message}\"\n    { success: false, error: :parameter_error, message: error.message }\n  end\n\n  def handle_unexpected_error(error, fallback_text)\n    puts \"\u274c Unexpected Error: #{error.class} - #{error.message}\"\n    puts error.backtrace.first(3) if ENV['DEBUG']\n\n    if fallback_text\n      { success: false, text: fallback_text, error: :unexpected_error }\n    else\n      { success: false, error: :unexpected_error, message: error.message }\n    end\n  end\n\n  def save_parameters_safely\n    @prompt.save\n  rescue =&gt; e\n    puts \"\u26a0\ufe0f  Warning: Could not save parameters: #{e.message}\"\n  end\nend\n\n# Usage examples\nprocessor = RobustPromptProcessor.new('welcome_email')\n\n# Successful processing\nresult = processor.process_with_fallback({\n  '[USER_NAME]' =&gt; 'Alice',\n  '[COMPANY_NAME]' =&gt; 'Acme Corp'\n})\n\nputs \"Success: #{result[:success]}\"\nputs result[:text] if result[:success]\n\n# Error handling with fallback\nfallback = \"Welcome! Thank you for joining us.\"\n\nresult = processor.process_with_fallback(\n  { '[USER_NAME]' =&gt; 'Bob' },  # Missing required parameter\n  fallback\n)\n\nputs \"Success: #{result[:success]}\"\nputs \"Error: #{result[:error]}\" unless result[:success]\nputs \"Text: #{result[:text]}\" if result[:text]\n</code></pre> <p>Key Learning Points: - Comprehensive error handling for all error types - Graceful fallback strategies - Parameter validation and safety checks - Production-ready error reporting</p>"},{"location":"examples/basic/#example-7-batch-processing","title":"Example 7: Batch Processing","text":"<p>Processing multiple prompts efficiently.</p>"},{"location":"examples/basic/#ruby-code_6","title":"Ruby Code","text":"batch_processing_example.rb<pre><code>require 'prompt_manager'\n\nclass BatchPromptProcessor\n  def initialize\n    @results = []\n    @errors = []\n  end\n\n  def process_batch(prompt_configs)\n    prompt_configs.each_with_index do |config, index|\n      begin\n        result = process_single_prompt(config)\n        @results &lt;&lt; { index: index, config: config, result: result }\n        puts \"\u2705 Processed #{config[:id]} successfully\"\n      rescue =&gt; e\n        error = { index: index, config: config, error: e }\n        @errors &lt;&lt; error\n        puts \"\u274c Failed to process #{config[:id]}: #{e.message}\"\n      end\n    end\n\n    summary\n  end\n\n  def process_single_prompt(config)\n    prompt = PromptManager::Prompt.new(\n      id: config[:id],\n      erb_flag: config[:erb_flag] || false\n    )\n\n    prompt.parameters = config[:parameters]\n    prompt.to_s\n  end\n\n  def summary\n    {\n      total: @results.length + @errors.length,\n      successful: @results.length,\n      failed: @errors.length,\n      results: @results,\n      errors: @errors\n    }\n  end\n\n  def successful_results\n    @results.map { |r| r[:result] }\n  end\n\n  def failed_configs\n    @errors.map { |e| e[:config] }\n  end\nend\n\n# Usage\nbatch_configs = [\n  {\n    id: 'greeting',\n    parameters: { '[NAME]' =&gt; 'Alice' }\n  },\n  {\n    id: 'welcome_email', \n    parameters: {\n      '[USER_NAME]' =&gt; 'Bob',\n      '[COMPANY_NAME]' =&gt; 'Acme Corp',\n      '[LOGIN_URL]' =&gt; 'https://app.acme.com',\n      '[SUPPORT_EMAIL]' =&gt; 'support@acme.com'\n    }\n  },\n  {\n    id: 'order_confirmation',\n    erb_flag: true,\n    parameters: {\n      '[CUSTOMER_NAME]' =&gt; 'Charlie',\n      '[ORDER_NUMBER]' =&gt; 'ORD-789',\n      '[ITEM_COUNT]' =&gt; '3',\n      '[TOTAL_AMOUNT]' =&gt; '199.99',\n      '[IS_PREMIUM]' =&gt; 'true'\n    }\n  }\n]\n\nprocessor = BatchPromptProcessor.new\nsummary = processor.process_batch(batch_configs)\n\nputs \"\\n=== Batch Processing Summary ===\"\nputs \"Total: #{summary[:total]}\"\nputs \"Successful: #{summary[:successful]}\"  \nputs \"Failed: #{summary[:failed]}\"\n\nif summary[:failed] &gt; 0\n  puts \"\\nFailed prompts:\"\n  processor.failed_configs.each do |config|\n    puts \"  - #{config[:id]}\"\n  end\nend\n</code></pre> <p>Key Learning Points: - Batch processing patterns - Error collection and reporting - Processing summaries and statistics - Handling mixed success/failure scenarios</p>"},{"location":"examples/basic/#running-the-examples","title":"Running the Examples","text":"<ol> <li> <p>Create the prompts directory: <pre><code>mkdir -p ~/.prompts/common\n</code></pre></p> </li> <li> <p>Create the prompt files shown in each example</p> </li> <li> <p>Run any example: <pre><code>ruby greeting_example.rb\nruby email_example.rb  \n# etc.\n</code></pre></p> </li> </ol>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Examples: See Advanced Examples for complex scenarios</li> <li>Real World Cases: Check Real World Use Cases for production examples  </li> <li>Core Features: Learn more about Parameterized Prompts</li> </ul>"},{"location":"examples/real-world/","title":"Real World Use Cases","text":"<p>This section presents complete, production-ready examples of PromptManager in real-world scenarios.</p>"},{"location":"examples/real-world/#e-commerce-platform","title":"E-commerce Platform","text":""},{"location":"examples/real-world/#customer-communication-system","title":"Customer Communication System","text":"<p>A complete customer notification system for an e-commerce platform.</p>"},{"location":"examples/real-world/#directory-structure","title":"Directory Structure","text":"<pre><code>prompts/\n\u251c\u2500\u2500 ecommerce/\n\u2502   \u251c\u2500\u2500 orders/\n\u2502   \u2502   \u251c\u2500\u2500 confirmation.txt\n\u2502   \u2502   \u251c\u2500\u2500 shipped.txt\n\u2502   \u2502   \u251c\u2500\u2500 delivered.txt\n\u2502   \u2502   \u2514\u2500\u2500 cancelled.txt\n\u2502   \u251c\u2500\u2500 customers/\n\u2502   \u2502   \u251c\u2500\u2500 welcome.txt\n\u2502   \u2502   \u251c\u2500\u2500 password_reset.txt\n\u2502   \u2502   \u2514\u2500\u2500 account_suspension.txt\n\u2502   \u2514\u2500\u2500 marketing/\n\u2502       \u251c\u2500\u2500 newsletter.txt\n\u2502       \u251c\u2500\u2500 sale_announcement.txt\n\u2502       \u2514\u2500\u2500 product_recommendation.txt\n\u2514\u2500\u2500 shared/\n    \u251c\u2500\u2500 headers/\n    \u2502   \u251c\u2500\u2500 brand_header.txt\n    \u2502   \u2514\u2500\u2500 legal_header.txt\n    \u2514\u2500\u2500 footers/\n        \u251c\u2500\u2500 unsubscribe_footer.txt\n        \u2514\u2500\u2500 contact_footer.txt\n</code></pre>"},{"location":"examples/real-world/#implementation","title":"Implementation","text":"<pre><code># app/services/customer_notification_service.rb\nclass CustomerNotificationService\n  include ActiveModel::Validations\n\n  validates :customer, presence: true\n  validates :notification_type, inclusion: {\n    in: %w[order_confirmation order_shipped order_delivered order_cancelled\n           welcome password_reset account_suspension newsletter sale_announcement]\n  }\n\n  def initialize(customer:, notification_type:, data: {})\n    @customer = customer\n    @notification_type = notification_type\n    @data = data\n  end\n\n  def deliver\n    return false unless valid?\n\n    content = render_notification\n    send_notification(content)\n    log_notification\n\n    true\n  rescue =&gt; e\n    handle_error(e)\n    false\n  end\n\n  private\n\n  attr_reader :customer, :notification_type, :data\n\n  def render_notification\n    prompt_id = \"ecommerce/#{notification_category}/#{notification_type.split('_').last}\"\n\n    prompt = PromptManager::Prompt.new(\n      id: prompt_id,\n      erb_flag: true,\n      envar_flag: true\n    )\n\n    prompt.render(notification_parameters)\n  end\n\n  def notification_category\n    case notification_type\n    when /^order_/ then 'orders'\n    when /^(welcome|password_reset|account_suspension)$/ then 'customers'\n    else 'marketing'\n    end\n  end\n\n  def notification_parameters\n    base_params = {\n      customer_name: customer.full_name,\n      customer_email: customer.email,\n      customer_id: customer.id,\n      company_name: ENV['COMPANY_NAME'],\n      support_email: ENV['SUPPORT_EMAIL'],\n      website_url: ENV['WEBSITE_URL']\n    }\n\n    base_params.merge(notification_specific_params)\n  end\n\n  def notification_specific_params\n    case notification_type\n    when 'order_confirmation'\n      order_confirmation_params\n    when 'order_shipped'\n      order_shipped_params\n    when 'product_recommendation'\n      recommendation_params\n    else\n      data\n    end\n  end\n\n  def order_confirmation_params\n    order = data[:order]\n    {\n      order_id: order.id,\n      order_date: order.created_at.strftime('%B %d, %Y'),\n      order_total: sprintf('%.2f', order.total),\n      order_items: order.line_items.map { |item|\n        \"#{item.quantity}x #{item.product.name} - $#{sprintf('%.2f', item.total)}\"\n      },\n      estimated_delivery: (order.created_at + order.shipping_method.estimated_days.days).strftime('%B %d, %Y'),\n      tracking_url: \"#{ENV['WEBSITE_URL']}/orders/#{order.id}/track\"\n    }\n  end\n\n  def order_shipped_params\n    order = data[:order]\n    shipment = data[:shipment]\n    {\n      order_id: order.id,\n      tracking_number: shipment.tracking_number,\n      carrier: shipment.carrier.name,\n      carrier_tracking_url: shipment.carrier_tracking_url,\n      estimated_delivery: shipment.estimated_delivery_date.strftime('%B %d, %Y'),\n      shipped_items: shipment.line_items.map { |item|\n        \"#{item.quantity}x #{item.product.name}\"\n      }\n    }\n  end\n\n  def recommendation_params\n    recommendations = data[:recommendations]\n    {\n      recommended_products: recommendations.map { |product|\n        {\n          name: product.name,\n          price: sprintf('%.2f', product.price),\n          image_url: product.primary_image.url,\n          product_url: \"#{ENV['WEBSITE_URL']}/products/#{product.slug}\",\n          discount_percentage: product.current_discount&amp;.percentage || 0\n        }\n      },\n      recommendation_reason: data[:reason] || 'Based on your recent purchases'\n    }\n  end\n\n  def send_notification(content)\n    case customer.preferred_notification_method\n    when 'email'\n      send_email(content)\n    when 'sms'\n      send_sms(content)\n    when 'push'\n      send_push_notification(content)\n    else\n      send_email(content)  # Default fallback\n    end\n  end\n\n  def send_email(content)\n    CustomerNotificationMailer.custom_notification(\n      customer: customer,\n      subject: email_subject,\n      content: content,\n      notification_type: notification_type\n    ).deliver_later\n  end\n\n  def email_subject\n    case notification_type\n    when 'order_confirmation' then \"Order Confirmation ##{data[:order].id}\"\n    when 'order_shipped' then \"Your Order Has Shipped! ##{data[:order].id}\"\n    when 'order_delivered' then \"Order Delivered ##{data[:order].id}\"\n    when 'welcome' then \"Welcome to #{ENV['COMPANY_NAME']}!\"\n    when 'password_reset' then \"Password Reset Request\"\n    when 'newsletter' then data[:subject] || \"Newsletter\"\n    else \"Notification from #{ENV['COMPANY_NAME']}\"\n    end\n  end\n\n  def log_notification\n    CustomerNotificationLog.create!(\n      customer: customer,\n      notification_type: notification_type,\n      delivery_method: customer.preferred_notification_method,\n      data: data,\n      delivered_at: Time.current\n    )\n  end\n\n  def handle_error(error)\n    Rails.logger.error \"Notification delivery failed: #{error.message}\"\n    Rails.logger.error error.backtrace.join(\"\\n\")\n\n    ErrorReportingService.notify(error, {\n      customer_id: customer.id,\n      notification_type: notification_type,\n      data: data\n    })\n  end\nend\n</code></pre>"},{"location":"examples/real-world/#prompt-templates","title":"Prompt Templates","text":"<pre><code># prompts/ecommerce/orders/confirmation.txt\n//include shared/headers/brand_header.txt\n\nDear [CUSTOMER_NAME],\n\nThank you for your order! We're excited to confirm that we've received your order and it's being processed.\n\n**Order Details:**\nOrder #: [ORDER_ID]\nOrder Date: [ORDER_DATE]\nTotal: $[ORDER_TOTAL]\n\n**Items Ordered:**\n&lt;% '[ORDER_ITEMS]'.each do |item| %&gt;\n\u2022 &lt;%= item %&gt;\n&lt;% end %&gt;\n\n**Shipping Information:**\nEstimated Delivery: [ESTIMATED_DELIVERY]\nYou can track your order at: [TRACKING_URL]\n\n&lt;% if '[ORDER_TOTAL]'.to_f &gt; 75 %&gt;\n\ud83c\udf89 **Free Shipping Applied!** - You saved $9.99\n&lt;% end %&gt;\n\nWe'll send you another email when your order ships with tracking information.\n\n//include shared/footers/contact_footer.txt\n\n# prompts/ecommerce/orders/shipped.txt  \n//include shared/headers/brand_header.txt\n\nGreat news, [CUSTOMER_NAME]!\n\nYour order #[ORDER_ID] has shipped and is on its way to you.\n\n**Shipping Details:**\n\ud83d\udce6 Carrier: [CARRIER]\n\ud83d\ude9a Tracking Number: [TRACKING_NUMBER]\n\ud83d\udcc5 Estimated Delivery: [ESTIMATED_DELIVERY]\n\n**Track Your Package:**\n[CARRIER_TRACKING_URL]\n\n**Items Shipped:**\n&lt;% '[SHIPPED_ITEMS]'.each do |item| %&gt;\n\u2713 &lt;%= item %&gt;\n&lt;% end %&gt;\n\nYour package should arrive by [ESTIMATED_DELIVERY]. If you have any questions, don't hesitate to reach out!\n\n//include shared/footers/contact_footer.txt\n\n# prompts/ecommerce/marketing/product_recommendation.txt\n//include shared/headers/brand_header.txt\n\nHi [CUSTOMER_NAME],\n\nWe thought you might be interested in these products [RECOMMENDATION_REASON]:\n\n&lt;% '[RECOMMENDED_PRODUCTS]'.each do |product| %&gt;\n**&lt;%= product['name'] %&gt;**\n&lt;% if product['discount_percentage'] &gt; 0 %&gt;\n~~$&lt;%= (product['price'].to_f / (1 - product['discount_percentage']/100.0)).round(2) %&gt;~~ **$&lt;%= product['price'] %&gt;** (&lt;%= product['discount_percentage'] %&gt;% OFF!)\n&lt;% else %&gt;\n$&lt;%= product['price'] %&gt;\n&lt;% end %&gt;\n[View Product](&lt;%= product['product_url'] %&gt;)\n\n&lt;% end %&gt;\n\nThese recommendations expire in 48 hours, so don't wait too long!\n\nHappy shopping!\nThe [COMPANY_NAME] Team\n\n//include shared/footers/unsubscribe_footer.txt\n</code></pre>"},{"location":"examples/real-world/#usage-examples","title":"Usage Examples","text":"<pre><code># Order confirmation\nCustomerNotificationService.new(\n  customer: current_user,\n  notification_type: 'order_confirmation',\n  data: { order: @order }\n).deliver\n\n# Shipping notification\nCustomerNotificationService.new(\n  customer: order.customer,\n  notification_type: 'order_shipped', \n  data: { \n    order: order,\n    shipment: shipment\n  }\n).deliver\n\n# Product recommendations\nCustomerNotificationService.new(\n  customer: user,\n  notification_type: 'product_recommendation',\n  data: {\n    recommendations: RecommendationEngine.for_user(user),\n    reason: \"based on your recent purchase of #{user.recent_orders.first.product_names.first}\"\n  }\n).deliver\n</code></pre>"},{"location":"examples/real-world/#saas-application","title":"SaaS Application","text":""},{"location":"examples/real-world/#multi-tenant-onboarding-system","title":"Multi-tenant Onboarding System","text":"<p>A complete onboarding workflow for a SaaS platform with multiple client organizations.</p> <pre><code># app/services/onboarding_workflow_service.rb\nclass OnboardingWorkflowService\n  WORKFLOW_STEPS = %w[\n    welcome\n    account_setup_instructions\n    feature_introduction\n    integration_guide\n    first_milestone_celebration\n    getting_help\n  ].freeze\n\n  def initialize(organization:, user:)\n    @organization = organization\n    @user = user\n    @step = 0\n  end\n\n  def start_workflow\n    schedule_step(0, delay: 0.minutes)\n  end\n\n  def complete_step(step_name)\n    step_index = WORKFLOW_STEPS.index(step_name)\n    return false unless step_index\n\n    @organization.onboarding_progress.update!(\n      completed_steps: @organization.onboarding_progress.completed_steps | [step_name],\n      current_step: WORKFLOW_STEPS[step_index + 1]\n    )\n\n    schedule_next_step(step_index + 1)\n    true\n  end\n\n  private\n\n  def schedule_step(step_index, delay: 1.day)\n    return if step_index &gt;= WORKFLOW_STEPS.length\n\n    OnboardingEmailJob.set(wait: delay).perform_later(\n      organization_id: @organization.id,\n      user_id: @user.id,\n      step: WORKFLOW_STEPS[step_index]\n    )\n  end\n\n  def schedule_next_step(step_index)\n    delays = {\n      0 =&gt; 0.minutes,    # welcome - immediate\n      1 =&gt; 1.hour,       # setup instructions\n      2 =&gt; 1.day,        # feature intro  \n      3 =&gt; 3.days,       # integration guide\n      4 =&gt; 1.week,       # milestone celebration\n      5 =&gt; 2.weeks       # getting help\n    }\n\n    schedule_step(step_index, delay: delays[step_index] || 3.days)\n  end\nend\n\n# app/jobs/onboarding_email_job.rb\nclass OnboardingEmailJob &lt; ApplicationJob\n  def perform(organization_id:, user_id:, step:)\n    organization = Organization.find(organization_id)\n    user = User.find(user_id)\n\n    prompt = PromptManager::Prompt.new(\n      id: \"saas/onboarding/#{step}\",\n      erb_flag: true\n    )\n\n    content = prompt.render(\n      user_name: user.first_name,\n      user_email: user.email,\n      organization_name: organization.name,\n      organization_plan: organization.current_plan.name,\n      organization_members_count: organization.users.count,\n      setup_url: \"#{ENV['APP_URL']}/setup?org=#{organization.id}\",\n      dashboard_url: \"#{ENV['APP_URL']}/dashboard?org=#{organization.id}\",\n      support_url: \"#{ENV['APP_URL']}/support\",\n      app_name: ENV['APP_NAME'],\n      days_since_signup: (Date.current - organization.created_at.to_date).to_i\n    )\n\n    OnboardingMailer.workflow_step(\n      user: user,\n      organization: organization,\n      step: step,\n      content: content\n    ).deliver_now\n\n    # Track email delivery\n    organization.onboarding_progress.increment!(\"#{step}_emails_sent\")\n  end\nend\n</code></pre>"},{"location":"examples/real-world/#onboarding-prompt-templates","title":"Onboarding Prompt Templates","text":"<pre><code># prompts/saas/onboarding/welcome.txt\n&lt;%= erb_flag = true %&gt;\n\nHi [USER_NAME]! \ud83d\udc4b\n\nWelcome to [APP_NAME]! We're thrilled to have [ORGANIZATION_NAME] join our platform.\n\nOver the next few weeks, I'll be sending you a series of emails to help you get the most out of [APP_NAME]. Here's what to expect:\n\n\ud83d\udccb **Next up (in about an hour):** Account setup guide\n\ud83d\ude80 **Tomorrow:** Feature walkthrough \n\ud83d\udd27 **In 3 days:** Integration setup help\n\ud83c\udf89 **Next week:** Celebrating your first milestone\n\n**Quick Start:**\nReady to dive in right now? Visit your dashboard: [DASHBOARD_URL]\n\n&lt;% if '[ORGANIZATION_PLAN]' == 'trial' %&gt;\n\u23f0 **Trial Reminder:** You have &lt;%= 30 - '[DAYS_SINCE_SIGNUP]'.to_i %&gt; days left in your trial. We'll help you make the most of it!\n&lt;% end %&gt;\n\nLooking forward to your success!\nSarah from the [APP_NAME] team\n\nP.S. Hit reply anytime - I read every email personally! \ud83d\udce7\n\n# prompts/saas/onboarding/account_setup_instructions.txt  \n&lt;%= erb_flag = true %&gt;\n\nHey [USER_NAME],\n\nReady to set up your [APP_NAME] account? Let's get [ORGANIZATION_NAME] fully configured! \n\n**Your 5-Minute Setup Checklist:**\n\u25a1 Complete your organization profile\n\u25a1 Invite your team members (&lt;%= '[ORGANIZATION_MEMBERS_COUNT]'.to_i == 1 ? \"You're flying solo for now!\" : \"You have #{[ORGANIZATION_MEMBERS_COUNT].to_i} members so far\" %&gt;)\n\u25a1 Connect your first integration  \n\u25a1 Set up your preferences\n\u25a1 Take our product tour\n\n**Start Setup: [SETUP_URL]**\n\n&lt;% if '[ORGANIZATION_PLAN]' == 'enterprise' %&gt;\n\ud83c\udfe2 **Enterprise Customer?** \nYour dedicated success manager will reach out within 24 hours to schedule a personalized onboarding call.\n&lt;% end %&gt;\n\n**Need help?** \n- \ud83d\udcd6 Check our setup guide: [SETUP_URL]/guide\n- \ud83d\udcac Live chat support: [SUPPORT_URL]  \n- \ud83d\udce7 Just reply to this email\n\nYou've got this!\nSarah \ud83c\udf1f\n\n# prompts/saas/onboarding/feature_introduction.txt\n&lt;%= erb_flag = true %&gt;\n\nHi [USER_NAME]!\n\nHope you're settling in well with [APP_NAME]! Today I want to show you three features that [ORGANIZATION_PLAN] customers love most:\n\n**\ud83c\udfaf Smart Analytics**\nGet insights into your data with our AI-powered analytics. Perfect for understanding trends and making data-driven decisions.\n[Learn more \u2192]([DASHBOARD_URL]/analytics)\n\n**\ud83d\udd04 Automation Workflows** \n&lt;% if '[ORGANIZATION_PLAN]' == 'enterprise' %&gt;\nSet up complex automation rules to streamline your processes. Enterprise customers can create unlimited workflows!\n&lt;% else %&gt;\nAutomate repetitive tasks with our visual workflow builder. Your plan includes up to 10 active workflows.\n&lt;% end %&gt;\n[See examples \u2192]([DASHBOARD_URL]/workflows)\n\n**\ud83d\udc65 Team Collaboration**\nShare dashboards, leave comments, and keep everyone in sync.\n[Invite teammates \u2192]([SETUP_URL]/team)\n\n**Pro tip:** Most successful teams start with automation workflows. They save an average of 5 hours per week! \n\nWant a personal demo of any of these features? Just reply and I'll set something up.\n\nCheers,\nSarah \ud83d\ude80\n\n# prompts/saas/onboarding/integration_guide.txt\n&lt;%= erb_flag = true %&gt;\n\nHey [USER_NAME],\n\nReady to supercharge [APP_NAME] with integrations? Let's connect your existing tools!\n\n**Popular Integrations for [ORGANIZATION_PLAN] teams:**\n\n\ud83d\udd17 **CRM Integration** (Salesforce, HubSpot, Pipedrive)\nSync your customer data automatically\n[Connect now \u2192]([SETUP_URL]/integrations/crm)\n\n\ud83d\udce7 **Email Marketing** (Mailchimp, ConvertKit, Klaviyo)  \nTrigger campaigns based on your [APP_NAME] data\n[Set up \u2192]([SETUP_URL]/integrations/email)\n\n\ud83d\udcca **Analytics** (Google Analytics, Mixpanel, Segment)\nGet deeper insights by combining data sources\n[Integrate \u2192]([SETUP_URL]/integrations/analytics)\n\n&lt;% if '[ORGANIZATION_PLAN]' == 'enterprise' %&gt;\n\ud83c\udfe2 **Enterprise Exclusive:**\n- Custom API integrations\n- SSO setup (SAML, OAuth)\n- Database connections\n[Contact your success manager for setup]\n&lt;% end %&gt;\n\n**Integration taking longer than expected?** \nOur integration specialists can help! Book a free 30-minute session: [SUPPORT_URL]/integration-help\n\nKeep building,\nSarah \u26a1\n\n# prompts/saas/onboarding/first_milestone_celebration.txt\n&lt;%= erb_flag = true %&gt;\n\n\ud83c\udf89 [USER_NAME], you did it!\n\nIt's been a week since [ORGANIZATION_NAME] joined [APP_NAME], and I wanted to celebrate some awesome progress:\n\n**Your Week 1 Achievements:**\n&lt;% days_active = '[DAYS_SINCE_SIGNUP]'.to_i %&gt;\n\u2705 Account active for &lt;%= days_active %&gt; &lt;%= days_active == 1 ? 'day' : 'days' %&gt;\n&lt;% if '[ORGANIZATION_MEMBERS_COUNT]'.to_i &gt; 1 %&gt;\n\u2705 Team of &lt;%= '[ORGANIZATION_MEMBERS_COUNT]' %&gt; members onboarded\n&lt;% end %&gt;\n\u2705 Dashboard configured and personalized\n\n**What's Working Well:**\nMost teams at your stage are focusing on:\n- Setting up their first automated workflows (saves ~5 hours/week)\n- Connecting 2-3 key integrations  \n- Training team members on core features\n\n**Quick Win for Week 2:**\nTry our \"Smart Automation\" feature - it suggests workflows based on your usage patterns.\n[Check it out \u2192]([DASHBOARD_URL]/automation/suggestions)\n\n&lt;% if '[ORGANIZATION_PLAN]' == 'trial' %&gt;\n\u23f0 **Trial Update:** &lt;%= 30 - days_active %&gt; days remaining\nReady to upgrade? Current customers save 20% on annual plans: [DASHBOARD_URL]/billing\n&lt;% end %&gt;\n\nYou're building something great! Keep going \ud83d\udcaa\n\nSarah &amp; the [APP_NAME] team\n\nP.S. Have a success story to share? I'd love to hear it! \ud83c\udf1f\n</code></pre>"},{"location":"examples/real-world/#healthcare-system","title":"Healthcare System","text":""},{"location":"examples/real-world/#patient-communication-platform","title":"Patient Communication Platform","text":"<p>A HIPAA-compliant patient communication system for healthcare providers.</p> <pre><code># app/services/patient_communication_service.rb  \nclass PatientCommunicationService\n  include EncryptionHelper\n\n  def initialize(patient:, provider:, communication_type:)\n    @patient = patient\n    @provider = provider  \n    @communication_type = communication_type\n    validate_hipaa_compliance!\n  end\n\n  def send_appointment_reminder(appointment)\n    send_secure_communication(\n      'healthcare/appointments/reminder',\n      appointment_reminder_params(appointment)\n    )\n  end\n\n  def send_test_results(test_result)\n    send_secure_communication(\n      'healthcare/results/lab_results',\n      test_results_params(test_result)\n    )\n  end\n\n  def send_medication_reminder(prescription)\n    send_secure_communication(\n      'healthcare/medications/reminder', \n      medication_params(prescription)\n    )\n  end\n\n  private\n\n  def send_secure_communication(prompt_id, parameters)\n    # Generate encrypted message\n    prompt = PromptManager::Prompt.new(id: prompt_id)\n    content = prompt.render(parameters)\n\n    encrypted_content = encrypt_phi(content)\n\n    # Send via secure channel\n    case @patient.preferred_communication_method\n    when 'secure_email'\n      send_encrypted_email(encrypted_content)\n    when 'patient_portal' \n      post_to_patient_portal(encrypted_content)\n    when 'secure_sms'\n      send_encrypted_sms(encrypted_content)\n    end\n\n    # Log communication (HIPAA audit trail)\n    log_patient_communication(prompt_id, parameters)\n  end\n\n  def appointment_reminder_params(appointment)\n    {\n      patient_first_name: @patient.first_name,\n      appointment_date: appointment.scheduled_at.strftime('%A, %B %d, %Y'),\n      appointment_time: appointment.scheduled_at.strftime('%I:%M %p'),\n      provider_name: @provider.full_name,\n      provider_title: @provider.title,\n      clinic_name: @provider.clinic.name,\n      clinic_address: @provider.clinic.address,\n      clinic_phone: format_phone(@provider.clinic.phone),\n      appointment_type: appointment.appointment_type.name,\n      preparation_instructions: appointment.preparation_instructions,\n      insurance_reminder: insurance_verification_needed?(appointment)\n    }\n  end\n\n  def test_results_params(test_result)\n    {\n      patient_first_name: @patient.first_name,\n      test_name: test_result.test_type.name,\n      test_date: test_result.collected_at.strftime('%B %d, %Y'),\n      ordering_provider: test_result.ordering_provider.full_name,\n      results_summary: sanitize_phi(test_result.summary),\n      next_steps: test_result.recommendations,\n      followup_needed: test_result.requires_followup?,\n      portal_url: \"#{ENV['PATIENT_PORTAL_URL']}/results/#{test_result.secure_id}\"\n    }\n  end\n\n  def validate_hipaa_compliance!\n    raise 'HIPAA compliance not configured' unless Rails.application.config.hipaa_enabled\n    raise 'Encryption not available' unless encryption_available?\n    raise 'Audit logging disabled' unless audit_logging_enabled?\n  end\nend\n</code></pre>"},{"location":"examples/real-world/#healthcare-prompt-templates","title":"Healthcare Prompt Templates","text":"<pre><code># prompts/healthcare/appointments/reminder.txt\nDear [PATIENT_FIRST_NAME],\n\nThis is a friendly reminder about your upcoming appointment:\n\n**Appointment Details:**\n\ud83d\udcc5 Date: [APPOINTMENT_DATE]  \n\ud83d\udd50 Time: [APPOINTMENT_TIME]\n\ud83d\udc69\u200d\u2695\ufe0f Provider: [PROVIDER_NAME], [PROVIDER_TITLE]\n\ud83c\udfe5 Location: [CLINIC_NAME]\n\ud83d\udccd Address: [CLINIC_ADDRESS]\n\ud83d\udcde Phone: [CLINIC_PHONE]\n\n**Appointment Type:** [APPOINTMENT_TYPE]\n\n&lt;% if ![PREPARATION_INSTRUCTIONS].empty? %&gt;\n**Important Preparation Instructions:**\n[PREPARATION_INSTRUCTIONS]\n&lt;% end %&gt;\n\n&lt;% if [INSURANCE_REMINDER] %&gt;\n**Insurance Reminder:** \nPlease bring your current insurance card and a valid photo ID.\n&lt;% end %&gt;\n\n**Need to reschedule?** \nPlease call us at [CLINIC_PHONE] at least 24 hours in advance.\n\n**Running late?**\nPlease call to let us know - we'll do our best to accommodate you.\n\nThank you for choosing [CLINIC_NAME] for your healthcare needs.\n\n---\nThis message contains confidential medical information intended only for [PATIENT_FIRST_NAME]. If you received this in error, please contact [CLINIC_PHONE] immediately.\n\n# prompts/healthcare/results/lab_results.txt  \nDear [PATIENT_FIRST_NAME],\n\nYour recent lab results from [TEST_DATE] are now available.\n\n**Test:** [TEST_NAME]\n**Ordered by:** [ORDERING_PROVIDER]\n\n**Results Summary:**\n[RESULTS_SUMMARY]\n\n&lt;% if [NEXT_STEPS] %&gt;\n**Recommended Next Steps:**\n[NEXT_STEPS]\n&lt;% end %&gt;\n\n&lt;% if [FOLLOWUP_NEEDED] %&gt;\n**\u26a0\ufe0f Follow-up Required**\nPlease schedule a follow-up appointment to discuss these results in detail.\nCall [CLINIC_PHONE] or use our patient portal.\n&lt;% else %&gt;\n**\u2705 No Follow-up Needed**\nThese results are within normal ranges. Continue your current care plan.\n&lt;% end %&gt;\n\n**View Complete Results:**\nLog into your patient portal for detailed results and reference ranges:\n[PORTAL_URL]\n\n**Questions about your results?**\nContact your care team at [CLINIC_PHONE] or send a secure message through the patient portal.\n\nBest regards,\n[ORDERING_PROVIDER] and Care Team\n\n---\nCONFIDENTIAL: This message contains protected health information. Do not forward or share.\n</code></pre> <p>These real-world examples demonstrate how PromptManager can be used to build sophisticated, production-ready communication systems across different industries while maintaining security, compliance, and scalability requirements.</p>"},{"location":"getting-started/basic-concepts/","title":"Basic Concepts","text":"<p>Understanding these core concepts will help you make the most of PromptManager.</p>"},{"location":"getting-started/basic-concepts/#the-prompt-lifecycle","title":"The Prompt Lifecycle","text":"<p>Every prompt in PromptManager follows a predictable lifecycle:</p> <pre><code>graph TD\n    A[Create/Load Prompt] --&gt; B[Parse Keywords]\n    B --&gt; C[Set Parameters]\n    C --&gt; D[Process Directives]\n    D --&gt; E[Apply ERB Templates]\n    E --&gt; F[Substitute Variables]\n    F --&gt; G[Generate Final Text]\n    G --&gt; H[Save Changes]</code></pre>"},{"location":"getting-started/basic-concepts/#core-components","title":"Core Components","text":""},{"location":"getting-started/basic-concepts/#1-prompts","title":"1. Prompts","text":"<p>A Prompt is the central entity in PromptManager. It represents a template with:</p> <ul> <li>Text content with embedded keywords</li> <li>Parameters (values for keywords)</li> <li>Metadata (directives, comments, configuration)</li> </ul> <pre><code>prompt = PromptManager::Prompt.new(\n  id: 'example',           # Unique identifier\n  erb_flag: true,          # Enable ERB processing\n  envar_flag: true         # Enable environment variables\n)\n</code></pre>"},{"location":"getting-started/basic-concepts/#2-keywords","title":"2. Keywords","text":"<p>Keywords are placeholders in your prompt text that get replaced with actual values:</p> <pre><code>Hello [NAME], today is [DATE] and the weather is [WEATHER].\n</code></pre> <p>Default keyword format: <code>[UPPERCASE_WITH_UNDERSCORES]</code></p> <p>You can customize this pattern:</p> <pre><code># Use {{mustache}} style\nPromptManager::Prompt.parameter_regex = /(\\{\\{[a-z_]+\\}\\})/\n\n# Use :symbol style  \nPromptManager::Prompt.parameter_regex = /(:[a-z_]+)/\n</code></pre>"},{"location":"getting-started/basic-concepts/#3-parameters","title":"3. Parameters","text":"<p>Parameters are the actual values that replace keywords:</p> <pre><code>prompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[DATE]\" =&gt; Date.today.to_s,\n  \"[WEATHER]\" =&gt; \"sunny\"\n}\n</code></pre> <p>Since v0.3.0, parameters store history as arrays:</p> <pre><code>prompt.parameters = {\n  \"[NAME]\" =&gt; [\"Alice\", \"Bob\", \"Charlie\"]  # Charlie is most recent\n}\n</code></pre>"},{"location":"getting-started/basic-concepts/#4-storage-adapters","title":"4. Storage Adapters","text":"<p>Storage Adapters handle how prompts are persisted:</p> FileSystemActiveRecord <pre><code>PromptManager::Storage::FileSystemAdapter.config do |config|\n  config.prompts_dir = '~/.prompts'\n  config.prompt_extension = '.txt'\n  config.params_extension = '.json'\nend\n</code></pre> <pre><code>PromptManager::Storage::ActiveRecordAdapter.config do |config|\n  config.model = PromptModel\n  config.id_column = :name\n  config.text_column = :content\n  config.parameters_column = :params\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#5-directives","title":"5. Directives","text":"<p>Directives are special instructions that start with <code>//</code>:</p> <pre><code>//include common/header.txt\n//import templates/[TEMPLATE_TYPE].txt\n\nYour main prompt content here...\n</code></pre>"},{"location":"getting-started/basic-concepts/#file-structure-filesystem-adapter","title":"File Structure (FileSystem Adapter)","text":"<p>When using the FileSystem adapter, your prompts are organized like this:</p> <pre><code>~/.prompts/\n\u251c\u2500\u2500 greeting.txt              # Prompt text\n\u251c\u2500\u2500 greeting.json             # Parameters\n\u251c\u2500\u2500 translation.txt\n\u251c\u2500\u2500 translation.json\n\u2514\u2500\u2500 common/\n    \u251c\u2500\u2500 header.txt            # Shared components\n    \u2514\u2500\u2500 footer.txt\n</code></pre>"},{"location":"getting-started/basic-concepts/#prompt-files-txt","title":"Prompt Files (<code>.txt</code>)","text":"greeting.txt<pre><code># Description: Friendly greeting prompt\n# Tags: customer-service, greeting\n# Version: 1.2\n\n//include common/header.txt\n\nHello [CUSTOMER_NAME]!\n\nThank you for contacting [COMPANY_NAME]. I'm here to help you with \n[REQUEST_TYPE]. Let me know how I can assist you today.\n\nBest regards,\n[AGENT_NAME]\n\n__END__\nInternal notes: This prompt is used for all initial customer contacts.\nUpdate the company name parameter when client changes.\n</code></pre>"},{"location":"getting-started/basic-concepts/#parameter-files-json","title":"Parameter Files (<code>.json</code>)","text":"greeting.json<pre><code>{\n  \"[CUSTOMER_NAME]\": [\"Alice Johnson\", \"Bob Smith\"],\n  \"[COMPANY_NAME]\": [\"Acme Corp\"],\n  \"[REQUEST_TYPE]\": [\"general inquiry\", \"technical support\", \"billing\"],\n  \"[AGENT_NAME]\": [\"Sarah\", \"Mike\", \"Jennifer\"]\n}\n</code></pre>"},{"location":"getting-started/basic-concepts/#processing-pipeline","title":"Processing Pipeline","text":"<p>PromptManager processes prompts through several stages:</p>"},{"location":"getting-started/basic-concepts/#1-text-loading","title":"1. Text Loading","text":"<ul> <li>Load raw prompt text from storage</li> <li>Parse out comments and <code>__END__</code> sections</li> </ul>"},{"location":"getting-started/basic-concepts/#2-keyword-extraction","title":"2. Keyword Extraction","text":"<ul> <li>Scan text for keyword patterns</li> <li>Build list of required parameters</li> </ul>"},{"location":"getting-started/basic-concepts/#3-directive-processing","title":"3. Directive Processing","text":"<ul> <li>Process <code>//include</code> and <code>//import</code> directives</li> <li>Handle loop protection for circular includes</li> <li>Substitute keywords in directive paths</li> </ul>"},{"location":"getting-started/basic-concepts/#4-template-processing","title":"4. Template Processing","text":"<ul> <li>Apply ERB templates if <code>erb_flag</code> is true</li> <li>Substitute environment variables if <code>envar_flag</code> is true</li> </ul>"},{"location":"getting-started/basic-concepts/#5-parameter-substitution","title":"5. Parameter Substitution","text":"<ul> <li>Replace keywords with parameter values</li> <li>Handle missing parameters (error or warning)</li> </ul>"},{"location":"getting-started/basic-concepts/#6-final-assembly","title":"6. Final Assembly","text":"<ul> <li>Combine processed components</li> <li>Return final prompt text</li> </ul>"},{"location":"getting-started/basic-concepts/#error-handling","title":"Error Handling","text":"<p>PromptManager provides specific error types:</p> <pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'example')\n  puts prompt.to_s\nrescue PromptManager::StorageError =&gt; e\n  puts \"Storage problem: #{e.message}\"\nrescue PromptManager::ParameterError =&gt; e  \n  puts \"Parameter issue: #{e.message}\"\nrescue PromptManager::ConfigurationError =&gt; e\n  puts \"Config problem: #{e.message}\"\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#common-error-scenarios","title":"Common Error Scenarios","text":"Error Type Common Cause Solution <code>StorageError</code> File not found, permission denied Check file paths and permissions <code>ParameterError</code> Missing parameter value Set all required parameters <code>ConfigurationError</code> Invalid adapter config Review adapter configuration"},{"location":"getting-started/basic-concepts/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/basic-concepts/#1-organize-your-prompts","title":"1. Organize Your Prompts","text":"<pre><code>prompts/\n\u251c\u2500\u2500 common/              # Shared components\n\u2502   \u251c\u2500\u2500 headers/\n\u2502   \u251c\u2500\u2500 footers/\n\u2502   \u2514\u2500\u2500 signatures/\n\u251c\u2500\u2500 customer-service/    # Domain-specific prompts\n\u251c\u2500\u2500 technical/\n\u2514\u2500\u2500 templates/           # Reusable templates\n</code></pre>"},{"location":"getting-started/basic-concepts/#2-use-meaningful-keywords","title":"2. Use Meaningful Keywords","text":"<pre><code># Good - descriptive and clear\n[CUSTOMER_NAME], [ORDER_NUMBER], [DELIVERY_DATE]\n\n# Avoid - unclear abbreviations  \n[CN], [ON], [DD]\n</code></pre>"},{"location":"getting-started/basic-concepts/#3-document-your-prompts","title":"3. Document Your Prompts","text":"<pre><code># Description: What this prompt does\n# Tags: classification, tags\n# Version: 1.0\n# Author: Your Name\n# Last Updated: 2024-01-15\n\n//include common/disclaimer.txt\n\nYour prompt content...\n\n__END__\nInternal notes, change history, and documentation go here.\nThis section is ignored by the processor.\n</code></pre>"},{"location":"getting-started/basic-concepts/#4-version-your-parameters","title":"4. Version Your Parameters","text":"<pre><code>{\n  \"_meta\": {\n    \"version\": \"1.0\",\n    \"updated\": \"2024-01-15\",\n    \"notes\": \"Added new product categories\"\n  },\n  \"[CATEGORY]\": [\"electronics\", \"books\", \"clothing\"]\n}\n</code></pre>"},{"location":"getting-started/basic-concepts/#advanced-concepts","title":"Advanced Concepts","text":""},{"location":"getting-started/basic-concepts/#parameter-validation","title":"Parameter Validation","text":"<pre><code># Custom validation in your application\ndef validate_parameters(prompt)\n  required = prompt.keywords\n  provided = prompt.parameters.keys\n  missing = required - provided\n\n  raise \"Missing parameters: #{missing.join(', ')}\" unless missing.empty?\nend\n</code></pre>"},{"location":"getting-started/basic-concepts/#dynamic-prompts","title":"Dynamic Prompts","text":"<pre><code># Template selection based on parameters\n//include templates/[TEMPLATE_TYPE].txt\n\n# Conditional content using ERB\n&lt;% if '[URGENCY]' == 'high' %&gt;\n\ud83d\udea8 URGENT: Immediate attention required\n&lt;% end %&gt;\n</code></pre>"},{"location":"getting-started/basic-concepts/#search-integration","title":"Search Integration","text":"<pre><code># Configure custom search\nadapter.search_proc = -&gt;(query) {\n  # Use ripgrep for fast search\n  `rg -l \"#{query}\" #{prompts_dir}`.split(\"\\n\").map { |f| \n    File.basename(f, '.txt') \n  }\n}\n</code></pre>"},{"location":"getting-started/basic-concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ol> <li>Try the examples in Core Features</li> <li>Choose a storage adapter in Storage Adapters </li> <li>Explore advanced features in Advanced Usage</li> <li>See real applications in Examples</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<p>PromptManager requires:</p> <ul> <li>Ruby: 2.7 or higher (3.0+ recommended)</li> <li>Operating System: Linux, macOS, or Windows</li> <li>Dependencies: No additional system dependencies required</li> </ul>"},{"location":"getting-started/installation/#install-the-gem","title":"Install the Gem","text":""},{"location":"getting-started/installation/#using-bundler-recommended","title":"Using Bundler (Recommended)","text":"<p>Add PromptManager to your project's <code>Gemfile</code>:</p> <pre><code># Gemfile\ngem 'prompt_manager'\n</code></pre> <p>Then install:</p> <pre><code>bundle install\n</code></pre>"},{"location":"getting-started/installation/#using-rubygems","title":"Using RubyGems","text":"<p>Install directly with gem:</p> <pre><code>gem install prompt_manager\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/MadBomber/prompt_manager.git\ncd prompt_manager\nbundle install\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test that PromptManager is installed correctly:</p> <pre><code>require 'prompt_manager'\nputs PromptManager::VERSION\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>PromptManager has minimal dependencies and automatically installs:</p> <ul> <li>No external system dependencies</li> <li>Pure Ruby dependencies only</li> <li>Lightweight footprint for easy integration</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Ruby Version</p> <p>If you see compatibility errors, ensure you're running Ruby 2.7+:</p> <pre><code>ruby --version\n</code></pre> <p>Bundler Issues</p> <p>If bundle install fails, try updating bundler:</p> <pre><code>gem update bundler\nbundle install\n</code></pre>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter installation issues:</p> <ol> <li>Check the GitHub Issues</li> <li>Search for similar problems in Discussions </li> <li>Create a new issue with:</li> <li>Ruby version (<code>ruby --version</code>)</li> <li>Gem version (<code>gem list prompt_manager</code>)</li> <li>Error message and full stack trace</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, continue to the Quick Start guide to begin using PromptManager.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will get you up and running with PromptManager in just a few minutes.</p>"},{"location":"getting-started/quick-start/#1-install-promptmanager","title":"1. Install PromptManager","text":"<pre><code>gem install prompt_manager\n</code></pre>"},{"location":"getting-started/quick-start/#2-set-up-your-first-prompt","title":"2. Set Up Your First Prompt","text":"<p>Create a directory for your prompts and your first prompt file:</p> <pre><code>mkdir ~/.prompts\n</code></pre> <p>Create your first prompt file:</p> ~/.prompts/greeting.txt~/.prompts/greeting.json <pre><code># Description: A friendly greeting prompt\n# Keywords: NAME, LANGUAGE\n\nHello [NAME]! \n\nI'm here to help you today. Please let me know how I can assist you,\nand I'll respond in [LANGUAGE].\n\nWhat would you like to know about?\n</code></pre> <pre><code>{\n  \"[NAME]\": [\"Alice\", \"Bob\", \"Charlie\"],\n  \"[LANGUAGE]\": [\"English\", \"Spanish\", \"French\"]\n}\n</code></pre>"},{"location":"getting-started/quick-start/#3-basic-usage","title":"3. Basic Usage","text":"<p>Create a simple Ruby script to use your prompt:</p> quick_example.rb<pre><code>#!/usr/bin/env ruby\n\nrequire 'prompt_manager'\n\n# Configure the FileSystem storage adapter\nPromptManager::Prompt.storage_adapter = \n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = File.expand_path('~/.prompts')\n  end.new\n\n# Load your prompt\nprompt = PromptManager::Prompt.new(id: 'greeting')\n\n# Set parameter values\nprompt.parameters = {\n  \"[NAME]\" =&gt; \"Alice\",\n  \"[LANGUAGE]\" =&gt; \"English\"\n}\n\n# Generate the final prompt text\nputs \"=== Generated Prompt ===\"\nputs prompt.to_s\n\n# Save any parameter changes\nprompt.save\n</code></pre> <p>Run it:</p> <pre><code>ruby quick_example.rb\n</code></pre> <p>Expected output: <pre><code>=== Generated Prompt ===\nHello Alice! \n\nI'm here to help you today. Please let me know how I can assist you,\nand I'll respond in English.\n\nWhat would you like to know about?\n</code></pre></p>"},{"location":"getting-started/quick-start/#4-understanding-the-workflow","title":"4. Understanding the Workflow","text":"<p>The basic PromptManager workflow involves:</p> <pre><code>graph LR\n    A[Create Prompt File] --&gt; B[Configure Storage]\n    B --&gt; C[Load Prompt]\n    C --&gt; D[Set Parameters]\n    D --&gt; E[Generate Text]\n    E --&gt; F[Save Changes]</code></pre>"},{"location":"getting-started/quick-start/#step-by-step","title":"Step by Step:","text":"<ol> <li>Create Prompt File: Write your template with <code>[KEYWORDS]</code></li> <li>Configure Storage: Choose FileSystem or ActiveRecord adapter</li> <li>Load Prompt: Create a Prompt instance with an ID</li> <li>Set Parameters: Provide values for your keywords</li> <li>Generate Text: Call <code>to_s</code> to get the final prompt</li> <li>Save Changes: Persist parameter updates</li> </ol>"},{"location":"getting-started/quick-start/#5-advanced-quick-start","title":"5. Advanced Quick Start","text":"<p>Here's a more advanced example showing multiple features:</p> advanced_example.rb<pre><code>require 'prompt_manager'\n\n# Configure storage\nPromptManager::Prompt.storage_adapter = \n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = File.expand_path('~/.prompts')\n  end.new\n\n# Create a prompt with directives and ERB\nprompt = PromptManager::Prompt.new(\n  id: 'advanced_greeting',\n  erb_flag: true,\n  envar_flag: true\n)\n\n# Set parameters\nprompt.parameters = {\n  \"[USER_NAME]\" =&gt; \"Alice\",\n  \"[TASK_TYPE]\" =&gt; \"translation\",\n  \"[URGENCY]\" =&gt; \"high\"\n}\n\n# Display available keywords\nputs \"Available keywords: #{prompt.keywords.join(', ')}\"\n\n# Generate and display the result\nputs \"\\n=== Final Prompt ===\"\nputs prompt.to_s\n\n# Save changes\nprompt.save\nputs \"\\nPrompt saved successfully!\"\n</code></pre> ~/.prompts/advanced_greeting.txt <pre><code># Advanced greeting with directives and ERB\n//include common/header.txt\n\nDear [USER_NAME],\n\n&lt;% if '[URGENCY]' == 'high' %&gt;\n\ud83d\udea8 URGENT: This [TASK_TYPE] request requires immediate attention.\n&lt;% else %&gt;\n\ud83d\udccb Standard [TASK_TYPE] request for processing.\n&lt;% end %&gt;\n\nCurrent system time: &lt;%= Time.now.strftime('%Y-%m-%d %H:%M:%S') %&gt;\nWorking directory: &lt;%= Dir.pwd %&gt;\n\n__END__\nThis section is ignored - useful for notes and documentation.\n</code></pre>"},{"location":"getting-started/quick-start/#6-next-steps","title":"6. Next Steps","text":"<p>Now that you have PromptManager working, explore these areas:</p>"},{"location":"getting-started/quick-start/#learn-core-features","title":"Learn Core Features","text":"<ul> <li>Parameterized Prompts - Master keyword substitution</li> <li>Directive Processing - Include files and process commands</li> <li>ERB Integration - Dynamic templating</li> </ul>"},{"location":"getting-started/quick-start/#storage-options","title":"Storage Options","text":"<ul> <li>FileSystem Adapter - File-based storage</li> <li>ActiveRecord Adapter - Database storage</li> <li>Custom Adapters - Build your own</li> </ul>"},{"location":"getting-started/quick-start/#advanced-usage","title":"Advanced Usage","text":"<ul> <li>Custom Keywords - Define your own keyword patterns</li> <li>Search Integration - Find prompts quickly</li> <li>Performance Tips - Optimize for large collections</li> </ul>"},{"location":"getting-started/quick-start/#real-examples","title":"Real Examples","text":"<ul> <li>Basic Examples - Simple use cases</li> <li>Advanced Examples - Complex scenarios</li> <li>Real World Cases - Production examples</li> </ul>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns you'll use frequently:</p>"},{"location":"getting-started/quick-start/#parameter-history","title":"Parameter History","text":"<pre><code># Access parameter history (since v0.3.0)\nprompt.parameters[\"[NAME]\"]  # Returns [\"Alice\", \"Bob\", \"Charlie\"] \nlatest_name = prompt.parameters[\"[NAME]\"].last  # \"Charlie\"\n</code></pre>"},{"location":"getting-started/quick-start/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'missing')\nrescue PromptManager::StorageError =&gt; e\n  puts \"Storage error: #{e.message}\"\nrescue PromptManager::ParameterError =&gt; e\n  puts \"Parameter error: #{e.message}\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#search-and-discovery","title":"Search and Discovery","text":"<pre><code># List all available prompts\nprompts = PromptManager::Prompt.list\nputs \"Available prompts: #{prompts.join(', ')}\"\n\n# Search for prompts (requires search_proc configuration)\nresults = PromptManager::Prompt.search('greeting')\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#file-not-found","title":"File Not Found","text":"<p>If you get \"file not found\" errors, check:</p> <ol> <li>Prompt directory exists: <code>ls ~/.prompts</code></li> <li>File has correct extension: Should be <code>.txt</code> by default</li> <li>Prompt ID matches filename: <code>greeting</code> looks for <code>greeting.txt</code></li> </ol>"},{"location":"getting-started/quick-start/#parameter-errors","title":"Parameter Errors","text":"<p>If parameters aren't substituting:</p> <ol> <li>Check keyword format: Must be <code>[UPPERCASE]</code> by default</li> <li>Verify parameter keys match: Case-sensitive matching</li> <li>Ensure parameters are set: Call <code>prompt.parameters = {...}</code></li> </ol>"},{"location":"getting-started/quick-start/#permission-issues","title":"Permission Issues","text":"<p>If you can't write to the prompts directory:</p> <pre><code>chmod 755 ~/.prompts\nchmod 644 ~/.prompts/*.txt\nchmod 644 ~/.prompts/*.json\n</code></pre> <p>Need help? Check our testing guide or open an issue.</p>"},{"location":"migration/v0.9.0/","title":"Migration Guide: Version 0.9.0","text":"<p>This guide helps you migrate from PromptManager v0.8.x to v0.9.0.</p>"},{"location":"migration/v0.9.0/#overview","title":"Overview","text":"<p>Version 0.9.0 introduces several breaking changes to improve consistency, performance, and usability. The main changes include:</p> <ul> <li>Unified configuration system</li> <li>Improved storage adapter interface</li> <li>Enhanced error handling</li> <li>Streamlined directive processing</li> </ul>"},{"location":"migration/v0.9.0/#breaking-changes","title":"Breaking Changes","text":""},{"location":"migration/v0.9.0/#1-configuration-system-changes","title":"1. Configuration System Changes","text":""},{"location":"migration/v0.9.0/#old-configuration-v08x","title":"Old Configuration (v0.8.x)","text":"<pre><code>PromptManager.setup do |config|\n  config.prompts_directory = '/path/to/prompts'\n  config.enable_caching = true\n  config.cache_duration = 300\n  config.default_storage = :filesystem\nend\n</code></pre>"},{"location":"migration/v0.9.0/#new-configuration-v090","title":"New Configuration (v0.9.0)","text":"<pre><code>PromptManager.configure do |config|\n  config.storage = PromptManager::Storage::FileSystemAdapter.new(\n    prompts_dir: '/path/to/prompts'\n  )\n  config.cache_prompts = true\n  config.cache_ttl = 300\nend\n</code></pre>"},{"location":"migration/v0.9.0/#migration-steps","title":"Migration Steps","text":"<ol> <li>Replace <code>PromptManager.setup</code> with <code>PromptManager.configure</code></li> <li>Replace <code>config.prompts_directory</code> with explicit storage adapter configuration</li> <li>Update cache configuration keys:</li> <li><code>enable_caching</code> \u2192 <code>cache_prompts</code></li> <li><code>cache_duration</code> \u2192 <code>cache_ttl</code></li> </ol>"},{"location":"migration/v0.9.0/#2-storage-adapter-interface","title":"2. Storage Adapter Interface","text":""},{"location":"migration/v0.9.0/#old-interface-v08x","title":"Old Interface (v0.8.x)","text":"<pre><code>class CustomAdapter\n  def get_prompt(id)\n    # Old method name\n  end\n\n  def save_prompt(id, content)\n    # Old method name\n  end\n\n  def prompt_exists?(id)\n    # Old method name\n  end\nend\n</code></pre>"},{"location":"migration/v0.9.0/#new-interface-v090","title":"New Interface (v0.9.0)","text":"<pre><code>class CustomAdapter &lt; PromptManager::Storage::Base\n  def read(prompt_id)\n    # New method name and inheritance requirement\n  end\n\n  def write(prompt_id, content)\n    # New method name\n  end\n\n  def exist?(prompt_id)\n    # New method name\n  end\n\n  def delete(prompt_id)\n    # New required method\n  end\n\n  def list\n    # New required method\n  end\nend\n</code></pre>"},{"location":"migration/v0.9.0/#migration-steps_1","title":"Migration Steps","text":"<ol> <li>Make your adapter inherit from <code>PromptManager::Storage::Base</code></li> <li>Rename methods:</li> <li><code>get_prompt</code> \u2192 <code>read</code></li> <li><code>save_prompt</code> \u2192 <code>write</code></li> <li><code>prompt_exists?</code> \u2192 <code>exist?</code></li> <li>Implement new required methods: <code>delete</code> and <code>list</code></li> <li>Update method signatures to use <code>prompt_id</code> parameter name</li> </ol>"},{"location":"migration/v0.9.0/#3-error-class-changes","title":"3. Error Class Changes","text":""},{"location":"migration/v0.9.0/#old-error-classes-v08x","title":"Old Error Classes (v0.8.x)","text":"<pre><code>begin\n  prompt.render\nrescue PromptManager::PromptMissingError =&gt; e\n  # Handle missing prompt\nrescue PromptManager::ParameterMissingError =&gt; e\n  # Handle missing parameters\nend\n</code></pre>"},{"location":"migration/v0.9.0/#new-error-classes-v090","title":"New Error Classes (v0.9.0)","text":"<pre><code>begin\n  prompt.render\nrescue PromptManager::PromptNotFoundError =&gt; e\n  # Handle missing prompt\nrescue PromptManager::MissingParametersError =&gt; e\n  # Handle missing parameters\n  puts \"Missing: #{e.missing_parameters.join(', ')}\"\nend\n</code></pre>"},{"location":"migration/v0.9.0/#migration-steps_2","title":"Migration Steps","text":"<ol> <li>Update exception class names:</li> <li><code>PromptMissingError</code> \u2192 <code>PromptNotFoundError</code></li> <li><code>ParameterMissingError</code> \u2192 <code>MissingParametersError</code></li> <li>Use the new <code>missing_parameters</code> method for detailed parameter information</li> </ol>"},{"location":"migration/v0.9.0/#4-prompt-initialization","title":"4. Prompt Initialization","text":""},{"location":"migration/v0.9.0/#old-initialization-v08x","title":"Old Initialization (v0.8.x)","text":"<pre><code>prompt = PromptManager::Prompt.new('prompt_id')\nprompt.storage_adapter = custom_adapter\n</code></pre>"},{"location":"migration/v0.9.0/#new-initialization-v090","title":"New Initialization (v0.9.0)","text":"<pre><code>prompt = PromptManager::Prompt.new(\n  id: 'prompt_id',\n  storage: custom_adapter\n)\n</code></pre>"},{"location":"migration/v0.9.0/#migration-steps_3","title":"Migration Steps","text":"<ol> <li>Use keyword arguments in <code>Prompt.new</code></li> <li>Pass storage adapter during initialization instead of setting it afterward</li> </ol>"},{"location":"migration/v0.9.0/#feature-updates","title":"Feature Updates","text":""},{"location":"migration/v0.9.0/#1-enhanced-parameter-support","title":"1. Enhanced Parameter Support","text":""},{"location":"migration/v0.9.0/#new-features","title":"New Features","text":"<ul> <li>Nested parameter access: <code>[USER.NAME]</code>, <code>[ORDER.ITEMS.0.NAME]</code></li> <li>Array parameter formatting</li> <li>Better error messages for missing parameters</li> </ul>"},{"location":"migration/v0.9.0/#migration-recommendation","title":"Migration Recommendation","text":"<p>Review your prompts for any parameter names that might conflict with the new nested syntax.</p>"},{"location":"migration/v0.9.0/#2-improved-directive-processing","title":"2. Improved Directive Processing","text":""},{"location":"migration/v0.9.0/#changes","title":"Changes","text":"<ul> <li>More robust <code>//include</code> processing</li> <li>Better error handling for circular includes</li> <li>New directive registration system</li> </ul>"},{"location":"migration/v0.9.0/#migration-steps_4","title":"Migration Steps","text":"<p>No changes required for basic <code>//include</code> usage. Custom directive implementations may need updates.</p>"},{"location":"migration/v0.9.0/#3-enhanced-caching","title":"3. Enhanced Caching","text":""},{"location":"migration/v0.9.0/#new-caching-options","title":"New Caching Options","text":"<pre><code>PromptManager.configure do |config|\n  config.cache_prompts = true\n  config.cache_ttl = 3600\n  config.cache_store = ActiveSupport::Cache::RedisStore.new(\n    url: ENV['REDIS_URL']\n  )\nend\n</code></pre>"},{"location":"migration/v0.9.0/#database-schema-changes-activerecord-adapter","title":"Database Schema Changes (ActiveRecord Adapter)","text":""},{"location":"migration/v0.9.0/#schema-updates-required","title":"Schema Updates Required","text":"<p>If you're using the ActiveRecord adapter, run this migration:</p> <pre><code>class UpdatePromptsForPromptManagerV09 &lt; ActiveRecord::Migration[7.0]\n  def change\n    # Add new columns\n    add_column :prompts, :metadata, :json, default: {}\n    add_column :prompts, :version, :integer, default: 1\n    add_column :prompts, :created_by, :string\n    add_column :prompts, :updated_by, :string\n\n    # Add indexes for better performance\n    add_index :prompts, :metadata, using: :gin\n    add_index :prompts, :version\n    add_index :prompts, :updated_at\n\n    # Update existing records\n    execute &lt;&lt;-SQL\n      UPDATE prompts \n      SET metadata = '{}', version = 1 \n      WHERE metadata IS NULL OR version IS NULL\n    SQL\n  end\n\n  def down\n    remove_column :prompts, :metadata\n    remove_column :prompts, :version  \n    remove_column :prompts, :created_by\n    remove_column :prompts, :updated_by\n  end\nend\n</code></pre>"},{"location":"migration/v0.9.0/#step-by-step-migration-process","title":"Step-by-Step Migration Process","text":""},{"location":"migration/v0.9.0/#1-update-dependencies","title":"1. Update Dependencies","text":"<pre><code># Gemfile\ngem 'prompt_manager', '~&gt; 0.9.0'\n</code></pre> <p>Run <code>bundle update prompt_manager</code></p>"},{"location":"migration/v0.9.0/#2-update-configuration","title":"2. Update Configuration","text":"<pre><code># Before (v0.8.x)\nPromptManager.setup do |config|\n  config.prompts_directory = Rails.root.join('app', 'prompts')\n  config.enable_caching = true\n  config.cache_duration = 1800\nend\n\n# After (v0.9.0)\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::FileSystemAdapter.new(\n    prompts_dir: Rails.root.join('app', 'prompts')\n  )\n  config.cache_prompts = true\n  config.cache_ttl = 1800\nend\n</code></pre>"},{"location":"migration/v0.9.0/#3-update-custom-storage-adapters","title":"3. Update Custom Storage Adapters","text":"<pre><code># Before (v0.8.x)\nclass RedisAdapter\n  def get_prompt(id)\n    @redis.get(\"prompt:#{id}\")\n  end\n\n  def save_prompt(id, content)\n    @redis.set(\"prompt:#{id}\", content)\n  end\n\n  def prompt_exists?(id)\n    @redis.exists?(\"prompt:#{id}\")\n  end\nend\n\n# After (v0.9.0)  \nclass RedisAdapter &lt; PromptManager::Storage::Base\n  def read(prompt_id)\n    content = @redis.get(key_for(prompt_id))\n    raise PromptManager::PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\") unless content\n    content\n  end\n\n  def write(prompt_id, content)\n    @redis.set(key_for(prompt_id), content)\n    true\n  end\n\n  def exist?(prompt_id)\n    @redis.exists?(key_for(prompt_id)) &gt; 0\n  end\n\n  def delete(prompt_id)\n    @redis.del(key_for(prompt_id)) &gt; 0\n  end\n\n  def list\n    keys = @redis.keys(\"prompts:*\")\n    keys.map { |key| key.sub('prompts:', '') }\n  end\n\n  private\n\n  def key_for(prompt_id)\n    \"prompts:#{prompt_id}\"\n  end\nend\n</code></pre>"},{"location":"migration/v0.9.0/#4-update-error-handling","title":"4. Update Error Handling","text":"<pre><code># Before (v0.8.x)\nbegin\n  result = prompt.render(params)\nrescue PromptManager::PromptMissingError\n  render json: { error: 'Prompt not found' }, status: 404\nrescue PromptManager::ParameterMissingError =&gt; e\n  render json: { error: 'Missing parameters' }, status: 400\nend\n\n# After (v0.9.0)\nbegin\n  result = prompt.render(params)\nrescue PromptManager::PromptNotFoundError\n  render json: { error: 'Prompt not found' }, status: 404\nrescue PromptManager::MissingParametersError =&gt; e\n  render json: { \n    error: 'Missing parameters',\n    missing: e.missing_parameters \n  }, status: 400\nend\n</code></pre>"},{"location":"migration/v0.9.0/#5-update-prompt-creation","title":"5. Update Prompt Creation","text":"<pre><code># Before (v0.8.x)\nprompt = PromptManager::Prompt.new('welcome_email')\nprompt.enable_erb = true\n\n# After (v0.9.0)\nprompt = PromptManager::Prompt.new(\n  id: 'welcome_email',\n  erb_flag: true\n)\n</code></pre>"},{"location":"migration/v0.9.0/#6-run-database-migrations-if-using-activerecord","title":"6. Run Database Migrations (if using ActiveRecord)","text":"<pre><code>rails generate migration UpdatePromptsForPromptManagerV09\n# Edit the migration file with the schema changes shown above\nrails db:migrate\n</code></pre>"},{"location":"migration/v0.9.0/#7-update-tests","title":"7. Update Tests","text":"<pre><code># Update test setup\nRSpec.configure do |config|\n  config.before(:each) do\n    # Clear configuration between tests\n    PromptManager.reset_configuration!\n\n    # Setup test configuration\n    PromptManager.configure do |config|\n      config.storage = PromptManager::Storage::FileSystemAdapter.new(\n        prompts_dir: 'spec/fixtures/prompts'\n      )\n    end\n  end\nend\n</code></pre>"},{"location":"migration/v0.9.0/#validation-testing","title":"Validation &amp; Testing","text":""},{"location":"migration/v0.9.0/#1-configuration-validation","title":"1. Configuration Validation","text":"<p>Add this to verify your configuration:</p> <pre><code># In your application's initialization\nbegin\n  PromptManager.validate_configuration!\n  puts \"\u2705 PromptManager configuration is valid\"\nrescue PromptManager::ConfigurationError =&gt; e\n  puts \"\u274c Configuration error: #{e.message}\"\n  exit 1\nend\n</code></pre>"},{"location":"migration/v0.9.0/#2-migration-test-script","title":"2. Migration Test Script","text":"<p>Create a test script to validate the migration:</p> <pre><code>#!/usr/bin/env ruby\n\nrequire 'prompt_manager'\n\n# Test basic functionality\nbegin\n  PromptManager.configure do |config|\n    config.storage = PromptManager::Storage::FileSystemAdapter.new(\n      prompts_dir: 'test_prompts'\n    )\n  end\n\n  # Create test prompt\n  prompt = PromptManager::Prompt.new(id: 'test')\n  prompt.write('Hello [NAME]!')\n\n  # Test rendering\n  result = prompt.render(name: 'World')\n\n  if result == 'Hello World!'\n    puts \"\u2705 Migration successful - basic functionality works\"\n  else\n    puts \"\u274c Migration failed - unexpected result: #{result}\"\n  end\n\n  # Cleanup\n  prompt.delete\n\nrescue =&gt; e\n  puts \"\u274c Migration failed with error: #{e.message}\"\n  puts e.backtrace\nend\n</code></pre>"},{"location":"migration/v0.9.0/#rollback-plan","title":"Rollback Plan","text":"<p>If you need to rollback to v0.8.x:</p> <ol> <li>Update Gemfile: <code>gem 'prompt_manager', '~&gt; 0.8.0'</code></li> <li>Run: <code>bundle install</code></li> <li>Revert configuration changes to the old format</li> <li>Revert database migrations (if using ActiveRecord):    <pre><code>rails db:rollback STEP=1\n</code></pre></li> </ol>"},{"location":"migration/v0.9.0/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check the updated documentation at https://madbomber.github.io/prompt_manager</li> <li>GitHub Issues: Report migration issues at https://github.com/MadBomber/prompt_manager/issues</li> <li>Discussions: Ask questions in GitHub Discussions</li> </ul>"},{"location":"migration/v0.9.0/#post-migration-checklist","title":"Post-Migration Checklist","text":"<ul> <li> Updated Gemfile and ran <code>bundle install</code></li> <li> Updated configuration format</li> <li> Updated custom storage adapters (if any)</li> <li> Updated error handling code</li> <li> Ran database migrations (if using ActiveRecord)</li> <li> Updated tests</li> <li> Validated configuration with test script</li> <li> Deployed to staging and tested thoroughly</li> <li> Updated documentation and team</li> </ul> <p>Need help? The migration should be straightforward for most applications. If you encounter issues, please open a GitHub issue with details about your setup and the specific problems you're experiencing.</p>"},{"location":"migration/v1.0.0/","title":"Migration Guide: Version 1.0.0","text":"<p>This guide helps you migrate from PromptManager v0.9.x to v1.0.0, which represents the first stable release with a commitment to semantic versioning.</p>"},{"location":"migration/v1.0.0/#overview","title":"Overview","text":"<p>Version 1.0.0 focuses on API stabilization, performance improvements, and enhanced developer experience. While there are some breaking changes, most applications should migrate smoothly.</p>"},{"location":"migration/v1.0.0/#major-changes","title":"Major Changes","text":""},{"location":"migration/v1.0.0/#1-stable-public-api","title":"1. Stable Public API","text":"<ul> <li>All public APIs are now considered stable</li> <li>Semantic versioning is strictly followed from this version forward</li> <li>Deprecation warnings will be provided for 6 months before removal</li> </ul>"},{"location":"migration/v1.0.0/#2-enhanced-storage-system","title":"2. Enhanced Storage System","text":"<ul> <li>New storage adapter capabilities</li> <li>Improved error handling and diagnostics</li> <li>Better performance for large prompt libraries</li> </ul>"},{"location":"migration/v1.0.0/#3-advanced-template-features","title":"3. Advanced Template Features","text":"<ul> <li>Template inheritance system</li> <li>Custom directive registration</li> <li>Improved ERB integration</li> </ul>"},{"location":"migration/v1.0.0/#breaking-changes","title":"Breaking Changes","text":""},{"location":"migration/v1.0.0/#1-removed-deprecated-methods","title":"1. Removed Deprecated Methods","text":""},{"location":"migration/v1.0.0/#methods-removed-in-v100","title":"Methods Removed in v1.0.0","text":"<pre><code># These methods were deprecated in v0.9.x and removed in v1.0.0\n\n# OLD (removed):\nprompt.enable_erb = true\nprompt.enable_envar = true\n\n# NEW (use during initialization):\nprompt = PromptManager::Prompt.new(\n  id: 'template',\n  erb_flag: true,\n  envar_flag: true\n)\n</code></pre>"},{"location":"migration/v1.0.0/#migration-steps","title":"Migration Steps","text":"<ol> <li>Remove usage of deprecated setter methods</li> <li>Pass flags during prompt initialization</li> </ol>"},{"location":"migration/v1.0.0/#2-storage-adapter-method-signatures","title":"2. Storage Adapter Method Signatures","text":""},{"location":"migration/v1.0.0/#updated-method-signatures","title":"Updated Method Signatures","text":"<pre><code># OLD (v0.9.x):\ndef read(prompt_id)\n  # Simple string return\nend\n\n# NEW (v1.0.0):\ndef read(prompt_id)\n  # Can return string or PromptData object\nend\n\n# NEW: Enhanced read method (optional)\ndef read_with_metadata(prompt_id)\n  {\n    content: \"prompt content\",\n    metadata: { author: \"user\", version: 1 },\n    last_modified: Time.current\n  }\nend\n</code></pre>"},{"location":"migration/v1.0.0/#migration-steps_1","title":"Migration Steps","text":"<ul> <li>No changes required for basic adapters</li> <li>Optionally implement <code>read_with_metadata</code> for enhanced functionality</li> </ul>"},{"location":"migration/v1.0.0/#3-configuration-changes","title":"3. Configuration Changes","text":""},{"location":"migration/v1.0.0/#updated-configuration-structure","title":"Updated Configuration Structure","text":"<pre><code># OLD (v0.9.x):\nPromptManager.configure do |config|\n  config.cache_prompts = true\n  config.cache_ttl = 300\nend\n\n# NEW (v1.0.0):\nPromptManager.configure do |config|\n  config.cache = {\n    enabled: true,\n    ttl: 300,\n    store: :memory,  # or :redis, :memcached\n    options: {}\n  }\nend\n</code></pre>"},{"location":"migration/v1.0.0/#migration-steps_2","title":"Migration Steps","text":"<ol> <li>Update cache configuration to use nested structure</li> <li>Specify cache store type explicitly</li> </ol>"},{"location":"migration/v1.0.0/#new-features","title":"New Features","text":""},{"location":"migration/v1.0.0/#1-template-inheritance","title":"1. Template Inheritance","text":"<p>Create reusable template hierarchies:</p> <pre><code># layouts/base.txt\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;//yield title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;//yield heading&lt;/h1&gt;\n  &lt;div class=\"content\"&gt;\n    //yield content\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n# email.txt\n//extends layouts/base\n//section title: Email Notification\n//section heading: Important Update\n//section content: Your account has been updated.\n</code></pre>"},{"location":"migration/v1.0.0/#2-custom-directive-system","title":"2. Custom Directive System","text":"<p>Register custom processing directives:</p> <pre><code>PromptManager.configure do |config|\n  config.register_directive('timestamp') do |format, context|\n    Time.current.strftime(format || '%Y-%m-%d %H:%M:%S')\n  end\n\n  config.register_directive('user_info') do |user_id, context|\n    user = User.find(user_id)\n    \"#{user.name} (#{user.email})\"\n  end\nend\n\n# Usage in prompts:\n# Generated at: //timestamp %B %d, %Y\n# User: //user_info [USER_ID]\n</code></pre>"},{"location":"migration/v1.0.0/#3-enhanced-error-information","title":"3. Enhanced Error Information","text":"<p>More detailed error messages and context:</p> <pre><code>begin\n  prompt.render(incomplete_params)\nrescue PromptManager::MissingParametersError =&gt; e\n  puts \"Missing parameters:\"\n  e.missing_parameters.each do |param|\n    puts \"  - #{param[:name]} (line #{param[:line]})\"\n  end\n\n  puts \"Suggestions:\"\n  e.suggestions.each { |suggestion| puts \"  - #{suggestion}\" }\nend\n</code></pre>"},{"location":"migration/v1.0.0/#4-performance-monitoring","title":"4. Performance Monitoring","text":"<p>Built-in performance tracking:</p> <pre><code>PromptManager.configure do |config|\n  config.performance_monitoring = {\n    enabled: true,\n    slow_threshold: 0.1,  # seconds\n    callback: -&gt;(metrics) {\n      Rails.logger.warn \"Slow prompt: #{metrics[:prompt_id]} (#{metrics[:duration]}s)\"\n    }\n  }\nend\n</code></pre>"},{"location":"migration/v1.0.0/#database-schema-updates-activerecord-adapter","title":"Database Schema Updates (ActiveRecord Adapter)","text":""},{"location":"migration/v1.0.0/#new-schema-for-enhanced-features","title":"New Schema for Enhanced Features","text":"<pre><code>class UpdatePromptsForV100 &lt; ActiveRecord::Migration[7.0]\n  def change\n    # Add versioning support\n    add_column :prompts, :version_number, :integer, default: 1\n    add_column :prompts, :parent_version, :integer\n\n    # Add template inheritance\n    add_column :prompts, :extends, :string\n    add_column :prompts, :template_type, :string, default: 'prompt'\n\n    # Add usage tracking\n    add_column :prompts, :usage_count, :integer, default: 0\n    add_column :prompts, :last_used_at, :timestamp\n\n    # Add performance tracking\n    add_column :prompts, :avg_render_time, :decimal, precision: 8, scale: 4\n    add_column :prompts, :last_render_time, :decimal, precision: 8, scale: 4\n\n    # Enhanced metadata\n    change_column :prompts, :metadata, :jsonb  # PostgreSQL\n    # For MySQL: change_column :prompts, :metadata, :json\n\n    # New indexes\n    add_index :prompts, :version_number\n    add_index :prompts, :template_type\n    add_index :prompts, :usage_count\n    add_index :prompts, :last_used_at\n    add_index :prompts, [:extends, :template_type]\n\n    # GIN index for metadata search (PostgreSQL)\n    add_index :prompts, :metadata, using: :gin\n  end\n\n  def down\n    remove_column :prompts, :version_number\n    remove_column :prompts, :parent_version\n    remove_column :prompts, :extends\n    remove_column :prompts, :template_type\n    remove_column :prompts, :usage_count\n    remove_column :prompts, :last_used_at\n    remove_column :prompts, :avg_render_time\n    remove_column :prompts, :last_render_time\n  end\nend\n</code></pre>"},{"location":"migration/v1.0.0/#configuration-migration","title":"Configuration Migration","text":""},{"location":"migration/v1.0.0/#full-configuration-example","title":"Full Configuration Example","text":"<pre><code># config/initializers/prompt_manager.rb (v1.0.0)\n\nPromptManager.configure do |config|\n  # Storage configuration\n  config.storage = if Rails.env.production?\n    PromptManager::Storage::ActiveRecordAdapter.new(\n      model_class: Prompt,\n      enable_versioning: true,\n      enable_usage_tracking: true\n    )\n  else\n    PromptManager::Storage::FileSystemAdapter.new(\n      prompts_dir: Rails.root.join('app', 'prompts'),\n      enable_hot_reload: Rails.env.development?\n    )\n  end\n\n  # Caching configuration\n  config.cache = {\n    enabled: Rails.env.production?,\n    ttl: 1.hour,\n    store: :redis,\n    options: {\n      url: ENV['REDIS_URL'],\n      namespace: 'prompt_manager',\n      compress: true\n    }\n  }\n\n  # Template processing\n  config.templates = {\n    inheritance_enabled: true,\n    max_inheritance_depth: 5,\n    custom_directives: true\n  }\n\n  # Performance monitoring\n  config.performance_monitoring = {\n    enabled: Rails.env.production?,\n    slow_threshold: 0.5,\n    callback: -&gt;(metrics) {\n      Rails.logger.info \"PromptManager: #{metrics[:prompt_id]} rendered in #{metrics[:duration]}s\"\n\n      if metrics[:duration] &gt; config.performance_monitoring[:slow_threshold]\n        SlackNotifier.notify(\"Slow prompt detected: #{metrics[:prompt_id]}\")\n      end\n    }\n  }\n\n  # Error handling\n  config.error_handling = {\n    raise_on_missing_prompts: Rails.env.development?,\n    raise_on_missing_parameters: Rails.env.development?,\n    fallback_handler: -&gt;(error, context) {\n      Rails.logger.error \"PromptManager error: #{error.message}\"\n      Rails.logger.error \"Context: #{context.inspect}\"\n\n      case error\n      when PromptManager::PromptNotFoundError\n        \"[Prompt temporarily unavailable]\"\n      when PromptManager::MissingParametersError\n        \"[Missing: #{error.missing_parameters.map(&amp;:name).join(', ')}]\"\n      else\n        \"[Content unavailable]\"\n      end\n    }\n  }\n\n  # Custom directives\n  config.register_directive('format_currency') do |amount, currency, context|\n    # Custom currency formatting logic\n    Money.new(amount.to_f * 100, currency).format\n  end\n\n  config.register_directive('user_avatar') do |user_id, size, context|\n    user = User.find(user_id)\n    user.avatar.variant(resize: \"#{size}x#{size}\").url\n  end\nend\n</code></pre>"},{"location":"migration/v1.0.0/#step-by-step-migration","title":"Step-by-Step Migration","text":""},{"location":"migration/v1.0.0/#1-update-dependencies","title":"1. Update Dependencies","text":"<pre><code># Gemfile\ngem 'prompt_manager', '~&gt; 1.0.0'\n\n# If using additional features:\ngem 'redis-rails'           # For Redis caching\ngem 'money-rails'          # For currency formatting example\n</code></pre>"},{"location":"migration/v1.0.0/#2-run-database-migration","title":"2. Run Database Migration","text":"<pre><code>rails generate migration UpdatePromptsForV100\n# Edit the migration with schema changes above\nrails db:migrate\n</code></pre>"},{"location":"migration/v1.0.0/#3-update-configuration","title":"3. Update Configuration","text":"<p>Replace your existing configuration with the new structure shown above.</p>"},{"location":"migration/v1.0.0/#4-update-custom-storage-adapters","title":"4. Update Custom Storage Adapters","text":"<pre><code>class CustomAdapter &lt; PromptManager::Storage::Base\n  # Add new optional methods for enhanced features\n\n  def read_with_metadata(prompt_id)\n    content = read(prompt_id)\n    {\n      content: content,\n      metadata: get_metadata(prompt_id),\n      last_modified: get_last_modified(prompt_id)\n    }\n  rescue PromptNotFoundError\n    raise\n  end\n\n  def track_usage(prompt_id, render_time)\n    # Optional: implement usage tracking\n  end\n\n  def get_versions(prompt_id)\n    # Optional: implement versioning\n    [{ version: 1, content: read(prompt_id), created_at: Time.current }]\n  end\nend\n</code></pre>"},{"location":"migration/v1.0.0/#5-update-application-code","title":"5. Update Application Code","text":"<pre><code># OLD (v0.9.x):\nclass EmailService\n  def send_welcome_email(user)\n    prompt = PromptManager::Prompt.new(id: 'welcome_email')\n    content = prompt.render(user: user)\n    # Send email\n  end\nend\n\n# NEW (v1.0.0) - with error handling:\nclass EmailService\n  def send_welcome_email(user)\n    begin\n      prompt = PromptManager::Prompt.new(id: 'welcome_email')\n      content = prompt.render(user: user)\n      EmailMailer.welcome(user, content).deliver_later\n    rescue PromptManager::PromptNotFoundError\n      Rails.logger.error \"Welcome email template not found\"\n      EmailMailer.fallback_welcome(user).deliver_later\n    rescue PromptManager::MissingParametersError =&gt; e\n      Rails.logger.error \"Missing email parameters: #{e.missing_parameters.join(', ')}\"\n      # Handle gracefully or re-raise\n    end\n  end\nend\n</code></pre>"},{"location":"migration/v1.0.0/#6-migrate-to-template-inheritance","title":"6. Migrate to Template Inheritance","text":"<p>Convert related prompts to use inheritance:</p> <pre><code># Before: Separate files with duplicated structure\n# welcome_email.txt, reset_password_email.txt, etc.\n\n# After: Base template + specific content\n# templates/email_base.txt\nSubject: [SUBJECT]\n\nDear [USER_NAME],\n\n[CONTENT]\n\nBest regards,\nThe [COMPANY_NAME] Team\n\n---\nThis email was sent to [USER_EMAIL].\nTo unsubscribe, visit [UNSUBSCRIBE_URL]\n\n# welcome_email.txt  \n//extends templates/email_base\n//section subject: Welcome to [COMPANY_NAME]!\n//section content: Thank you for joining us. We're excited to have you aboard!\n\n# reset_password_email.txt\n//extends templates/email_base\n//section subject: Password Reset Request\n//section content: Click here to reset your password: [RESET_URL]\n</code></pre>"},{"location":"migration/v1.0.0/#testing-migration","title":"Testing Migration","text":""},{"location":"migration/v1.0.0/#automated-migration-test","title":"Automated Migration Test","text":"<pre><code># test/migration_test.rb\nrequire 'test_helper'\n\nclass V100MigrationTest &lt; ActiveSupport::TestCase\n  def setup\n    # Setup test data\n  end\n\n  test \"basic prompt rendering still works\" do\n    prompt = PromptManager::Prompt.new(id: 'test_prompt')\n    result = prompt.render(name: 'Test')\n    assert_equal 'Hello Test!', result\n  end\n\n  test \"template inheritance works\" do\n    prompt = PromptManager::Prompt.new(id: 'inherited_prompt')\n    result = prompt.render(title: 'Test Page', content: 'Test content')\n    assert_includes result, 'Test Page'\n    assert_includes result, 'Test content'\n  end\n\n  test \"custom directives work\" do\n    prompt = PromptManager::Prompt.new(id: 'directive_prompt')\n    result = prompt.render\n    assert_match /\\d{4}-\\d{2}-\\d{2}/, result  # Should include timestamp\n  end\n\n  test \"error handling provides detailed information\" do\n    prompt = PromptManager::Prompt.new(id: 'param_prompt')\n\n    error = assert_raises(PromptManager::MissingParametersError) do\n      prompt.render  # Missing required parameters\n    end\n\n    assert error.missing_parameters.any?\n    assert error.suggestions.any?\n  end\nend\n</code></pre>"},{"location":"migration/v1.0.0/#performance-verification","title":"Performance Verification","text":"<pre><code># test/performance_test.rb\nrequire 'test_helper'\nrequire 'benchmark'\n\nclass V100PerformanceTest &lt; ActiveSupport::TestCase\n  test \"rendering performance is acceptable\" do\n    prompt = PromptManager::Prompt.new(id: 'complex_prompt')\n    params = { user: create_test_user, items: create_test_items(100) }\n\n    time = Benchmark.measure do\n      100.times { prompt.render(params) }\n    end\n\n    # Should render 100 complex prompts in under 1 second\n    assert time.real &lt; 1.0, \"Rendering too slow: #{time.real}s\"\n  end\nend\n</code></pre>"},{"location":"migration/v1.0.0/#rollback-procedures","title":"Rollback Procedures","text":""},{"location":"migration/v1.0.0/#quick-rollback","title":"Quick Rollback","text":"<pre><code># 1. Update Gemfile\ngem 'prompt_manager', '~&gt; 0.9.0'\n\n# 2. Bundle install\nbundle install\n\n# 3. Rollback database\nrails db:rollback STEP=1\n\n# 4. Restart application\n</code></pre>"},{"location":"migration/v1.0.0/#configuration-rollback","title":"Configuration Rollback","text":"<p>Keep a backup of your v0.9.x configuration:</p> <pre><code># config/initializers/prompt_manager_v09_backup.rb\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::FileSystemAdapter.new(\n    prompts_dir: Rails.root.join('app', 'prompts')\n  )\n  config.cache_prompts = true\n  config.cache_ttl = 1800\nend\n</code></pre>"},{"location":"migration/v1.0.0/#validation-checklist","title":"Validation Checklist","text":"<ul> <li> Dependencies Updated: Gemfile shows v1.0.0</li> <li> Database Migrated: New columns and indexes created</li> <li> Configuration Updated: New configuration structure in use</li> <li> Custom Adapters Updated: Enhanced methods implemented (if applicable)</li> <li> Template Inheritance: Converted applicable prompts to use inheritance</li> <li> Error Handling: Updated to use new error information</li> <li> Tests Updated: All tests pass with new version</li> <li> Performance Verified: Rendering performance is acceptable</li> <li> Documentation Updated: Internal documentation reflects v1.0.0 features</li> </ul>"},{"location":"migration/v1.0.0/#getting-support","title":"Getting Support","text":"<ul> <li>Documentation: https://madbomber.github.io/prompt_manager</li> <li>GitHub Issues: https://github.com/MadBomber/prompt_manager/issues</li> <li>Community Forum: https://github.com/MadBomber/prompt_manager/discussions</li> <li>Migration Support: Tag issues with <code>migration-v1.0.0</code></li> </ul>"},{"location":"migration/v1.0.0/#post-migration-optimization","title":"Post-Migration Optimization","text":""},{"location":"migration/v1.0.0/#1-enable-new-features-gradually","title":"1. Enable New Features Gradually","text":"<p>Start with basic v1.0.0 functionality, then gradually enable: - Template inheritance - Custom directives - Performance monitoring - Advanced caching</p>"},{"location":"migration/v1.0.0/#2-monitor-performance","title":"2. Monitor Performance","text":"<p>Use the new performance monitoring to identify optimization opportunities:</p> <pre><code># Check slow prompts\nPromptManager.slow_prompts(threshold: 0.1).each do |prompt_data|\n  puts \"#{prompt_data[:id]}: #{prompt_data[:avg_time]}s average\"\nend\n</code></pre>"},{"location":"migration/v1.0.0/#3-optimize-storage","title":"3. Optimize Storage","text":"<p>Consider upgrading storage adapters for better performance: - Use Redis adapter for high-frequency prompts - Enable database connection pooling - Implement read replicas for heavy read workloads</p> <p>Congratulations! You've successfully migrated to PromptManager v1.0.0. This stable release provides a solid foundation for scaling your prompt management needs.</p>"},{"location":"storage/activerecord-adapter/","title":"ActiveRecordAdapter","text":"<p>The ActiveRecordAdapter allows you to store prompts in a relational database using ActiveRecord, perfect for Rails applications and scenarios requiring database-backed prompt storage.</p>"},{"location":"storage/activerecord-adapter/#overview","title":"Overview","text":"<p>Store prompts in your application's database alongside other application data. This adapter provides full CRUD operations, query capabilities, and integration with ActiveRecord models.</p>"},{"location":"storage/activerecord-adapter/#setup","title":"Setup","text":""},{"location":"storage/activerecord-adapter/#migration","title":"Migration","text":"<p>Create the prompts table:</p> <pre><code># Generate migration\nrails generate migration CreatePrompts\n\n# In the migration file:\nclass CreatePrompts &lt; ActiveRecord::Migration[7.0]\n  def change\n    create_table :prompts do |t|\n      t.string :prompt_id, null: false, index: { unique: true }\n      t.text :content, null: false\n      t.text :description\n      t.json :metadata, default: {}\n      t.timestamps\n    end\n  end\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#model","title":"Model","text":"<pre><code># app/models/prompt.rb\nclass Prompt &lt; ApplicationRecord\n  validates :prompt_id, presence: true, uniqueness: true\n  validates :content, presence: true\n\n  # Optional: Add scopes for organization\n  scope :by_category, -&gt;(category) { where(\"metadata-&gt;&gt;'category' = ?\", category) }\n  scope :recent, -&gt; { order(updated_at: :desc) }\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#configuration","title":"Configuration","text":"<pre><code># Configure PromptManager to use ActiveRecord\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::ActiveRecordAdapter.new(\n    model_class: Prompt,\n    id_column: :prompt_id,\n    content_column: :content\n  )\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#basic-usage","title":"Basic Usage","text":""},{"location":"storage/activerecord-adapter/#creating-prompts","title":"Creating Prompts","text":"<pre><code># Create via PromptManager\nprompt = PromptManager::Prompt.new(id: 'welcome_email')\nprompt.save(\n  content: 'Welcome to our service, [USER_NAME]!',\n  metadata: {\n    category: 'email',\n    author: 'marketing_team',\n    version: '1.0'\n  }\n)\n\n# Or create via ActiveRecord\nPrompt.create!(\n  prompt_id: 'goodbye_email',\n  content: 'Thanks for using our service, [USER_NAME]!',\n  description: 'Farewell email template',\n  metadata: { category: 'email', priority: 'low' }\n)\n</code></pre>"},{"location":"storage/activerecord-adapter/#reading-prompts","title":"Reading Prompts","text":"<pre><code># Via PromptManager (recommended)\nprompt = PromptManager::Prompt.new(id: 'welcome_email')\nresult = prompt.render(user_name: 'Alice')\n\n# Via ActiveRecord\nprompt_record = Prompt.find_by(prompt_id: 'welcome_email')\nputs prompt_record.content\n</code></pre>"},{"location":"storage/activerecord-adapter/#updating-prompts","title":"Updating Prompts","text":"<pre><code># Via PromptManager\nprompt = PromptManager::Prompt.new(id: 'welcome_email')\nprompt.save('Updated content: Welcome [USER_NAME] to our platform!')\n\n# Via ActiveRecord\nprompt_record = Prompt.find_by(prompt_id: 'welcome_email')\nprompt_record.update!(\n  content: 'Updated content...',\n  metadata: prompt_record.metadata.merge(version: '1.1')\n)\n</code></pre>"},{"location":"storage/activerecord-adapter/#advanced-features","title":"Advanced Features","text":""},{"location":"storage/activerecord-adapter/#query-interface","title":"Query Interface","text":"<pre><code># Configure with query support\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::ActiveRecordAdapter.new(\n    model_class: Prompt,\n    id_column: :prompt_id,\n    content_column: :content,\n    enable_queries: true\n  )\nend\n\n# Search prompts\nresults = PromptManager.storage.search(\n  category: 'email',\n  content_contains: 'welcome'\n)\n\n# List by metadata\nemail_prompts = PromptManager.storage.where(\n  \"metadata-&gt;&gt;'category' = ?\", 'email'\n)\n</code></pre>"},{"location":"storage/activerecord-adapter/#versioning","title":"Versioning","text":"<pre><code># Add versioning to your model\nclass Prompt &lt; ApplicationRecord\n  has_many :prompt_versions, dependent: :destroy\n\n  before_update :create_version\n\n  private\n\n  def create_version\n    if content_changed?\n      prompt_versions.create!(\n        content: content_was,\n        version_number: (prompt_versions.maximum(:version_number) || 0) + 1,\n        created_at: updated_at_was\n      )\n    end\n  end\nend\n\n# Version model\nclass PromptVersion &lt; ApplicationRecord\n  belongs_to :prompt\nend\n\n# Migration for versions\nclass CreatePromptVersions &lt; ActiveRecord::Migration[7.0]\n  def change\n    create_table :prompt_versions do |t|\n      t.references :prompt, null: false, foreign_key: true\n      t.text :content, null: false\n      t.integer :version_number, null: false\n      t.timestamps\n    end\n\n    add_index :prompt_versions, [:prompt_id, :version_number], unique: true\n  end\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#multi-tenancy","title":"Multi-tenancy","text":"<pre><code># Add tenant support\nclass Prompt &lt; ApplicationRecord\n  belongs_to :tenant\n\n  validates :prompt_id, uniqueness: { scope: :tenant_id }\n\n  scope :for_tenant, -&gt;(tenant) { where(tenant: tenant) }\nend\n\n# Configure with tenant scope\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::ActiveRecordAdapter.new(\n    model_class: Prompt,\n    id_column: :prompt_id,\n    content_column: :content,\n    scope: -&gt; { Prompt.for_tenant(Current.tenant) }\n  )\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#performance-optimization","title":"Performance Optimization","text":""},{"location":"storage/activerecord-adapter/#indexing","title":"Indexing","text":"<pre><code># Add performance indexes\nclass AddPromptIndexes &lt; ActiveRecord::Migration[7.0]\n  def change\n    add_index :prompts, :prompt_id, unique: true\n    add_index :prompts, :updated_at\n    add_index :prompts, \"((metadata-&gt;&gt;'category'))\", name: 'index_prompts_on_category'\n    add_index :prompts, :content, type: :gin  # For full-text search (PostgreSQL)\n  end\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#caching","title":"Caching","text":"<pre><code># Configure caching\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::ActiveRecordAdapter.new(\n    model_class: Prompt,\n    id_column: :prompt_id,\n    content_column: :content,\n    cache_queries: true,\n    cache_ttl: 300  # 5 minutes\n  )\nend\n\n# Add caching to your model\nclass Prompt &lt; ApplicationRecord\n  after_update :clear_cache\n  after_destroy :clear_cache\n\n  private\n\n  def clear_cache\n    Rails.cache.delete(\"prompt:#{prompt_id}\")\n  end\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#connection-pooling","title":"Connection Pooling","text":"<pre><code># For high-traffic applications\nclass PromptReadOnlyRecord &lt; ApplicationRecord\n  self.abstract_class = true\n  connects_to database: { reading: :prompt_replica }\nend\n\nclass Prompt &lt; PromptReadOnlyRecord\n  # Read operations use replica database\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#integration-examples","title":"Integration Examples","text":""},{"location":"storage/activerecord-adapter/#rails-controller","title":"Rails Controller","text":"<pre><code>class PromptsController &lt; ApplicationController\n  def show\n    prompt = PromptManager::Prompt.new(id: params[:id])\n    @content = prompt.render(params.permit(:user_name, :product_name))\n  rescue PromptManager::PromptNotFoundError\n    render json: { error: 'Prompt not found' }, status: 404\n  end\n\n  def create\n    prompt = PromptManager::Prompt.new(id: prompt_params[:id])\n    prompt.save(prompt_params[:content])\n\n    render json: { message: 'Prompt created successfully' }\n  rescue =&gt; e\n    render json: { error: e.message }, status: 422\n  end\n\n  private\n\n  def prompt_params\n    params.require(:prompt).permit(:id, :content, :description, metadata: {})\n  end\nend\n</code></pre>"},{"location":"storage/activerecord-adapter/#background-jobs","title":"Background Jobs","text":"<pre><code>class ProcessPromptJob &lt; ApplicationJob\n  def perform(prompt_id, parameters)\n    prompt = PromptManager::Prompt.new(id: prompt_id)\n    result = prompt.render(parameters)\n\n    # Process the result\n    NotificationService.send_message(result)\n  rescue PromptManager::PromptNotFoundError =&gt; e\n    logger.error \"Prompt not found: #{prompt_id}\"\n    # Handle gracefully\n  end\nend\n\n# Usage\nProcessPromptJob.perform_later('daily_report', user_id: user.id)\n</code></pre>"},{"location":"storage/activerecord-adapter/#best-practices","title":"Best Practices","text":"<ol> <li>Use Transactions: Wrap prompt operations in database transactions</li> <li>Validate Content: Add model validations for prompt content</li> <li>Index Strategically: Index frequently queried fields</li> <li>Cache Wisely: Cache frequently accessed prompts</li> <li>Monitor Performance: Track database query performance</li> <li>Backup Regularly: Include prompts in your database backup strategy</li> <li>Version Control: Consider versioning for important prompts</li> <li>Secure Access: Use database-level permissions and encryption</li> </ol>"},{"location":"storage/activerecord-adapter/#migration-from-filesystem","title":"Migration from FileSystem","text":"<pre><code># Migrate from filesystem to database\nclass MigratePromptsToDatabase\n  def self.perform(prompts_dir)\n    Dir.glob(File.join(prompts_dir, '**/*.txt')).each do |file_path|\n      relative_path = Pathname.new(file_path).relative_path_from(Pathname.new(prompts_dir))\n      prompt_id = relative_path.sub_ext('').to_s\n      content = File.read(file_path)\n\n      Prompt.create!(\n        prompt_id: prompt_id,\n        content: content,\n        description: \"Migrated from #{file_path}\",\n        metadata: {\n          original_file: file_path,\n          migrated_at: Time.current\n        }\n      )\n    end\n  end\nend\n\n# Run migration\nMigratePromptsToDatabase.perform('/path/to/prompts')\n</code></pre>"},{"location":"storage/custom-adapters/","title":"Custom Storage Adapters","text":"<p>Create custom storage adapters to integrate PromptManager with any storage system.</p>"},{"location":"storage/custom-adapters/#adapter-interface","title":"Adapter Interface","text":"<p>All storage adapters must inherit from <code>PromptManager::Storage::Base</code> and implement the required methods:</p> <pre><code>class CustomAdapter &lt; PromptManager::Storage::Base\n  def initialize(**options)\n    # Initialize your storage connection\n    super\n  end\n\n  def read(prompt_id)\n    # Return the prompt content as a string\n    # Raise PromptManager::PromptNotFoundError if not found\n  end\n\n  def write(prompt_id, content)\n    # Save the prompt content\n    # Return true on success\n  end\n\n  def exist?(prompt_id)\n    # Return true if prompt exists\n  end\n\n  def delete(prompt_id) \n    # Remove the prompt\n    # Return true on success\n  end\n\n  def list\n    # Return array of all prompt IDs\n  end\nend\n</code></pre>"},{"location":"storage/custom-adapters/#example-redis-adapter","title":"Example: Redis Adapter","text":"<pre><code>require 'redis'\n\nclass RedisAdapter &lt; PromptManager::Storage::Base\n  def initialize(redis_url: 'redis://localhost:6379', key_prefix: 'prompts:', **options)\n    @redis = Redis.new(url: redis_url)\n    @key_prefix = key_prefix\n    super(**options)\n  end\n\n  def read(prompt_id)\n    content = @redis.get(redis_key(prompt_id))\n    raise PromptManager::PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\") unless content\n    content\n  end\n\n  def write(prompt_id, content)\n    @redis.set(redis_key(prompt_id), content)\n    true\n  end\n\n  def exist?(prompt_id)\n    @redis.exists?(redis_key(prompt_id)) &gt; 0\n  end\n\n  def delete(prompt_id)\n    @redis.del(redis_key(prompt_id)) &gt; 0\n  end\n\n  def list\n    keys = @redis.keys(\"#{@key_prefix}*\")\n    keys.map { |key| key.sub(@key_prefix, '') }\n  end\n\n  private\n\n  def redis_key(prompt_id)\n    \"#{@key_prefix}#{prompt_id}\"\n  end\nend\n\n# Configure PromptManager to use Redis\nPromptManager.configure do |config|\n  config.storage = RedisAdapter.new(\n    redis_url: ENV['REDIS_URL'],\n    key_prefix: 'myapp:prompts:'\n  )\nend\n</code></pre>"},{"location":"storage/custom-adapters/#example-s3-adapter","title":"Example: S3 Adapter","text":"<pre><code>require 'aws-sdk-s3'\n\nclass S3Adapter &lt; PromptManager::Storage::Base\n  def initialize(bucket:, region: 'us-east-1', key_prefix: 'prompts/', **options)\n    @bucket = bucket\n    @key_prefix = key_prefix\n    @s3 = Aws::S3::Client.new(region: region)\n    super(**options)\n  end\n\n  def read(prompt_id)\n    response = @s3.get_object(\n      bucket: @bucket,\n      key: s3_key(prompt_id)\n    )\n    response.body.read\n  rescue Aws::S3::Errors::NoSuchKey\n    raise PromptManager::PromptNotFoundError.new(\"Prompt '#{prompt_id}' not found\")\n  end\n\n  def write(prompt_id, content)\n    @s3.put_object(\n      bucket: @bucket,\n      key: s3_key(prompt_id),\n      body: content,\n      content_type: 'text/plain'\n    )\n    true\n  end\n\n  def exist?(prompt_id)\n    @s3.head_object(bucket: @bucket, key: s3_key(prompt_id))\n    true\n  rescue Aws::S3::Errors::NotFound\n    false\n  end\n\n  def delete(prompt_id)\n    @s3.delete_object(bucket: @bucket, key: s3_key(prompt_id))\n    true\n  end\n\n  def list\n    response = @s3.list_objects_v2(\n      bucket: @bucket,\n      prefix: @key_prefix\n    )\n\n    response.contents.map do |object|\n      object.key.sub(@key_prefix, '')\n    end\n  end\n\n  private\n\n  def s3_key(prompt_id)\n    \"#{@key_prefix}#{prompt_id}.txt\"\n  end\nend\n</code></pre>"},{"location":"storage/custom-adapters/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always raise appropriate exceptions</li> <li>Connection Management: Handle connection failures gracefully  </li> <li>Performance: Implement connection pooling where appropriate</li> <li>Security: Use proper authentication and encryption</li> <li>Testing: Write comprehensive tests for your adapter</li> <li>Documentation: Document configuration options and requirements</li> </ol>"},{"location":"storage/custom-adapters/#configuration","title":"Configuration","text":"<p>Register your custom adapter:</p> <pre><code>PromptManager.configure do |config|\n  config.storage = CustomAdapter.new(\n    # Your adapter configuration\n  )\nend\n</code></pre>"},{"location":"storage/filesystem-adapter/","title":"FileSystemAdapter","text":"<p>The FileSystemAdapter is the default storage adapter for PromptManager, storing prompts as files in a directory structure.</p>"},{"location":"storage/filesystem-adapter/#overview","title":"Overview","text":"<p>The FileSystemAdapter stores prompts as individual text files in a configurable directory. This is the simplest and most common storage method.</p>"},{"location":"storage/filesystem-adapter/#configuration","title":"Configuration","text":""},{"location":"storage/filesystem-adapter/#basic-setup","title":"Basic Setup","text":"<pre><code>require 'prompt_manager'\n\n# Use default filesystem storage (~/prompts_dir/)\nprompt = PromptManager::Prompt.new(id: 'welcome_message')\n</code></pre>"},{"location":"storage/filesystem-adapter/#custom-directory","title":"Custom Directory","text":"<pre><code>PromptManager.configure do |config|\n  config.storage = PromptManager::Storage::FileSystemAdapter.new(\n    prompts_dir: '/path/to/your/prompts'\n  )\nend\n</code></pre>"},{"location":"storage/filesystem-adapter/#multiple-directories","title":"Multiple Directories","text":"<pre><code># Search multiple directories in order\nPromptManager.configure do |config|\n  config.storage = PromptManager::Storage::FileSystemAdapter.new(\n    prompts_dir: [\n      '/home/user/project_prompts',\n      '/shared/common_prompts',\n      '/system/default_prompts'\n    ]\n  )\nend\n</code></pre>"},{"location":"storage/filesystem-adapter/#directory-structure","title":"Directory Structure","text":""},{"location":"storage/filesystem-adapter/#basic-structure","title":"Basic Structure","text":"<pre><code>prompts_dir/\n\u251c\u2500\u2500 welcome_message.txt\n\u251c\u2500\u2500 error_response.txt\n\u251c\u2500\u2500 customer_service/\n\u2502   \u251c\u2500\u2500 greeting.txt\n\u2502   \u2514\u2500\u2500 farewell.txt\n\u2514\u2500\u2500 templates/\n    \u251c\u2500\u2500 email_header.txt\n    \u2514\u2500\u2500 email_footer.txt\n</code></pre>"},{"location":"storage/filesystem-adapter/#organizing-prompts","title":"Organizing Prompts","text":"<pre><code># Access nested prompts using path separators\ncustomer_greeting = PromptManager::Prompt.new(id: 'customer_service/greeting')\nemail_header = PromptManager::Prompt.new(id: 'templates/email_header')\n</code></pre>"},{"location":"storage/filesystem-adapter/#file-operations","title":"File Operations","text":""},{"location":"storage/filesystem-adapter/#creating-prompts","title":"Creating Prompts","text":"<pre><code># Prompts are created as .txt files\nprompt = PromptManager::Prompt.new(id: 'new_prompt')\nprompt.save(\"Your prompt content here...\")\n# Creates: prompts_dir/new_prompt.txt\n</code></pre>"},{"location":"storage/filesystem-adapter/#reading-prompts","title":"Reading Prompts","text":"<pre><code># Automatically reads from filesystem\nprompt = PromptManager::Prompt.new(id: 'existing_prompt')\ncontent = prompt.render\n</code></pre>"},{"location":"storage/filesystem-adapter/#updating-prompts","title":"Updating Prompts","text":"<pre><code># Modify the file directly or use save method\nprompt = PromptManager::Prompt.new(id: 'existing_prompt')\nprompt.save(\"Updated content...\")\n</code></pre>"},{"location":"storage/filesystem-adapter/#deleting-prompts","title":"Deleting Prompts","text":"<pre><code># Remove the prompt file\nprompt = PromptManager::Prompt.new(id: 'old_prompt')\nprompt.delete\n</code></pre>"},{"location":"storage/filesystem-adapter/#advanced-features","title":"Advanced Features","text":""},{"location":"storage/filesystem-adapter/#file-extensions","title":"File Extensions","text":"<p>The adapter supports different file extensions:</p> <pre><code># These all work:\n# - welcome.txt\n# - welcome.md\n# - welcome.prompt\n# - welcome (no extension)\n\nprompt = PromptManager::Prompt.new(id: 'welcome')\n# Searches for welcome.txt, then welcome.md, etc.\n</code></pre>"},{"location":"storage/filesystem-adapter/#directory-search-order","title":"Directory Search Order","text":"<p>When using multiple directories, the adapter searches in order:</p> <pre><code>config.storage = PromptManager::Storage::FileSystemAdapter.new(\n  prompts_dir: [\n    './project_prompts',    # First priority\n    '~/shared_prompts',     # Second priority  \n    '/system/prompts'       # Last resort\n  ]\n)\n</code></pre>"},{"location":"storage/filesystem-adapter/#permissions-and-security","title":"Permissions and Security","text":"<pre><code># Set directory permissions\nconfig.storage = PromptManager::Storage::FileSystemAdapter.new(\n  prompts_dir: '/secure/prompts',\n  file_mode: 0600,      # Read/write for owner only\n  dir_mode: 0700        # Access for owner only\n)\n</code></pre>"},{"location":"storage/filesystem-adapter/#error-handling","title":"Error Handling","text":""},{"location":"storage/filesystem-adapter/#common-issues","title":"Common Issues","text":"<pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'missing_prompt')\nrescue PromptManager::PromptNotFoundError =&gt; e\n  puts \"Prompt file not found: #{e.message}\"\nend\n\nbegin\n  prompt.save(\"content\")\nrescue PromptManager::StorageError =&gt; e\n  puts \"Cannot write file: #{e.message}\"\n  # Check permissions, disk space, etc.\nend\n</code></pre>"},{"location":"storage/filesystem-adapter/#file-system-monitoring","title":"File System Monitoring","text":"<pre><code># Watch for file changes (requires additional gems)\nrequire 'listen'\n\nlistener = Listen.to('/path/to/prompts') do |modified, added, removed|\n  puts \"Prompts changed: #{modified + added + removed}\"\n  # Reload prompts if needed\nend\n\nlistener.start\n</code></pre>"},{"location":"storage/filesystem-adapter/#performance-considerations","title":"Performance Considerations","text":""},{"location":"storage/filesystem-adapter/#caching","title":"Caching","text":"<pre><code># Enable file content caching\nPromptManager.configure do |config|\n  config.cache_prompts = true\n  config.cache_ttl = 300  # 5 minutes\nend\n</code></pre>"},{"location":"storage/filesystem-adapter/#large-directories","title":"Large Directories","text":"<p>For directories with many prompts:</p> <pre><code># Use indexing for faster lookups\nconfig.storage = PromptManager::Storage::FileSystemAdapter.new(\n  prompts_dir: '/large/prompt/directory',\n  enable_indexing: true,\n  index_file: '.prompt_index'\n)\n</code></pre>"},{"location":"storage/filesystem-adapter/#best-practices","title":"Best Practices","text":"<ol> <li>Organize by Purpose: Use subdirectories to group related prompts</li> <li>Consistent Naming: Use clear, descriptive prompt IDs</li> <li>Version Control: Store your prompts directory in git</li> <li>Backup Strategy: Regular backups of your prompts directory</li> <li>File Permissions: Secure sensitive prompts with appropriate permissions</li> <li>Documentation: Use comments in prompt files to document purpose and usage</li> </ol>"},{"location":"storage/filesystem-adapter/#migration-from-other-storage","title":"Migration from Other Storage","text":""},{"location":"storage/filesystem-adapter/#from-database","title":"From Database","text":"<pre><code># Export database prompts to filesystem\ndatabase_adapter.all_prompts.each do |prompt_id, content|\n  file_path = File.join(prompts_dir, \"#{prompt_id}.txt\")\n  File.write(file_path, content)\nend\n</code></pre>"},{"location":"storage/filesystem-adapter/#bulk-import","title":"Bulk Import","text":"<pre><code># Import multiple files\nDir.glob('/old/prompts/*.txt').each do |file_path|\n  prompt_id = File.basename(file_path, '.txt')\n  content = File.read(file_path)\n\n  prompt = PromptManager::Prompt.new(id: prompt_id)\n  prompt.save(content)\nend\n</code></pre>"},{"location":"storage/overview/","title":"Storage Adapters Overview","text":"<p>Storage adapters are the backbone of PromptManager, providing the interface between your prompts and their persistence layer. They allow you to store prompts in various backends while maintaining a consistent API.</p>"},{"location":"storage/overview/#what-are-storage-adapters","title":"What are Storage Adapters?","text":"<p>Storage adapters implement a common interface that handles:</p> <ul> <li>Loading prompt text and parameters</li> <li>Saving changes back to storage  </li> <li>Listing available prompts</li> <li>Searching through prompt collections</li> <li>Managing prompt metadata</li> </ul> <p>Think of them as the \"database drivers\" for your prompts - they handle the specifics of where and how your prompts are stored.</p>"},{"location":"storage/overview/#adapter-architecture","title":"Adapter Architecture","text":"<pre><code>graph TB\n    subgraph \"Your Application\"\n        APP[Application Code]\n        PROMPT[PromptManager::Prompt]\n    end\n\n    subgraph \"Adapter Layer\"  \n        INTERFACE[Storage Adapter Interface]\n        FS[FileSystemAdapter]\n        AR[ActiveRecordAdapter]\n        CUSTOM[Custom Adapters]\n    end\n\n    subgraph \"Storage Backends\"\n        FILES[File System]\n        POSTGRES[PostgreSQL]\n        MYSQL[MySQL]\n        REDIS[Redis]\n        S3[AWS S3]\n    end\n\n    APP --&gt; PROMPT\n    PROMPT --&gt; INTERFACE\n    INTERFACE --&gt; FS\n    INTERFACE --&gt; AR  \n    INTERFACE --&gt; CUSTOM\n\n    FS --&gt; FILES\n    AR --&gt; POSTGRES\n    AR --&gt; MYSQL\n    CUSTOM --&gt; REDIS\n    CUSTOM --&gt; S3</code></pre>"},{"location":"storage/overview/#available-adapters","title":"Available Adapters","text":"<p>PromptManager includes two built-in adapters:</p>"},{"location":"storage/overview/#filesystemadapter","title":"FileSystemAdapter","text":"<ul> <li>Best for: Development, small teams, file-based workflows</li> <li>Storage: Local files (<code>.txt</code> for prompts, <code>.json</code> for parameters)</li> <li>Features: Simple setup, version control friendly, human-readable</li> <li>Use cases: Personal projects, documentation, prototype development</li> </ul>"},{"location":"storage/overview/#activerecordadapter","title":"ActiveRecordAdapter","text":"<ul> <li>Best for: Web applications, enterprise deployments, shared access</li> <li>Storage: Any database supported by ActiveRecord (PostgreSQL, MySQL, SQLite, etc.)</li> <li>Features: Transactions, concurrent access, advanced querying</li> <li>Use cases: Production applications, multi-user systems, API backends</li> </ul>"},{"location":"storage/overview/#common-interface","title":"Common Interface","text":"<p>All storage adapters implement the same core methods:</p> <pre><code>module StorageAdapterInterface\n  # Load a prompt's text and parameters\n  def get(id)\n    # Returns: [text_string, parameters_hash]\n  end\n\n  # Save a prompt's text and parameters\n  def save(id, text, parameters)\n    # Persists changes to storage\n  end\n\n  # Delete a prompt\n  def delete(id)\n    # Removes prompt from storage\n  end\n\n  # List all available prompt IDs\n  def list\n    # Returns: array of prompt ID strings\n  end\n\n  # Search for prompts (optional)\n  def search(query)\n    # Returns: array of matching prompt IDs\n  end\nend\n</code></pre>"},{"location":"storage/overview/#choosing-an-adapter","title":"Choosing an Adapter","text":""},{"location":"storage/overview/#use-filesystemadapter-when","title":"Use FileSystemAdapter When:","text":"<p>\u2705 Starting a new project - Simple setup and configuration \u2705 Working solo or small team - Easy to manage and understand \u2705 Version control integration - Files work well with Git \u2705 Human-readable storage - Can edit prompts directly \u2705 Prototyping - Quick to set up and iterate  </p> <p>\u274c Avoid when: High concurrency, complex querying, or web deployment</p>"},{"location":"storage/overview/#use-activerecordadapter-when","title":"Use ActiveRecordAdapter When:","text":"<p>\u2705 Web applications - Integrates with existing Rails/web apps \u2705 Multi-user systems - Handles concurrent access properly \u2705 Complex queries - SQL-based searching and filtering \u2705 Production deployment - Scalable and reliable \u2705 Advanced features - Transactions, migrations, backups  </p> <p>\u274c Avoid when: Simple scripts, file-based workflows, or development experimentation</p>"},{"location":"storage/overview/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"storage/overview/#global-configuration","title":"Global Configuration","text":"<p>Set the adapter once for your entire application:</p> <pre><code># At application startup\nPromptManager::Prompt.storage_adapter = \n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = Rails.root.join('prompts')\n  end.new\n</code></pre>"},{"location":"storage/overview/#per-instance-configuration","title":"Per-Instance Configuration","text":"<p>Use different adapters for different prompt types:</p> <pre><code># Customer service prompts from filesystem\ncustomer_service = PromptManager::Prompt.new(id: 'greeting')\ncustomer_service.storage_adapter = filesystem_adapter\n\n# System prompts from database  \nsystem_prompt = PromptManager::Prompt.new(id: 'api_template')\nsystem_prompt.storage_adapter = activerecord_adapter\n</code></pre>"},{"location":"storage/overview/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Different adapters for different environments:</p> <pre><code>adapter = case Rails.env\nwhen 'development'\n  PromptManager::Storage::FileSystemAdapter.config do |config|\n    config.prompts_dir = 'prompts'\n  end.new\nwhen 'production'\n  PromptManager::Storage::ActiveRecordAdapter.config do |config|\n    config.model = PromptModel\n  end.new  \nend\n\nPromptManager::Prompt.storage_adapter = adapter\n</code></pre>"},{"location":"storage/overview/#adapter-comparison","title":"Adapter Comparison","text":"Feature FileSystemAdapter ActiveRecordAdapter Custom Adapters Setup Complexity Low Medium Varies Concurrent Access Limited Excellent Depends Search Performance Good with tools Excellent Varies Version Control Excellent Poor Varies Backup/Recovery File-based Database tools Depends Human Readable Yes No Depends Scalability Limited High Varies Query Complexity Limited High Varies"},{"location":"storage/overview/#migration-between-adapters","title":"Migration Between Adapters","text":"<p>You can migrate prompts between different adapters:</p> <pre><code># Migration helper\nclass AdapterMigration\n  def self.migrate(from_adapter, to_adapter)\n    prompt_ids = from_adapter.list\n\n    prompt_ids.each do |id|\n      text, parameters = from_adapter.get(id)\n      to_adapter.save(id, text, parameters)\n      puts \"Migrated: #{id}\"\n    end\n  end\nend\n\n# Usage\nold_adapter = FileSystemAdapter.new(prompts_dir: 'old_prompts')\nnew_adapter = ActiveRecordAdapter.new(model: PromptModel)\n\nAdapterMigration.migrate(old_adapter, new_adapter)\n</code></pre>"},{"location":"storage/overview/#performance-considerations","title":"Performance Considerations","text":""},{"location":"storage/overview/#filesystemadapter-performance","title":"FileSystemAdapter Performance","text":"<p>Strengths: - Fast individual prompt access - No database overhead - Works with external search tools (ripgrep, grep)</p> <p>Limitations: - Slow listing operations with many files - No built-in indexing - Limited concurrent write support</p> <p>Optimization tips: <pre><code># Use custom search for better performance\nadapter.config.search_proc = -&gt;(query) {\n  `rg -l \"#{query}\" #{prompts_dir}`.split(\"\\n\").map { |f|\n    File.basename(f, '.txt')\n  }\n}\n</code></pre></p>"},{"location":"storage/overview/#activerecordadapter-performance","title":"ActiveRecordAdapter Performance","text":"<p>Strengths: - SQL-based querying and indexing - Optimized for concurrent access - Built-in caching support</p> <p>Limitations: - Database connection overhead - More complex deployment</p> <p>Optimization tips: <pre><code># Add database indexes\nclass CreatePrompts &lt; ActiveRecord::Migration[7.0]\n  def change\n    create_table :prompts do |t|\n      t.string :name, null: false\n      t.text :content\n      t.json :parameters\n      t.timestamps\n    end\n\n    add_index :prompts, :name, unique: true\n    add_index :prompts, :created_at\n    # Add full-text search index for content\n    add_index :prompts, :content, using: :gin if adapter_name == 'PostgreSQL'\n  end\nend\n</code></pre></p>"},{"location":"storage/overview/#error-handling","title":"Error Handling","text":"<p>All adapters should handle common error scenarios:</p> <pre><code>begin\n  prompt = PromptManager::Prompt.new(id: 'example')\n  text = prompt.to_s\nrescue PromptManager::StorageError =&gt; e\n  case e.message\n  when /not found/\n    puts \"Prompt doesn't exist: #{e.id}\"\n  when /permission denied/\n    puts \"Cannot access storage: #{e.message}\"\n  when /connection failed/\n    puts \"Storage backend unavailable: #{e.message}\"\n  else\n    puts \"Storage error: #{e.message}\"\n  end\nend\n</code></pre>"},{"location":"storage/overview/#testing-with-adapters","title":"Testing with Adapters","text":""},{"location":"storage/overview/#test-adapter","title":"Test Adapter","text":"<p>For testing, create a simple in-memory adapter:</p> <pre><code>class TestAdapter\n  def initialize\n    @storage = {}\n  end\n\n  def get(id)\n    @storage[id] || raise(\"Prompt not found: #{id}\")\n  end\n\n  def save(id, text, parameters)\n    @storage[id] = [text, parameters]\n  end\n\n  def list\n    @storage.keys\n  end\nend\n\n# In your tests\nRSpec.describe \"PromptManager\" do\n  let(:adapter) { TestAdapter.new }\n\n  before do\n    PromptManager::Prompt.storage_adapter = adapter\n    adapter.save('test', 'Hello [NAME]', { '[NAME]' =&gt; 'World' })\n  end\n\n  it \"processes prompts correctly\" do\n    prompt = PromptManager::Prompt.new(id: 'test')\n    expect(prompt.to_s).to eq('Hello World')\n  end\nend\n</code></pre>"},{"location":"storage/overview/#adapter-testing","title":"Adapter Testing","text":"<p>Test your custom adapters with a shared test suite:</p> <pre><code># Shared examples for adapter testing\nRSpec.shared_examples \"storage adapter\" do |adapter_factory|\n  let(:adapter) { adapter_factory.call }\n\n  it \"saves and retrieves prompts\" do\n    adapter.save('test', 'Hello [NAME]', { '[NAME]' =&gt; 'World' })\n    text, params = adapter.get('test')\n\n    expect(text).to eq('Hello [NAME]')\n    expect(params).to eq({ '[NAME]' =&gt; 'World' })\n  end\n\n  it \"lists available prompts\" do\n    adapter.save('test1', 'Content 1', {})\n    adapter.save('test2', 'Content 2', {})\n\n    expect(adapter.list).to contain_exactly('test1', 'test2')\n  end\n\n  it \"raises error for missing prompts\" do\n    expect { adapter.get('missing') }.to raise_error(PromptManager::StorageError)\n  end\nend\n\n# Test your adapters\nRSpec.describe FileSystemAdapter do\n  include_examples \"storage adapter\", -&gt; { \n    FileSystemAdapter.new(prompts_dir: temp_dir) \n  }\nend\n</code></pre>"},{"location":"storage/overview/#best-practices","title":"Best Practices","text":""},{"location":"storage/overview/#1-configuration-management","title":"1. Configuration Management","text":"<pre><code># Use environment variables for sensitive config\ndatabase_config = {\n  host: ENV.fetch('DATABASE_HOST', 'localhost'),\n  password: ENV['DATABASE_PASSWORD'],\n  pool: ENV.fetch('DATABASE_POOL', 5).to_i\n}\n</code></pre>"},{"location":"storage/overview/#2-error-recovery","title":"2. Error Recovery","text":"<pre><code>class ResilientAdapter\n  def initialize(primary, fallback)\n    @primary = primary\n    @fallback = fallback\n  end\n\n  def get(id)\n    @primary.get(id)\n  rescue =&gt; e\n    Rails.logger.warn \"Primary adapter failed: #{e.message}\"\n    @fallback.get(id)\n  end\nend\n</code></pre>"},{"location":"storage/overview/#3-caching-layer","title":"3. Caching Layer","text":"<pre><code>class CachingAdapter\n  def initialize(adapter, cache_store = Rails.cache)\n    @adapter = adapter\n    @cache = cache_store\n  end\n\n  def get(id)\n    @cache.fetch(\"prompt:#{id}\", expires_in: 1.hour) do\n      @adapter.get(id)\n    end\n  end\nend\n</code></pre>"},{"location":"storage/overview/#4-monitoring-and-logging","title":"4. Monitoring and Logging","text":"<pre><code>class InstrumentedAdapter\n  def initialize(adapter)\n    @adapter = adapter\n  end\n\n  def get(id)\n    start_time = Time.current\n    result = @adapter.get(id)\n    duration = Time.current - start_time\n\n    Rails.logger.info \"Prompt loaded: #{id} (#{duration}s)\"\n    result\n  end\nend\n</code></pre>"},{"location":"storage/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Learn specific adapters: FileSystemAdapter | ActiveRecordAdapter</li> <li>Build custom adapters: Custom Adapters Guide</li> <li>See examples: Real-world Usage</li> </ul>"}]}